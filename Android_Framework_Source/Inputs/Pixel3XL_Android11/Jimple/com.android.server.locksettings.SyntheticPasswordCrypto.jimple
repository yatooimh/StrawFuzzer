public class com.android.server.locksettings.SyntheticPasswordCrypto extends java.lang.Object
{
    private static final int AES_KEY_LENGTH;
    private static final byte[] APPLICATION_ID_PERSONALIZATION;
    private static final int DEFAULT_TAG_LENGTH_BITS;
    private static final int PROFILE_KEY_IV_SIZE;
    private static final java.lang.String TAG;
    private static final int USER_AUTHENTICATION_VALIDITY;

    static void <clinit>()
    {
        java.lang.String $r0;
        byte[] $r1;

        <com.android.server.locksettings.SyntheticPasswordCrypto: int USER_AUTHENTICATION_VALIDITY> = 15;

        <com.android.server.locksettings.SyntheticPasswordCrypto: java.lang.String TAG> = "SyntheticPasswordCrypto";

        <com.android.server.locksettings.SyntheticPasswordCrypto: int PROFILE_KEY_IV_SIZE> = 12;

        <com.android.server.locksettings.SyntheticPasswordCrypto: int DEFAULT_TAG_LENGTH_BITS> = 128;

        <com.android.server.locksettings.SyntheticPasswordCrypto: int AES_KEY_LENGTH> = 32;

        $r0 = "application-id";

        $r1 = virtualinvoke $r0.<java.lang.String: byte[] getBytes()>();

        <com.android.server.locksettings.SyntheticPasswordCrypto: byte[] APPLICATION_ID_PERSONALIZATION> = $r1;

        return;
    }

    public void <init>()
    {
        com.android.server.locksettings.SyntheticPasswordCrypto r0;

        r0 := @this: com.android.server.locksettings.SyntheticPasswordCrypto;

        specialinvoke r0.<java.lang.Object: void <init>()>();

        return;
    }

    public static byte[] createBlob(java.lang.String, byte[], byte[], long)
    {
        byte[] r0, r1, $r8, $r9, r22;
        long l0;
        java.security.KeyStore$SecretKeyEntry r2;
        java.lang.String[] $r3, $r5;
        android.security.keystore.KeyProtection$Builder $r4, $r6, $r10, $r11, r20, r21;
        byte $b1;
        android.security.keystore.KeyProtection $r7;
        java.lang.Throwable $r13;
        java.lang.IllegalStateException $r14;
        java.lang.String r15;
        javax.crypto.KeyGenerator r16;
        java.security.SecureRandom r17;
        javax.crypto.SecretKey r18;
        java.security.KeyStore r19;

        r15 := @parameter0: java.lang.String;

        r0 := @parameter1: byte[];

        r1 := @parameter2: byte[];

        l0 := @parameter3: long;

     label1:
        r16 = staticinvoke <javax.crypto.KeyGenerator: javax.crypto.KeyGenerator getInstance(java.lang.String)>("AES");

        r17 = new java.security.SecureRandom;

        specialinvoke r17.<java.security.SecureRandom: void <init>()>();

        virtualinvoke r16.<javax.crypto.KeyGenerator: void init(int,java.security.SecureRandom)>(256, r17);

        r18 = virtualinvoke r16.<javax.crypto.KeyGenerator: javax.crypto.SecretKey generateKey()>();

        r19 = staticinvoke <java.security.KeyStore: java.security.KeyStore getInstance(java.lang.String)>("AndroidKeyStore");

        virtualinvoke r19.<java.security.KeyStore: void load(java.security.KeyStore$LoadStoreParameter)>(null);

        r20 = new android.security.keystore.KeyProtection$Builder;

        specialinvoke r20.<android.security.keystore.KeyProtection$Builder: void <init>(int)>(2);

        $r3 = newarray (java.lang.String)[1];

        $r3[0] = "GCM";

        $r4 = virtualinvoke r20.<android.security.keystore.KeyProtection$Builder: android.security.keystore.KeyProtection$Builder setBlockModes(java.lang.String[])>($r3);

        $r5 = newarray (java.lang.String)[1];

        $r5[0] = "NoPadding";

        $r6 = virtualinvoke $r4.<android.security.keystore.KeyProtection$Builder: android.security.keystore.KeyProtection$Builder setEncryptionPaddings(java.lang.String[])>($r5);

        r21 = virtualinvoke $r6.<android.security.keystore.KeyProtection$Builder: android.security.keystore.KeyProtection$Builder setCriticalToDeviceEncryption(boolean)>(1);

     label2:
        $b1 = l0 cmp 0L;

        if $b1 == 0 goto label4;

     label3:
        $r10 = virtualinvoke r21.<android.security.keystore.KeyProtection$Builder: android.security.keystore.KeyProtection$Builder setUserAuthenticationRequired(boolean)>(1);

        $r11 = virtualinvoke $r10.<android.security.keystore.KeyProtection$Builder: android.security.keystore.KeyProtection$Builder setBoundToSpecificSecureUserId(long)>(l0);

        virtualinvoke $r11.<android.security.keystore.KeyProtection$Builder: android.security.keystore.KeyProtection$Builder setUserAuthenticationValidityDurationSeconds(int)>(15);

     label4:
        r2 = new java.security.KeyStore$SecretKeyEntry;

        specialinvoke r2.<java.security.KeyStore$SecretKeyEntry: void <init>(javax.crypto.SecretKey)>(r18);

        $r7 = virtualinvoke r21.<android.security.keystore.KeyProtection$Builder: android.security.keystore.KeyProtection build()>();

        virtualinvoke r19.<java.security.KeyStore: void setEntry(java.lang.String,java.security.KeyStore$Entry,java.security.KeyStore$ProtectionParameter)>(r15, r2, $r7);

        $r8 = <com.android.server.locksettings.SyntheticPasswordCrypto: byte[] APPLICATION_ID_PERSONALIZATION>;

        $r9 = staticinvoke <com.android.server.locksettings.SyntheticPasswordCrypto: byte[] encrypt(byte[],byte[],byte[])>(r1, $r8, r0);

        r22 = staticinvoke <com.android.server.locksettings.SyntheticPasswordCrypto: byte[] encrypt(javax.crypto.SecretKey,byte[])>(r18, $r9);

     label5:
        return r22;

     label6:
        $r13 := @caughtexception;

        staticinvoke <android.util.Slog: int e(java.lang.String,java.lang.String,java.lang.Throwable)>("SyntheticPasswordCrypto", "Failed to create blob", $r13);

        $r14 = new java.lang.IllegalStateException;

        specialinvoke $r14.<java.lang.IllegalStateException: void <init>(java.lang.String,java.lang.Throwable)>("Failed to encrypt blob", $r13);

        throw $r14;

        catch java.security.cert.CertificateException from label1 to label2 with label6;
        catch java.io.IOException from label1 to label2 with label6;
        catch javax.crypto.BadPaddingException from label1 to label2 with label6;
        catch javax.crypto.IllegalBlockSizeException from label1 to label2 with label6;
        catch java.security.KeyStoreException from label1 to label2 with label6;
        catch javax.crypto.NoSuchPaddingException from label1 to label2 with label6;
        catch java.security.NoSuchAlgorithmException from label1 to label2 with label6;
        catch java.security.InvalidKeyException from label1 to label2 with label6;
        catch java.security.spec.InvalidParameterSpecException from label1 to label2 with label6;
        catch java.security.cert.CertificateException from label3 to label4 with label6;
        catch java.io.IOException from label3 to label4 with label6;
        catch javax.crypto.BadPaddingException from label3 to label4 with label6;
        catch javax.crypto.IllegalBlockSizeException from label3 to label4 with label6;
        catch java.security.KeyStoreException from label3 to label4 with label6;
        catch javax.crypto.NoSuchPaddingException from label3 to label4 with label6;
        catch java.security.NoSuchAlgorithmException from label3 to label4 with label6;
        catch java.security.InvalidKeyException from label3 to label4 with label6;
        catch java.security.spec.InvalidParameterSpecException from label3 to label4 with label6;
        catch java.security.cert.CertificateException from label4 to label5 with label6;
        catch java.io.IOException from label4 to label5 with label6;
        catch javax.crypto.BadPaddingException from label4 to label5 with label6;
        catch javax.crypto.IllegalBlockSizeException from label4 to label5 with label6;
        catch java.security.KeyStoreException from label4 to label5 with label6;
        catch javax.crypto.NoSuchPaddingException from label4 to label5 with label6;
        catch java.security.NoSuchAlgorithmException from label4 to label5 with label6;
        catch java.security.InvalidKeyException from label4 to label5 with label6;
        catch java.security.spec.InvalidParameterSpecException from label4 to label5 with label6;
    }

    private static byte[] decrypt(javax.crypto.SecretKey, byte[]) throws java.security.NoSuchAlgorithmException, javax.crypto.NoSuchPaddingException, java.security.InvalidKeyException, java.security.InvalidAlgorithmParameterException, javax.crypto.IllegalBlockSizeException, javax.crypto.BadPaddingException
    {
        javax.crypto.SecretKey r0;
        byte[] r1, $r4, r5, r6;
        javax.crypto.Cipher r2;
        int $i0;
        javax.crypto.spec.GCMParameterSpec $r3;

        r0 := @parameter0: javax.crypto.SecretKey;

        r5 := @parameter1: byte[];

        if r5 != null goto label1;

        return null;

     label1:
        r1 = staticinvoke <java.util.Arrays: byte[] copyOfRange(byte[],int,int)>(r5, 0, 12);

        $i0 = lengthof r5;

        r6 = staticinvoke <java.util.Arrays: byte[] copyOfRange(byte[],int,int)>(r5, 12, $i0);

        r2 = staticinvoke <javax.crypto.Cipher: javax.crypto.Cipher getInstance(java.lang.String)>("AES/GCM/NoPadding");

        $r3 = new javax.crypto.spec.GCMParameterSpec;

        specialinvoke $r3.<javax.crypto.spec.GCMParameterSpec: void <init>(int,byte[])>(128, r1);

        virtualinvoke r2.<javax.crypto.Cipher: void init(int,java.security.Key,java.security.spec.AlgorithmParameterSpec)>(2, r0, $r3);

        $r4 = virtualinvoke r2.<javax.crypto.Cipher: byte[] doFinal(byte[])>(r6);

        return $r4;
    }

    public static byte[] decrypt(byte[], byte[], byte[])
    {
        byte[] r0, r1, $r4, $r5, r7, r9;
        javax.crypto.spec.SecretKeySpec $r2;
        byte[][] $r3;
        java.lang.Throwable $r6;

        r7 := @parameter0: byte[];

        r0 := @parameter1: byte[];

        r1 := @parameter2: byte[];

        $r2 = new javax.crypto.spec.SecretKeySpec;

        $r3 = newarray (byte[])[1];

        $r3[0] = r7;

        $r4 = staticinvoke <com.android.server.locksettings.SyntheticPasswordCrypto: byte[] personalisedHash(byte[],byte[][])>(r0, $r3);

        $r5 = staticinvoke <java.util.Arrays: byte[] copyOf(byte[],int)>($r4, 32);

        specialinvoke $r2.<javax.crypto.spec.SecretKeySpec: void <init>(byte[],java.lang.String)>($r5, "AES");

     label1:
        r9 = staticinvoke <com.android.server.locksettings.SyntheticPasswordCrypto: byte[] decrypt(javax.crypto.SecretKey,byte[])>($r2, r1);

     label2:
        return r9;

     label3:
        $r6 := @caughtexception;

        staticinvoke <android.util.Slog: int e(java.lang.String,java.lang.String,java.lang.Throwable)>("SyntheticPasswordCrypto", "Failed to decrypt", $r6);

        return null;

        catch java.security.InvalidKeyException from label1 to label2 with label3;
        catch java.security.NoSuchAlgorithmException from label1 to label2 with label3;
        catch javax.crypto.NoSuchPaddingException from label1 to label2 with label3;
        catch javax.crypto.IllegalBlockSizeException from label1 to label2 with label3;
        catch javax.crypto.BadPaddingException from label1 to label2 with label3;
        catch java.security.InvalidAlgorithmParameterException from label1 to label2 with label3;
    }

    public static byte[] decryptBlob(java.lang.String, byte[], byte[])
    {
        java.security.Key $r0;
        java.lang.String $r3, r8;
        byte[] $r4, $r5, r9, r10, r13;
        java.lang.Throwable $r6;
        java.lang.IllegalStateException $r7, r14;
        java.security.KeyStore r11;
        javax.crypto.SecretKey r12;
        java.lang.StringBuilder r15;

        r8 := @parameter0: java.lang.String;

        r9 := @parameter1: byte[];

        r10 := @parameter2: byte[];

     label1:
        r11 = staticinvoke <java.security.KeyStore: java.security.KeyStore getInstance(java.lang.String)>("AndroidKeyStore");

        virtualinvoke r11.<java.security.KeyStore: void load(java.security.KeyStore$LoadStoreParameter)>(null);

        $r0 = virtualinvoke r11.<java.security.KeyStore: java.security.Key getKey(java.lang.String,char[])>(r8, null);

        r12 = (javax.crypto.SecretKey) $r0;

     label2:
        if r12 == null goto label4;

     label3:
        r13 = staticinvoke <com.android.server.locksettings.SyntheticPasswordCrypto: byte[] decrypt(javax.crypto.SecretKey,byte[])>(r12, r9);

        $r4 = <com.android.server.locksettings.SyntheticPasswordCrypto: byte[] APPLICATION_ID_PERSONALIZATION>;

        $r5 = staticinvoke <com.android.server.locksettings.SyntheticPasswordCrypto: byte[] decrypt(byte[],byte[],byte[])>(r10, $r4, r13);

        return $r5;

     label4:
        r14 = new java.lang.IllegalStateException;

        r15 = new java.lang.StringBuilder;

        specialinvoke r15.<java.lang.StringBuilder: void <init>()>();

        virtualinvoke r15.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>("SP key is missing: ");

        virtualinvoke r15.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(r8);

        $r3 = virtualinvoke r15.<java.lang.StringBuilder: java.lang.String toString()>();

        specialinvoke r14.<java.lang.IllegalStateException: void <init>(java.lang.String)>($r3);

        throw r14;

     label5:
        $r6 := @caughtexception;

        staticinvoke <android.util.Slog: int e(java.lang.String,java.lang.String,java.lang.Throwable)>("SyntheticPasswordCrypto", "Failed to decrypt blob", $r6);

        $r7 = new java.lang.IllegalStateException;

        specialinvoke $r7.<java.lang.IllegalStateException: void <init>(java.lang.String,java.lang.Throwable)>("Failed to decrypt blob", $r6);

        throw $r7;

        catch java.security.cert.CertificateException from label1 to label2 with label5;
        catch java.io.IOException from label1 to label2 with label5;
        catch javax.crypto.BadPaddingException from label1 to label2 with label5;
        catch javax.crypto.IllegalBlockSizeException from label1 to label2 with label5;
        catch java.security.KeyStoreException from label1 to label2 with label5;
        catch javax.crypto.NoSuchPaddingException from label1 to label2 with label5;
        catch java.security.NoSuchAlgorithmException from label1 to label2 with label5;
        catch java.security.InvalidKeyException from label1 to label2 with label5;
        catch java.security.UnrecoverableKeyException from label1 to label2 with label5;
        catch java.security.InvalidAlgorithmParameterException from label1 to label2 with label5;
        catch java.security.cert.CertificateException from label3 to label4 with label5;
        catch java.io.IOException from label3 to label4 with label5;
        catch javax.crypto.BadPaddingException from label3 to label4 with label5;
        catch javax.crypto.IllegalBlockSizeException from label3 to label4 with label5;
        catch java.security.KeyStoreException from label3 to label4 with label5;
        catch javax.crypto.NoSuchPaddingException from label3 to label4 with label5;
        catch java.security.NoSuchAlgorithmException from label3 to label4 with label5;
        catch java.security.InvalidKeyException from label3 to label4 with label5;
        catch java.security.UnrecoverableKeyException from label3 to label4 with label5;
        catch java.security.InvalidAlgorithmParameterException from label3 to label4 with label5;
        catch java.security.cert.CertificateException from label4 to label5 with label5;
        catch java.io.IOException from label4 to label5 with label5;
        catch javax.crypto.BadPaddingException from label4 to label5 with label5;
        catch javax.crypto.IllegalBlockSizeException from label4 to label5 with label5;
        catch java.security.KeyStoreException from label4 to label5 with label5;
        catch javax.crypto.NoSuchPaddingException from label4 to label5 with label5;
        catch java.security.NoSuchAlgorithmException from label4 to label5 with label5;
        catch java.security.InvalidKeyException from label4 to label5 with label5;
        catch java.security.UnrecoverableKeyException from label4 to label5 with label5;
        catch java.security.InvalidAlgorithmParameterException from label4 to label5 with label5;
    }

    public static byte[] decryptBlobV1(java.lang.String, byte[], byte[])
    {
        java.security.Key $r0;
        java.lang.String $r3, r9;
        byte[] $r4, $r5, $r6, r10, r11;
        java.lang.Exception $r7;
        java.lang.IllegalStateException $r8, r14;
        java.security.KeyStore r12;
        javax.crypto.SecretKey r13;
        java.lang.StringBuilder r15;

        r9 := @parameter0: java.lang.String;

        r10 := @parameter1: byte[];

        r11 := @parameter2: byte[];

     label1:
        r12 = staticinvoke <java.security.KeyStore: java.security.KeyStore getInstance(java.lang.String)>("AndroidKeyStore");

        virtualinvoke r12.<java.security.KeyStore: void load(java.security.KeyStore$LoadStoreParameter)>(null);

        $r0 = virtualinvoke r12.<java.security.KeyStore: java.security.Key getKey(java.lang.String,char[])>(r9, null);

        r13 = (javax.crypto.SecretKey) $r0;

     label2:
        if r13 == null goto label4;

     label3:
        $r4 = <com.android.server.locksettings.SyntheticPasswordCrypto: byte[] APPLICATION_ID_PERSONALIZATION>;

        $r5 = staticinvoke <com.android.server.locksettings.SyntheticPasswordCrypto: byte[] decrypt(byte[],byte[],byte[])>(r11, $r4, r10);

        $r6 = staticinvoke <com.android.server.locksettings.SyntheticPasswordCrypto: byte[] decrypt(javax.crypto.SecretKey,byte[])>(r13, $r5);

        return $r6;

     label4:
        r14 = new java.lang.IllegalStateException;

        r15 = new java.lang.StringBuilder;

        specialinvoke r15.<java.lang.StringBuilder: void <init>()>();

        virtualinvoke r15.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>("SP key is missing: ");

        virtualinvoke r15.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(r9);

        $r3 = virtualinvoke r15.<java.lang.StringBuilder: java.lang.String toString()>();

        specialinvoke r14.<java.lang.IllegalStateException: void <init>(java.lang.String)>($r3);

        throw r14;

     label5:
        $r7 := @caughtexception;

        staticinvoke <android.util.Slog: int e(java.lang.String,java.lang.String,java.lang.Throwable)>("SyntheticPasswordCrypto", "Failed to decrypt V1 blob", $r7);

        $r8 = new java.lang.IllegalStateException;

        specialinvoke $r8.<java.lang.IllegalStateException: void <init>(java.lang.String,java.lang.Throwable)>("Failed to decrypt blob", $r7);

        throw $r8;

        catch java.lang.Exception from label1 to label2 with label5;
        catch java.lang.Exception from label3 to label4 with label5;
        catch java.lang.Exception from label4 to label5 with label5;
    }

    public static void destroyBlobKey(java.lang.String)
    {
        java.lang.String $r2, r4;
        java.lang.Throwable $r3;
        java.security.KeyStore r5;
        java.lang.StringBuilder r6;

        r4 := @parameter0: java.lang.String;

     label1:
        r5 = staticinvoke <java.security.KeyStore: java.security.KeyStore getInstance(java.lang.String)>("AndroidKeyStore");

        virtualinvoke r5.<java.security.KeyStore: void load(java.security.KeyStore$LoadStoreParameter)>(null);

        virtualinvoke r5.<java.security.KeyStore: void deleteEntry(java.lang.String)>(r4);

        r6 = new java.lang.StringBuilder;

        specialinvoke r6.<java.lang.StringBuilder: void <init>()>();

        virtualinvoke r6.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>("SP key deleted: ");

        virtualinvoke r6.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(r4);

        $r2 = virtualinvoke r6.<java.lang.StringBuilder: java.lang.String toString()>();

        staticinvoke <android.util.Slog: int i(java.lang.String,java.lang.String)>("SyntheticPasswordCrypto", $r2);

     label2:
        goto label4;

     label3:
        $r3 := @caughtexception;

        staticinvoke <android.util.Slog: int e(java.lang.String,java.lang.String,java.lang.Throwable)>("SyntheticPasswordCrypto", "Failed to destroy blob", $r3);

     label4:
        return;

        catch java.security.KeyStoreException from label1 to label2 with label3;
        catch java.security.NoSuchAlgorithmException from label1 to label2 with label3;
        catch java.security.cert.CertificateException from label1 to label2 with label3;
        catch java.io.IOException from label1 to label2 with label3;
    }

    private static byte[] encrypt(javax.crypto.SecretKey, byte[]) throws java.io.IOException, java.security.NoSuchAlgorithmException, javax.crypto.NoSuchPaddingException, java.security.InvalidKeyException, javax.crypto.IllegalBlockSizeException, javax.crypto.BadPaddingException, java.security.spec.InvalidParameterSpecException
    {
        int $i0, $i1, $i2, $i3;
        java.lang.StringBuilder $r0, $r7;
        java.lang.IllegalArgumentException $r3, $r10;
        java.lang.String $r4, $r11;
        java.security.AlgorithmParameters $r5;
        java.security.spec.AlgorithmParameterSpec $r6;
        java.io.ByteArrayOutputStream $r12;
        byte[] $r13, r15, r17, r18;
        javax.crypto.SecretKey r14;
        javax.crypto.Cipher r16;
        javax.crypto.spec.GCMParameterSpec r19;

        r14 := @parameter0: javax.crypto.SecretKey;

        r15 := @parameter1: byte[];

        if r15 != null goto label1;

        return null;

     label1:
        r16 = staticinvoke <javax.crypto.Cipher: javax.crypto.Cipher getInstance(java.lang.String)>("AES/GCM/NoPadding");

        virtualinvoke r16.<javax.crypto.Cipher: void init(int,java.security.Key)>(1, r14);

        r17 = virtualinvoke r16.<javax.crypto.Cipher: byte[] doFinal(byte[])>(r15);

        r18 = virtualinvoke r16.<javax.crypto.Cipher: byte[] getIV()>();

        $i0 = lengthof r18;

        if $i0 != 12 goto label3;

        $r5 = virtualinvoke r16.<javax.crypto.Cipher: java.security.AlgorithmParameters getParameters()>();

        $r6 = virtualinvoke $r5.<java.security.AlgorithmParameters: java.security.spec.AlgorithmParameterSpec getParameterSpec(java.lang.Class)>(class "Ljavax/crypto/spec/GCMParameterSpec;");

        r19 = (javax.crypto.spec.GCMParameterSpec) $r6;

        $i2 = virtualinvoke r19.<javax.crypto.spec.GCMParameterSpec: int getTLen()>();

        if $i2 != 128 goto label2;

        $r12 = new java.io.ByteArrayOutputStream;

        specialinvoke $r12.<java.io.ByteArrayOutputStream: void <init>()>();

        virtualinvoke $r12.<java.io.ByteArrayOutputStream: void write(byte[])>(r18);

        virtualinvoke $r12.<java.io.ByteArrayOutputStream: void write(byte[])>(r17);

        $r13 = virtualinvoke $r12.<java.io.ByteArrayOutputStream: byte[] toByteArray()>();

        return $r13;

     label2:
        $r7 = new java.lang.StringBuilder;

        specialinvoke $r7.<java.lang.StringBuilder: void <init>()>();

        virtualinvoke $r7.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>("Invalid tag length: ");

        $i3 = virtualinvoke r19.<javax.crypto.spec.GCMParameterSpec: int getTLen()>();

        virtualinvoke $r7.<java.lang.StringBuilder: java.lang.StringBuilder append(int)>($i3);

        $r10 = new java.lang.IllegalArgumentException;

        $r11 = virtualinvoke $r7.<java.lang.StringBuilder: java.lang.String toString()>();

        specialinvoke $r10.<java.lang.IllegalArgumentException: void <init>(java.lang.String)>($r11);

        throw $r10;

     label3:
        $r0 = new java.lang.StringBuilder;

        specialinvoke $r0.<java.lang.StringBuilder: void <init>()>();

        virtualinvoke $r0.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>("Invalid iv length: ");

        $i1 = lengthof r18;

        virtualinvoke $r0.<java.lang.StringBuilder: java.lang.StringBuilder append(int)>($i1);

        $r3 = new java.lang.IllegalArgumentException;

        $r4 = virtualinvoke $r0.<java.lang.StringBuilder: java.lang.String toString()>();

        specialinvoke $r3.<java.lang.IllegalArgumentException: void <init>(java.lang.String)>($r4);

        throw $r3;
    }

    public static byte[] encrypt(byte[], byte[], byte[])
    {
        byte[] r0, r1, $r4, $r5, r7, r9;
        javax.crypto.spec.SecretKeySpec $r2;
        byte[][] $r3;
        java.lang.Throwable $r6;

        r7 := @parameter0: byte[];

        r0 := @parameter1: byte[];

        r1 := @parameter2: byte[];

        $r2 = new javax.crypto.spec.SecretKeySpec;

        $r3 = newarray (byte[])[1];

        $r3[0] = r7;

        $r4 = staticinvoke <com.android.server.locksettings.SyntheticPasswordCrypto: byte[] personalisedHash(byte[],byte[][])>(r0, $r3);

        $r5 = staticinvoke <java.util.Arrays: byte[] copyOf(byte[],int)>($r4, 32);

        specialinvoke $r2.<javax.crypto.spec.SecretKeySpec: void <init>(byte[],java.lang.String)>($r5, "AES");

     label1:
        r9 = staticinvoke <com.android.server.locksettings.SyntheticPasswordCrypto: byte[] encrypt(javax.crypto.SecretKey,byte[])>($r2, r1);

     label2:
        return r9;

     label3:
        $r6 := @caughtexception;

        staticinvoke <android.util.Slog: int e(java.lang.String,java.lang.String,java.lang.Throwable)>("SyntheticPasswordCrypto", "Failed to encrypt", $r6);

        return null;

        catch java.security.InvalidKeyException from label1 to label2 with label3;
        catch java.security.NoSuchAlgorithmException from label1 to label2 with label3;
        catch javax.crypto.NoSuchPaddingException from label1 to label2 with label3;
        catch javax.crypto.IllegalBlockSizeException from label1 to label2 with label3;
        catch javax.crypto.BadPaddingException from label1 to label2 with label3;
        catch java.io.IOException from label1 to label2 with label3;
        catch java.security.spec.InvalidParameterSpecException from label1 to label2 with label3;
    }

    protected static transient byte[] personalisedHash(byte[], byte[][])
    {
        byte[][] r0;
        java.security.MessageDigest r1;
        int i0, $i1, i2;
        byte[] $r2, $r3, $r4, r7;
        java.lang.Throwable $r5;
        java.lang.IllegalStateException $r6;
        java.lang.IllegalArgumentException r8;

        r7 := @parameter0: byte[];

        r0 := @parameter1: byte[][];

     label1:
        r1 = staticinvoke <java.security.MessageDigest: java.security.MessageDigest getInstance(java.lang.String)>("SHA-512");

        $i1 = lengthof r7;

        if $i1 > 128 goto label7;

        $r2 = staticinvoke <java.util.Arrays: byte[] copyOf(byte[],int)>(r7, 128);

        virtualinvoke r1.<java.security.MessageDigest: void update(byte[])>($r2);

        i0 = lengthof r0;

     label2:
        i2 = 0;

     label3:
        if i2 >= i0 goto label6;

     label4:
        $r4 = r0[i2];

        virtualinvoke r1.<java.security.MessageDigest: void update(byte[])>($r4);

     label5:
        i2 = i2 + 1;

        goto label3;

     label6:
        $r3 = virtualinvoke r1.<java.security.MessageDigest: byte[] digest()>();

        return $r3;

     label7:
        r8 = new java.lang.IllegalArgumentException;

        specialinvoke r8.<java.lang.IllegalArgumentException: void <init>(java.lang.String)>("Personalisation too long");

        throw r8;

     label8:
        $r5 := @caughtexception;

        $r6 = new java.lang.IllegalStateException;

        specialinvoke $r6.<java.lang.IllegalStateException: void <init>(java.lang.String,java.lang.Throwable)>("NoSuchAlgorithmException for SHA-512", $r5);

        throw $r6;

        catch java.security.NoSuchAlgorithmException from label1 to label2 with label8;
        catch java.security.NoSuchAlgorithmException from label4 to label5 with label8;
        catch java.security.NoSuchAlgorithmException from label6 to label7 with label8;
        catch java.security.NoSuchAlgorithmException from label7 to label8 with label8;
    }
}
