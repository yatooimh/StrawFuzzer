Name: DockObserver
StubClassName: null
isAvaliable: false
Methods : 0 

Name: SurfaceFlinger
StubClassName: null
isAvaliable: true
Methods : 0 

Name: accessibility
StubClassName: android.view.accessibility.IAccessibilityManager
isAvaliable: true
Methods : 26 
	<android.view.accessibility.IAccessibilityManager$Stub$Proxy: int addAccessibilityInteractionConnection(android.view.IWindow,android.os.IBinder,android.view.accessibility.IAccessibilityInteractionConnection,java.lang.String,int)>
	<android.view.accessibility.IAccessibilityManager$Stub$Proxy: long addClient(android.view.accessibility.IAccessibilityManagerClient,int)>
	<android.view.accessibility.IAccessibilityManager$Stub$Proxy: android.os.IBinder asBinder()>
	<android.view.accessibility.IAccessibilityManager$Stub$Proxy: void associateEmbeddedHierarchy(android.os.IBinder,android.os.IBinder)>
	<android.view.accessibility.IAccessibilityManager$Stub$Proxy: void disassociateEmbeddedHierarchy(android.os.IBinder)>
	<android.view.accessibility.IAccessibilityManager$Stub$Proxy: java.util.List getAccessibilityShortcutTargets(int)>
	<android.view.accessibility.IAccessibilityManager$Stub$Proxy: int getAccessibilityWindowId(android.os.IBinder)>
	<android.view.accessibility.IAccessibilityManager$Stub$Proxy: java.util.List getEnabledAccessibilityServiceList(int,int)>
	<android.view.accessibility.IAccessibilityManager$Stub$Proxy: java.util.List getInstalledAccessibilityServiceList(int)>
	<android.view.accessibility.IAccessibilityManager$Stub$Proxy: java.lang.String getInterfaceDescriptor()>
	<android.view.accessibility.IAccessibilityManager$Stub$Proxy: long getRecommendedTimeoutMillis()>
	<android.view.accessibility.IAccessibilityManager$Stub$Proxy: android.os.IBinder getWindowToken(int,int)>
	<android.view.accessibility.IAccessibilityManager$Stub$Proxy: void interrupt(int)>
	<android.view.accessibility.IAccessibilityManager$Stub$Proxy: void notifyAccessibilityButtonClicked(int,java.lang.String)>
	<android.view.accessibility.IAccessibilityManager$Stub$Proxy: void notifyAccessibilityButtonVisibilityChanged(boolean)>
	<android.view.accessibility.IAccessibilityManager$Stub$Proxy: void performAccessibilityShortcut(java.lang.String)>
	<android.view.accessibility.IAccessibilityManager$Stub$Proxy: void registerSystemAction(android.app.RemoteAction,int)>
	<android.view.accessibility.IAccessibilityManager$Stub$Proxy: void registerUiTestAutomationService(android.os.IBinder,android.accessibilityservice.IAccessibilityServiceClient,android.accessibilityservice.AccessibilityServiceInfo,int)>
	<android.view.accessibility.IAccessibilityManager$Stub$Proxy: void removeAccessibilityInteractionConnection(android.view.IWindow)>
	<android.view.accessibility.IAccessibilityManager$Stub$Proxy: void sendAccessibilityEvent(android.view.accessibility.AccessibilityEvent,int)>
	<android.view.accessibility.IAccessibilityManager$Stub$Proxy: boolean sendFingerprintGesture(int)>
	<android.view.accessibility.IAccessibilityManager$Stub$Proxy: void setPictureInPictureActionReplacingConnection(android.view.accessibility.IAccessibilityInteractionConnection)>
	<android.view.accessibility.IAccessibilityManager$Stub$Proxy: void setWindowMagnificationConnection(android.view.accessibility.IWindowMagnificationConnection)>
	<android.view.accessibility.IAccessibilityManager$Stub$Proxy: void temporaryEnableAccessibilityStateUntilKeyguardRemoved(android.content.ComponentName,boolean)>
	<android.view.accessibility.IAccessibilityManager$Stub$Proxy: void unregisterSystemAction(int)>
	<android.view.accessibility.IAccessibilityManager$Stub$Proxy: void unregisterUiTestAutomationService(android.accessibilityservice.IAccessibilityServiceClient)>

Name: account
StubClassName: android.accounts.IAccountManager
isAvaliable: true
Methods : 48 
	<android.accounts.IAccountManager$Stub$Proxy: boolean accountAuthenticated(android.accounts.Account)>
	<android.accounts.IAccountManager$Stub$Proxy: void addAccount(android.accounts.IAccountManagerResponse,java.lang.String,java.lang.String,[Ljava.lang.String;,boolean,android.os.Bundle)>
	<android.accounts.IAccountManager$Stub$Proxy: void addAccountAsUser(android.accounts.IAccountManagerResponse,java.lang.String,java.lang.String,[Ljava.lang.String;,boolean,android.os.Bundle,int)>
	<android.accounts.IAccountManager$Stub$Proxy: boolean addAccountExplicitly(android.accounts.Account,java.lang.String,android.os.Bundle)>
	<android.accounts.IAccountManager$Stub$Proxy: boolean addAccountExplicitlyWithVisibility(android.accounts.Account,java.lang.String,android.os.Bundle,java.util.Map)>
	<android.accounts.IAccountManager$Stub$Proxy: void addSharedAccountsFromParentUser(int,int,java.lang.String)>
	<android.accounts.IAccountManager$Stub$Proxy: android.os.IBinder asBinder()>
	<android.accounts.IAccountManager$Stub$Proxy: void clearPassword(android.accounts.Account)>
	<android.accounts.IAccountManager$Stub$Proxy: void confirmCredentialsAsUser(android.accounts.IAccountManagerResponse,android.accounts.Account,android.os.Bundle,boolean,int)>
	<android.accounts.IAccountManager$Stub$Proxy: void copyAccountToUser(android.accounts.IAccountManagerResponse,android.accounts.Account,int,int)>
	<android.accounts.IAccountManager$Stub$Proxy: android.content.IntentSender createRequestAccountAccessIntentSenderAsUser(android.accounts.Account,java.lang.String,android.os.UserHandle)>
	<android.accounts.IAccountManager$Stub$Proxy: void editProperties(android.accounts.IAccountManagerResponse,java.lang.String,boolean)>
	<android.accounts.IAccountManager$Stub$Proxy: void finishSessionAsUser(android.accounts.IAccountManagerResponse,android.os.Bundle,boolean,android.os.Bundle,int)>
	<android.accounts.IAccountManager$Stub$Proxy: void getAccountByTypeAndFeatures(android.accounts.IAccountManagerResponse,java.lang.String,[Ljava.lang.String;,java.lang.String)>
	<android.accounts.IAccountManager$Stub$Proxy: int getAccountVisibility(android.accounts.Account,java.lang.String)>
	<android.accounts.IAccountManager$Stub$Proxy: java.util.Map getAccountsAndVisibilityForPackage(java.lang.String,java.lang.String)>
	<android.accounts.IAccountManager$Stub$Proxy: [Landroid.accounts.Account; getAccountsAsUser(java.lang.String,int,java.lang.String)>
	<android.accounts.IAccountManager$Stub$Proxy: void getAccountsByFeatures(android.accounts.IAccountManagerResponse,java.lang.String,[Ljava.lang.String;,java.lang.String)>
	<android.accounts.IAccountManager$Stub$Proxy: [Landroid.accounts.Account; getAccountsByTypeForPackage(java.lang.String,java.lang.String,java.lang.String)>
	<android.accounts.IAccountManager$Stub$Proxy: [Landroid.accounts.Account; getAccountsForPackage(java.lang.String,int,java.lang.String)>
	<android.accounts.IAccountManager$Stub$Proxy: void getAuthToken(android.accounts.IAccountManagerResponse,android.accounts.Account,java.lang.String,boolean,boolean,android.os.Bundle)>
	<android.accounts.IAccountManager$Stub$Proxy: void getAuthTokenLabel(android.accounts.IAccountManagerResponse,java.lang.String,java.lang.String)>
	<android.accounts.IAccountManager$Stub$Proxy: [Landroid.accounts.AuthenticatorDescription; getAuthenticatorTypes(int)>
	<android.accounts.IAccountManager$Stub$Proxy: java.lang.String getInterfaceDescriptor()>
	<android.accounts.IAccountManager$Stub$Proxy: java.util.Map getPackagesAndVisibilityForAccount(android.accounts.Account)>
	<android.accounts.IAccountManager$Stub$Proxy: java.lang.String getPassword(android.accounts.Account)>
	<android.accounts.IAccountManager$Stub$Proxy: java.lang.String getPreviousName(android.accounts.Account)>
	<android.accounts.IAccountManager$Stub$Proxy: java.lang.String getUserData(android.accounts.Account,java.lang.String)>
	<android.accounts.IAccountManager$Stub$Proxy: boolean hasAccountAccess(android.accounts.Account,java.lang.String,android.os.UserHandle)>
	<android.accounts.IAccountManager$Stub$Proxy: void hasFeatures(android.accounts.IAccountManagerResponse,android.accounts.Account,[Ljava.lang.String;,java.lang.String)>
	<android.accounts.IAccountManager$Stub$Proxy: void invalidateAuthToken(java.lang.String,java.lang.String)>
	<android.accounts.IAccountManager$Stub$Proxy: void isCredentialsUpdateSuggested(android.accounts.IAccountManagerResponse,android.accounts.Account,java.lang.String)>
	<android.accounts.IAccountManager$Stub$Proxy: void onAccountAccessed(java.lang.String)>
	<android.accounts.IAccountManager$Stub$Proxy: java.lang.String peekAuthToken(android.accounts.Account,java.lang.String)>
	<android.accounts.IAccountManager$Stub$Proxy: void registerAccountListener([Ljava.lang.String;,java.lang.String)>
	<android.accounts.IAccountManager$Stub$Proxy: void removeAccountAsUser(android.accounts.IAccountManagerResponse,android.accounts.Account,boolean,int)>
	<android.accounts.IAccountManager$Stub$Proxy: boolean removeAccountExplicitly(android.accounts.Account)>
	<android.accounts.IAccountManager$Stub$Proxy: void renameAccount(android.accounts.IAccountManagerResponse,android.accounts.Account,java.lang.String)>
	<android.accounts.IAccountManager$Stub$Proxy: boolean setAccountVisibility(android.accounts.Account,java.lang.String,int)>
	<android.accounts.IAccountManager$Stub$Proxy: void setAuthToken(android.accounts.Account,java.lang.String,java.lang.String)>
	<android.accounts.IAccountManager$Stub$Proxy: void setPassword(android.accounts.Account,java.lang.String)>
	<android.accounts.IAccountManager$Stub$Proxy: void setUserData(android.accounts.Account,java.lang.String,java.lang.String)>
	<android.accounts.IAccountManager$Stub$Proxy: boolean someUserHasAccount(android.accounts.Account)>
	<android.accounts.IAccountManager$Stub$Proxy: void startAddAccountSession(android.accounts.IAccountManagerResponse,java.lang.String,java.lang.String,[Ljava.lang.String;,boolean,android.os.Bundle)>
	<android.accounts.IAccountManager$Stub$Proxy: void startUpdateCredentialsSession(android.accounts.IAccountManagerResponse,android.accounts.Account,java.lang.String,boolean,android.os.Bundle)>
	<android.accounts.IAccountManager$Stub$Proxy: void unregisterAccountListener([Ljava.lang.String;,java.lang.String)>
	<android.accounts.IAccountManager$Stub$Proxy: void updateAppPermission(android.accounts.Account,java.lang.String,int,boolean)>
	<android.accounts.IAccountManager$Stub$Proxy: void updateCredentials(android.accounts.IAccountManagerResponse,android.accounts.Account,java.lang.String,boolean,android.os.Bundle)>

Name: activity
StubClassName: android.app.IActivityManager
isAvaliable: true
Methods : 218 
	<android.app.IActivityManager$Stub$Proxy: void addInstrumentationResults(android.app.IApplicationThread,android.os.Bundle)>
	<android.app.IActivityManager$Stub$Proxy: void addPackageDependency(java.lang.String)>
	<android.app.IActivityManager$Stub$Proxy: void appNotResponding(java.lang.String)>
	<android.app.IActivityManager$Stub$Proxy: void appNotRespondingViaProvider(android.os.IBinder)>
	<android.app.IActivityManager$Stub$Proxy: android.os.IBinder asBinder()>
	<android.app.IActivityManager$Stub$Proxy: void attachApplication(android.app.IApplicationThread,long)>
	<android.app.IActivityManager$Stub$Proxy: void backgroundWhitelistUid(int)>
	<android.app.IActivityManager$Stub$Proxy: void backupAgentCreated(java.lang.String,android.os.IBinder,int)>
	<android.app.IActivityManager$Stub$Proxy: boolean bindBackupAgent(java.lang.String,int,int)>
	<android.app.IActivityManager$Stub$Proxy: int bindIsolatedService(android.app.IApplicationThread,android.os.IBinder,android.content.Intent,java.lang.String,android.app.IServiceConnection,int,java.lang.String,java.lang.String,int)>
	<android.app.IActivityManager$Stub$Proxy: int bindService(android.app.IApplicationThread,android.os.IBinder,android.content.Intent,java.lang.String,android.app.IServiceConnection,int,java.lang.String,int)>
	<android.app.IActivityManager$Stub$Proxy: void bootAnimationComplete()>
	<android.app.IActivityManager$Stub$Proxy: int broadcastIntent(android.app.IApplicationThread,android.content.Intent,java.lang.String,android.content.IIntentReceiver,int,java.lang.String,android.os.Bundle,[Ljava.lang.String;,int,android.os.Bundle,boolean,boolean,int)>
	<android.app.IActivityManager$Stub$Proxy: int broadcastIntentWithFeature(android.app.IApplicationThread,java.lang.String,android.content.Intent,java.lang.String,android.content.IIntentReceiver,int,java.lang.String,android.os.Bundle,[Ljava.lang.String;,int,android.os.Bundle,boolean,boolean,int)>
	<android.app.IActivityManager$Stub$Proxy: void cancelIntentSender(android.content.IIntentSender)>
	<android.app.IActivityManager$Stub$Proxy: void cancelRecentsAnimation(boolean)>
	<android.app.IActivityManager$Stub$Proxy: void cancelTaskWindowTransition(int)>
	<android.app.IActivityManager$Stub$Proxy: int checkPermission(java.lang.String,int,int)>
	<android.app.IActivityManager$Stub$Proxy: int checkPermissionWithToken(java.lang.String,int,int,android.os.IBinder)>
	<android.app.IActivityManager$Stub$Proxy: int checkUriPermission(android.net.Uri,int,int,int,int,android.os.IBinder)>
	<android.app.IActivityManager$Stub$Proxy: boolean clearApplicationUserData(java.lang.String,boolean,android.content.pm.IPackageDataObserver,int)>
	<android.app.IActivityManager$Stub$Proxy: void closeSystemDialogs(java.lang.String)>
	<android.app.IActivityManager$Stub$Proxy: void crashApplication(int,int,java.lang.String,int,java.lang.String,boolean)>
	<android.app.IActivityManager$Stub$Proxy: boolean dumpHeap(java.lang.String,int,boolean,boolean,boolean,java.lang.String,android.os.ParcelFileDescriptor,android.os.RemoteCallback)>
	<android.app.IActivityManager$Stub$Proxy: void dumpHeapFinished(java.lang.String)>
	<android.app.IActivityManager$Stub$Proxy: void enterSafeMode()>
	<android.app.IActivityManager$Stub$Proxy: boolean finishActivity(android.os.IBinder,int,android.content.Intent,int)>
	<android.app.IActivityManager$Stub$Proxy: void finishHeavyWeightApp()>
	<android.app.IActivityManager$Stub$Proxy: void finishInstrumentation(android.app.IApplicationThread,int,android.os.Bundle)>
	<android.app.IActivityManager$Stub$Proxy: void finishReceiver(android.os.IBinder,int,java.lang.String,android.os.Bundle,boolean,int)>
	<android.app.IActivityManager$Stub$Proxy: void forceStopPackage(java.lang.String,int)>
	<android.app.IActivityManager$Stub$Proxy: java.util.List getAllStackInfos()>
	<android.app.IActivityManager$Stub$Proxy: java.util.List getBugreportWhitelistedPackages()>
	<android.app.IActivityManager$Stub$Proxy: android.content.res.Configuration getConfiguration()>
	<android.app.IActivityManager$Stub$Proxy: android.app.ContentProviderHolder getContentProvider(android.app.IApplicationThread,java.lang.String,java.lang.String,int,boolean)>
	<android.app.IActivityManager$Stub$Proxy: android.app.ContentProviderHolder getContentProviderExternal(java.lang.String,int,android.os.IBinder,java.lang.String)>
	<android.app.IActivityManager$Stub$Proxy: android.content.pm.UserInfo getCurrentUser()>
	<android.app.IActivityManager$Stub$Proxy: android.app.ActivityManager$StackInfo getFocusedStackInfo()>
	<android.app.IActivityManager$Stub$Proxy: int getForegroundServiceType(android.content.ComponentName,android.os.IBinder)>
	<android.app.IActivityManager$Stub$Proxy: android.content.pm.ParceledListSlice getHistoricalProcessExitReasons(java.lang.String,int,int,int)>
	<android.app.IActivityManager$Stub$Proxy: android.content.Intent getIntentForIntentSender(android.content.IIntentSender)>
	<android.app.IActivityManager$Stub$Proxy: android.content.IIntentSender getIntentSender(int,java.lang.String,android.os.IBinder,java.lang.String,int,[Landroid.content.Intent;,[Ljava.lang.String;,int,android.os.Bundle,int)>
	<android.app.IActivityManager$Stub$Proxy: android.content.IIntentSender getIntentSenderWithFeature(int,java.lang.String,java.lang.String,android.os.IBinder,java.lang.String,int,[Landroid.content.Intent;,[Ljava.lang.String;,int,android.os.Bundle,int)>
	<android.app.IActivityManager$Stub$Proxy: java.lang.String getInterfaceDescriptor()>
	<android.app.IActivityManager$Stub$Proxy: java.lang.String getLaunchedFromPackage(android.os.IBinder)>
	<android.app.IActivityManager$Stub$Proxy: int getLaunchedFromUid(android.os.IBinder)>
	<android.app.IActivityManager$Stub$Proxy: android.os.ParcelFileDescriptor getLifeMonitor()>
	<android.app.IActivityManager$Stub$Proxy: int getLockTaskModeState()>
	<android.app.IActivityManager$Stub$Proxy: void getMemoryInfo(android.app.ActivityManager$MemoryInfo)>
	<android.app.IActivityManager$Stub$Proxy: int getMemoryTrimLevel()>
	<android.app.IActivityManager$Stub$Proxy: void getMyMemoryState(android.app.ActivityManager$RunningAppProcessInfo)>
	<android.app.IActivityManager$Stub$Proxy: java.lang.String getPackageForIntentSender(android.content.IIntentSender)>
	<android.app.IActivityManager$Stub$Proxy: int getPackageProcessState(java.lang.String,java.lang.String)>
	<android.app.IActivityManager$Stub$Proxy: int getProcessLimit()>
	<android.app.IActivityManager$Stub$Proxy: [Landroid.os.Debug$MemoryInfo; getProcessMemoryInfo([I)>
	<android.app.IActivityManager$Stub$Proxy: [J getProcessPss([I)>
	<android.app.IActivityManager$Stub$Proxy: java.util.List getProcessesInErrorState()>
	<android.app.IActivityManager$Stub$Proxy: java.lang.String getProviderMimeType(android.net.Uri,int)>
	<android.app.IActivityManager$Stub$Proxy: void getProviderMimeTypeAsync(android.net.Uri,int,android.os.RemoteCallback)>
	<android.app.IActivityManager$Stub$Proxy: android.content.pm.ParceledListSlice getRecentTasks(int,int,int)>
	<android.app.IActivityManager$Stub$Proxy: java.util.List getRunningAppProcesses()>
	<android.app.IActivityManager$Stub$Proxy: java.util.List getRunningExternalApplications()>
	<android.app.IActivityManager$Stub$Proxy: android.app.PendingIntent getRunningServiceControlPanel(android.content.ComponentName)>
	<android.app.IActivityManager$Stub$Proxy: [I getRunningUserIds()>
	<android.app.IActivityManager$Stub$Proxy: java.util.List getServices(int,int)>
	<android.app.IActivityManager$Stub$Proxy: java.lang.String getTagForIntentSender(android.content.IIntentSender,java.lang.String)>
	<android.app.IActivityManager$Stub$Proxy: android.graphics.Rect getTaskBounds(int)>
	<android.app.IActivityManager$Stub$Proxy: int getTaskForActivity(android.os.IBinder,boolean)>
	<android.app.IActivityManager$Stub$Proxy: android.app.ActivityManager$TaskSnapshot getTaskSnapshot(int,boolean)>
	<android.app.IActivityManager$Stub$Proxy: java.util.List getTasks(int)>
	<android.app.IActivityManager$Stub$Proxy: int getUidForIntentSender(android.content.IIntentSender)>
	<android.app.IActivityManager$Stub$Proxy: int getUidProcessState(int,java.lang.String)>
	<android.app.IActivityManager$Stub$Proxy: void grantUriPermission(android.app.IApplicationThread,java.lang.String,android.net.Uri,int,int)>
	<android.app.IActivityManager$Stub$Proxy: void handleApplicationCrash(android.os.IBinder,android.app.ApplicationErrorReport$ParcelableCrashInfo)>
	<android.app.IActivityManager$Stub$Proxy: void handleApplicationStrictModeViolation(android.os.IBinder,int,android.os.StrictMode$ViolationInfo)>
	<android.app.IActivityManager$Stub$Proxy: boolean handleApplicationWtf(android.os.IBinder,java.lang.String,boolean,android.app.ApplicationErrorReport$ParcelableCrashInfo,int)>
	<android.app.IActivityManager$Stub$Proxy: int handleIncomingUser(int,int,int,boolean,boolean,java.lang.String,java.lang.String)>
	<android.app.IActivityManager$Stub$Proxy: void hang(android.os.IBinder,boolean)>
	<android.app.IActivityManager$Stub$Proxy: boolean isAppFreezerSupported()>
	<android.app.IActivityManager$Stub$Proxy: boolean isAppStartModeDisabled(int,java.lang.String)>
	<android.app.IActivityManager$Stub$Proxy: boolean isBackgroundRestricted(java.lang.String)>
	<android.app.IActivityManager$Stub$Proxy: boolean isInLockTaskMode()>
	<android.app.IActivityManager$Stub$Proxy: boolean isIntentSenderABroadcast(android.content.IIntentSender)>
	<android.app.IActivityManager$Stub$Proxy: boolean isIntentSenderAForegroundService(android.content.IIntentSender)>
	<android.app.IActivityManager$Stub$Proxy: boolean isIntentSenderAnActivity(android.content.IIntentSender)>
	<android.app.IActivityManager$Stub$Proxy: boolean isIntentSenderTargetedToPackage(android.content.IIntentSender)>
	<android.app.IActivityManager$Stub$Proxy: boolean isTopActivityImmersive()>
	<android.app.IActivityManager$Stub$Proxy: boolean isTopOfTask(android.os.IBinder)>
	<android.app.IActivityManager$Stub$Proxy: boolean isUidActive(int,java.lang.String)>
	<android.app.IActivityManager$Stub$Proxy: boolean isUserAMonkey()>
	<android.app.IActivityManager$Stub$Proxy: boolean isUserRunning(int,int)>
	<android.app.IActivityManager$Stub$Proxy: boolean isVrModePackageEnabled(android.content.ComponentName)>
	<android.app.IActivityManager$Stub$Proxy: void killAllBackgroundProcesses()>
	<android.app.IActivityManager$Stub$Proxy: void killApplication(java.lang.String,int,int,java.lang.String)>
	<android.app.IActivityManager$Stub$Proxy: void killApplicationProcess(java.lang.String,int)>
	<android.app.IActivityManager$Stub$Proxy: void killBackgroundProcesses(java.lang.String,int)>
	<android.app.IActivityManager$Stub$Proxy: void killPackageDependents(java.lang.String,int)>
	<android.app.IActivityManager$Stub$Proxy: boolean killPids([I,java.lang.String,boolean)>
	<android.app.IActivityManager$Stub$Proxy: boolean killProcessesBelowForeground(java.lang.String)>
	<android.app.IActivityManager$Stub$Proxy: void killProcessesWhenImperceptible([I,java.lang.String)>
	<android.app.IActivityManager$Stub$Proxy: void killUid(int,int,java.lang.String)>
	<android.app.IActivityManager$Stub$Proxy: void killUidForPermissionChange(int,int,java.lang.String)>
	<android.app.IActivityManager$Stub$Proxy: boolean launchBugReportHandlerApp()>
	<android.app.IActivityManager$Stub$Proxy: void makePackageIdle(java.lang.String,int)>
	<android.app.IActivityManager$Stub$Proxy: boolean moveActivityTaskToBack(android.os.IBinder,boolean)>
	<android.app.IActivityManager$Stub$Proxy: void moveTaskToFront(android.app.IApplicationThread,java.lang.String,int,int,android.os.Bundle)>
	<android.app.IActivityManager$Stub$Proxy: void moveTaskToStack(int,int,boolean)>
	<android.app.IActivityManager$Stub$Proxy: boolean moveTopActivityToPinnedStack(int,android.graphics.Rect)>
	<android.app.IActivityManager$Stub$Proxy: void noteAlarmFinish(android.content.IIntentSender,android.os.WorkSource,int,java.lang.String)>
	<android.app.IActivityManager$Stub$Proxy: void noteAlarmStart(android.content.IIntentSender,android.os.WorkSource,int,java.lang.String)>
	<android.app.IActivityManager$Stub$Proxy: void noteWakeupAlarm(android.content.IIntentSender,android.os.WorkSource,int,java.lang.String,java.lang.String)>
	<android.app.IActivityManager$Stub$Proxy: void notifyCleartextNetwork(int,[B)>
	<android.app.IActivityManager$Stub$Proxy: void notifyLockedProfile(int)>
	<android.app.IActivityManager$Stub$Proxy: android.os.ParcelFileDescriptor openContentUri(java.lang.String)>
	<android.app.IActivityManager$Stub$Proxy: android.os.IBinder peekService(android.content.Intent,java.lang.String,java.lang.String)>
	<android.app.IActivityManager$Stub$Proxy: void performIdleMaintenance()>
	<android.app.IActivityManager$Stub$Proxy: void positionTaskInStack(int,int,int)>
	<android.app.IActivityManager$Stub$Proxy: boolean profileControl(java.lang.String,int,boolean,android.app.ProfilerInfo,int)>
	<android.app.IActivityManager$Stub$Proxy: void publishContentProviders(android.app.IApplicationThread,java.util.List)>
	<android.app.IActivityManager$Stub$Proxy: void publishService(android.os.IBinder,android.content.Intent,android.os.IBinder)>
	<android.app.IActivityManager$Stub$Proxy: boolean refContentProvider(android.os.IBinder,int,int)>
	<android.app.IActivityManager$Stub$Proxy: void registerIntentSenderCancelListener(android.content.IIntentSender,com.android.internal.os.IResultReceiver)>
	<android.app.IActivityManager$Stub$Proxy: void registerProcessObserver(android.app.IProcessObserver)>
	<android.app.IActivityManager$Stub$Proxy: android.content.Intent registerReceiver(android.app.IApplicationThread,java.lang.String,android.content.IIntentReceiver,android.content.IntentFilter,java.lang.String,int,int)>
	<android.app.IActivityManager$Stub$Proxy: android.content.Intent registerReceiverWithFeature(android.app.IApplicationThread,java.lang.String,java.lang.String,android.content.IIntentReceiver,android.content.IntentFilter,java.lang.String,int,int)>
	<android.app.IActivityManager$Stub$Proxy: void registerTaskStackListener(android.app.ITaskStackListener)>
	<android.app.IActivityManager$Stub$Proxy: void registerUidObserver(android.app.IUidObserver,int,int,java.lang.String)>
	<android.app.IActivityManager$Stub$Proxy: void registerUserSwitchObserver(android.app.IUserSwitchObserver,java.lang.String)>
	<android.app.IActivityManager$Stub$Proxy: void removeContentProvider(android.os.IBinder,boolean)>
	<android.app.IActivityManager$Stub$Proxy: void removeContentProviderExternal(java.lang.String,android.os.IBinder)>
	<android.app.IActivityManager$Stub$Proxy: void removeContentProviderExternalAsUser(java.lang.String,android.os.IBinder,int)>
	<android.app.IActivityManager$Stub$Proxy: void removeStack(int)>
	<android.app.IActivityManager$Stub$Proxy: boolean removeTask(int)>
	<android.app.IActivityManager$Stub$Proxy: void requestBugReport(int)>
	<android.app.IActivityManager$Stub$Proxy: void requestBugReportWithDescription(java.lang.String,java.lang.String,int)>
	<android.app.IActivityManager$Stub$Proxy: void requestFullBugReport()>
	<android.app.IActivityManager$Stub$Proxy: void requestInteractiveBugReport()>
	<android.app.IActivityManager$Stub$Proxy: void requestInteractiveBugReportWithDescription(java.lang.String,java.lang.String)>
	<android.app.IActivityManager$Stub$Proxy: void requestRemoteBugReport()>
	<android.app.IActivityManager$Stub$Proxy: void requestSystemServerHeapDump()>
	<android.app.IActivityManager$Stub$Proxy: void requestTelephonyBugReport(java.lang.String,java.lang.String)>
	<android.app.IActivityManager$Stub$Proxy: void requestWifiBugReport(java.lang.String,java.lang.String)>
	<android.app.IActivityManager$Stub$Proxy: void resizeTask(int,android.graphics.Rect,int)>
	<android.app.IActivityManager$Stub$Proxy: void restart()>
	<android.app.IActivityManager$Stub$Proxy: int restartUserInBackground(int)>
	<android.app.IActivityManager$Stub$Proxy: void resumeAppSwitches()>
	<android.app.IActivityManager$Stub$Proxy: void revokeUriPermission(android.app.IApplicationThread,java.lang.String,android.net.Uri,int,int)>
	<android.app.IActivityManager$Stub$Proxy: void scheduleApplicationInfoChanged(java.util.List,int)>
	<android.app.IActivityManager$Stub$Proxy: void sendIdleJobTrigger()>
	<android.app.IActivityManager$Stub$Proxy: int sendIntentSender(android.content.IIntentSender,android.os.IBinder,int,android.content.Intent,java.lang.String,android.content.IIntentReceiver,java.lang.String,android.os.Bundle)>
	<android.app.IActivityManager$Stub$Proxy: void serviceDoneExecuting(android.os.IBinder,int,int,int)>
	<android.app.IActivityManager$Stub$Proxy: void setActivityController(android.app.IActivityController,boolean)>
	<android.app.IActivityManager$Stub$Proxy: void setActivityLocusContext(android.content.ComponentName,android.content.LocusId,android.os.IBinder)>
	<android.app.IActivityManager$Stub$Proxy: void setAgentApp(java.lang.String,java.lang.String)>
	<android.app.IActivityManager$Stub$Proxy: void setAlwaysFinish(boolean)>
	<android.app.IActivityManager$Stub$Proxy: void setDebugApp(java.lang.String,boolean,boolean)>
	<android.app.IActivityManager$Stub$Proxy: void setDumpHeapDebugLimit(java.lang.String,int,long,java.lang.String)>
	<android.app.IActivityManager$Stub$Proxy: void setFocusedStack(int)>
	<android.app.IActivityManager$Stub$Proxy: void setHasTopUi(boolean)>
	<android.app.IActivityManager$Stub$Proxy: void setPackageScreenCompatMode(java.lang.String,int)>
	<android.app.IActivityManager$Stub$Proxy: void setPersistentVrThread(int)>
	<android.app.IActivityManager$Stub$Proxy: void setProcessImportant(android.os.IBinder,int,boolean,java.lang.String)>
	<android.app.IActivityManager$Stub$Proxy: void setProcessLimit(int)>
	<android.app.IActivityManager$Stub$Proxy: boolean setProcessMemoryTrimLevel(java.lang.String,int,int)>
	<android.app.IActivityManager$Stub$Proxy: void setProcessStateSummary([B)>
	<android.app.IActivityManager$Stub$Proxy: void setRenderThread(int)>
	<android.app.IActivityManager$Stub$Proxy: void setRequestedOrientation(android.os.IBinder,int)>
	<android.app.IActivityManager$Stub$Proxy: void setServiceForeground(android.content.ComponentName,android.os.IBinder,int,android.app.Notification,int,int)>
	<android.app.IActivityManager$Stub$Proxy: void setTaskResizeable(int,int)>
	<android.app.IActivityManager$Stub$Proxy: void setUserIsMonkey(boolean)>
	<android.app.IActivityManager$Stub$Proxy: void showBootMessage(java.lang.CharSequence,boolean)>
	<android.app.IActivityManager$Stub$Proxy: void showWaitingForDebugger(android.app.IApplicationThread,boolean)>
	<android.app.IActivityManager$Stub$Proxy: boolean shutdown(int)>
	<android.app.IActivityManager$Stub$Proxy: void signalPersistentProcesses(int)>
	<android.app.IActivityManager$Stub$Proxy: int startActivity(android.app.IApplicationThread,java.lang.String,android.content.Intent,java.lang.String,android.os.IBinder,java.lang.String,int,int,android.app.ProfilerInfo,android.os.Bundle)>
	<android.app.IActivityManager$Stub$Proxy: int startActivityAsUser(android.app.IApplicationThread,java.lang.String,android.content.Intent,java.lang.String,android.os.IBinder,java.lang.String,int,int,android.app.ProfilerInfo,android.os.Bundle,int)>
	<android.app.IActivityManager$Stub$Proxy: int startActivityAsUserWithFeature(android.app.IApplicationThread,java.lang.String,java.lang.String,android.content.Intent,java.lang.String,android.os.IBinder,java.lang.String,int,int,android.app.ProfilerInfo,android.os.Bundle,int)>
	<android.app.IActivityManager$Stub$Proxy: int startActivityFromRecents(int,android.os.Bundle)>
	<android.app.IActivityManager$Stub$Proxy: int startActivityWithFeature(android.app.IApplicationThread,java.lang.String,java.lang.String,android.content.Intent,java.lang.String,android.os.IBinder,java.lang.String,int,int,android.app.ProfilerInfo,android.os.Bundle)>
	<android.app.IActivityManager$Stub$Proxy: boolean startBinderTracking()>
	<android.app.IActivityManager$Stub$Proxy: void startConfirmDeviceCredentialIntent(android.content.Intent,android.os.Bundle)>
	<android.app.IActivityManager$Stub$Proxy: void startDelegateShellPermissionIdentity(int,[Ljava.lang.String;)>
	<android.app.IActivityManager$Stub$Proxy: boolean startInstrumentation(android.content.ComponentName,java.lang.String,int,android.os.Bundle,android.app.IInstrumentationWatcher,android.app.IUiAutomationConnection,int,java.lang.String)>
	<android.app.IActivityManager$Stub$Proxy: void startRecentsActivity(android.content.Intent,android.app.IAssistDataReceiver,android.view.IRecentsAnimationRunner)>
	<android.app.IActivityManager$Stub$Proxy: android.content.ComponentName startService(android.app.IApplicationThread,android.content.Intent,java.lang.String,boolean,java.lang.String,java.lang.String,int)>
	<android.app.IActivityManager$Stub$Proxy: void startSystemLockTaskMode(int)>
	<android.app.IActivityManager$Stub$Proxy: boolean startUserInBackground(int)>
	<android.app.IActivityManager$Stub$Proxy: boolean startUserInBackgroundWithListener(int,android.os.IProgressListener)>
	<android.app.IActivityManager$Stub$Proxy: boolean startUserInForegroundWithListener(int,android.os.IProgressListener)>
	<android.app.IActivityManager$Stub$Proxy: void stopAppSwitches()>
	<android.app.IActivityManager$Stub$Proxy: boolean stopBinderTrackingAndDump(android.os.ParcelFileDescriptor)>
	<android.app.IActivityManager$Stub$Proxy: void stopDelegateShellPermissionIdentity()>
	<android.app.IActivityManager$Stub$Proxy: int stopService(android.app.IApplicationThread,android.content.Intent,java.lang.String,int)>
	<android.app.IActivityManager$Stub$Proxy: boolean stopServiceToken(android.content.ComponentName,android.os.IBinder,int)>
	<android.app.IActivityManager$Stub$Proxy: int stopUser(int,boolean,android.app.IStopUserCallback)>
	<android.app.IActivityManager$Stub$Proxy: int stopUserWithDelayedLocking(int,boolean,android.app.IStopUserCallback)>
	<android.app.IActivityManager$Stub$Proxy: void suppressResizeConfigChanges(boolean)>
	<android.app.IActivityManager$Stub$Proxy: boolean switchUser(int)>
	<android.app.IActivityManager$Stub$Proxy: void unbindBackupAgent(android.content.pm.ApplicationInfo)>
	<android.app.IActivityManager$Stub$Proxy: void unbindFinished(android.os.IBinder,android.content.Intent,boolean)>
	<android.app.IActivityManager$Stub$Proxy: boolean unbindService(android.app.IServiceConnection)>
	<android.app.IActivityManager$Stub$Proxy: void unbroadcastIntent(android.app.IApplicationThread,android.content.Intent,int)>
	<android.app.IActivityManager$Stub$Proxy: void unhandledBack()>
	<android.app.IActivityManager$Stub$Proxy: boolean unlockUser(int,[B,[B,android.os.IProgressListener)>
	<android.app.IActivityManager$Stub$Proxy: void unregisterIntentSenderCancelListener(android.content.IIntentSender,com.android.internal.os.IResultReceiver)>
	<android.app.IActivityManager$Stub$Proxy: void unregisterProcessObserver(android.app.IProcessObserver)>
	<android.app.IActivityManager$Stub$Proxy: void unregisterReceiver(android.content.IIntentReceiver)>
	<android.app.IActivityManager$Stub$Proxy: void unregisterTaskStackListener(android.app.ITaskStackListener)>
	<android.app.IActivityManager$Stub$Proxy: void unregisterUidObserver(android.app.IUidObserver)>
	<android.app.IActivityManager$Stub$Proxy: void unregisterUserSwitchObserver(android.app.IUserSwitchObserver)>
	<android.app.IActivityManager$Stub$Proxy: void unstableProviderDied(android.os.IBinder)>
	<android.app.IActivityManager$Stub$Proxy: boolean updateConfiguration(android.content.res.Configuration)>
	<android.app.IActivityManager$Stub$Proxy: void updateDeviceOwner(java.lang.String)>
	<android.app.IActivityManager$Stub$Proxy: void updateLockTaskPackages(int,[Ljava.lang.String;)>
	<android.app.IActivityManager$Stub$Proxy: boolean updateMccMncConfiguration(java.lang.String,java.lang.String)>
	<android.app.IActivityManager$Stub$Proxy: void updatePersistentConfiguration(android.content.res.Configuration)>
	<android.app.IActivityManager$Stub$Proxy: void updateServiceGroup(android.app.IServiceConnection,int,int)>
	<android.app.IActivityManager$Stub$Proxy: void waitForNetworkStateUpdate(long)>

Name: activity_task
StubClassName: android.app.IActivityTaskManager
isAvaliable: true
Methods : 157 
	<android.app.IActivityTaskManager$Stub$Proxy: void activityDestroyed(android.os.IBinder)>
	<android.app.IActivityTaskManager$Stub$Proxy: void activityIdle(android.os.IBinder,android.content.res.Configuration,boolean)>
	<android.app.IActivityTaskManager$Stub$Proxy: void activityPaused(android.os.IBinder)>
	<android.app.IActivityTaskManager$Stub$Proxy: void activityRelaunched(android.os.IBinder)>
	<android.app.IActivityTaskManager$Stub$Proxy: void activityResumed(android.os.IBinder)>
	<android.app.IActivityTaskManager$Stub$Proxy: void activityStopped(android.os.IBinder,android.os.Bundle,android.os.PersistableBundle,java.lang.CharSequence)>
	<android.app.IActivityTaskManager$Stub$Proxy: void activityTopResumedStateLost()>
	<android.app.IActivityTaskManager$Stub$Proxy: int addAppTask(android.os.IBinder,android.content.Intent,android.app.ActivityManager$TaskDescription,android.graphics.Bitmap)>
	<android.app.IActivityTaskManager$Stub$Proxy: void alwaysShowUnsupportedCompileSdkWarning(android.content.ComponentName)>
	<android.app.IActivityTaskManager$Stub$Proxy: android.os.IBinder asBinder()>
	<android.app.IActivityTaskManager$Stub$Proxy: void cancelRecentsAnimation(boolean)>
	<android.app.IActivityTaskManager$Stub$Proxy: void cancelTaskWindowTransition(int)>
	<android.app.IActivityTaskManager$Stub$Proxy: void clearLaunchParamsForPackages(java.util.List)>
	<android.app.IActivityTaskManager$Stub$Proxy: boolean convertFromTranslucent(android.os.IBinder)>
	<android.app.IActivityTaskManager$Stub$Proxy: boolean convertToTranslucent(android.os.IBinder,android.os.Bundle)>
	<android.app.IActivityTaskManager$Stub$Proxy: void dismissKeyguard(android.os.IBinder,com.android.internal.policy.IKeyguardDismissCallback,java.lang.CharSequence)>
	<android.app.IActivityTaskManager$Stub$Proxy: boolean enterPictureInPictureMode(android.os.IBinder,android.app.PictureInPictureParams)>
	<android.app.IActivityTaskManager$Stub$Proxy: boolean finishActivity(android.os.IBinder,int,android.content.Intent,int)>
	<android.app.IActivityTaskManager$Stub$Proxy: boolean finishActivityAffinity(android.os.IBinder)>
	<android.app.IActivityTaskManager$Stub$Proxy: void finishSubActivity(android.os.IBinder,java.lang.String,int)>
	<android.app.IActivityTaskManager$Stub$Proxy: void finishVoiceTask(android.service.voice.IVoiceInteractionSession)>
	<android.app.IActivityTaskManager$Stub$Proxy: android.content.ComponentName getActivityClassForToken(android.os.IBinder)>
	<android.app.IActivityTaskManager$Stub$Proxy: android.os.Bundle getActivityOptions(android.os.IBinder)>
	<android.app.IActivityTaskManager$Stub$Proxy: java.util.List getAllStackInfos()>
	<android.app.IActivityTaskManager$Stub$Proxy: java.util.List getAllStackInfosOnDisplay(int)>
	<android.app.IActivityTaskManager$Stub$Proxy: android.graphics.Point getAppTaskThumbnailSize()>
	<android.app.IActivityTaskManager$Stub$Proxy: java.util.List getAppTasks(java.lang.String)>
	<android.app.IActivityTaskManager$Stub$Proxy: android.os.Bundle getAssistContextExtras(int)>
	<android.app.IActivityTaskManager$Stub$Proxy: android.content.ComponentName getCallingActivity(android.os.IBinder)>
	<android.app.IActivityTaskManager$Stub$Proxy: java.lang.String getCallingPackage(android.os.IBinder)>
	<android.app.IActivityTaskManager$Stub$Proxy: android.content.pm.ConfigurationInfo getDeviceConfigurationInfo()>
	<android.app.IActivityTaskManager$Stub$Proxy: int getDisplayId(android.os.IBinder)>
	<android.app.IActivityTaskManager$Stub$Proxy: java.util.List getFilteredTasks(int,boolean)>
	<android.app.IActivityTaskManager$Stub$Proxy: android.app.ActivityManager$StackInfo getFocusedStackInfo()>
	<android.app.IActivityTaskManager$Stub$Proxy: int getFrontActivityScreenCompatMode()>
	<android.app.IActivityTaskManager$Stub$Proxy: java.lang.String getInterfaceDescriptor()>
	<android.app.IActivityTaskManager$Stub$Proxy: int getLastResumedActivityUserId()>
	<android.app.IActivityTaskManager$Stub$Proxy: java.lang.String getLaunchedFromPackage(android.os.IBinder)>
	<android.app.IActivityTaskManager$Stub$Proxy: int getLaunchedFromUid(android.os.IBinder)>
	<android.app.IActivityTaskManager$Stub$Proxy: int getLockTaskModeState()>
	<android.app.IActivityTaskManager$Stub$Proxy: int getMaxNumPictureInPictureActions(android.os.IBinder)>
	<android.app.IActivityTaskManager$Stub$Proxy: boolean getPackageAskScreenCompat(java.lang.String)>
	<android.app.IActivityTaskManager$Stub$Proxy: java.lang.String getPackageForToken(android.os.IBinder)>
	<android.app.IActivityTaskManager$Stub$Proxy: int getPackageScreenCompatMode(java.lang.String)>
	<android.app.IActivityTaskManager$Stub$Proxy: android.content.pm.ParceledListSlice getRecentTasks(int,int,int)>
	<android.app.IActivityTaskManager$Stub$Proxy: int getRequestedOrientation(android.os.IBinder)>
	<android.app.IActivityTaskManager$Stub$Proxy: android.app.ActivityManager$StackInfo getStackInfo(int,int)>
	<android.app.IActivityTaskManager$Stub$Proxy: android.app.ActivityManager$StackInfo getStackInfoOnDisplay(int,int,int)>
	<android.app.IActivityTaskManager$Stub$Proxy: android.graphics.Rect getTaskBounds(int)>
	<android.app.IActivityTaskManager$Stub$Proxy: android.app.ActivityManager$TaskDescription getTaskDescription(int)>
	<android.app.IActivityTaskManager$Stub$Proxy: android.graphics.Bitmap getTaskDescriptionIcon(java.lang.String,int)>
	<android.app.IActivityTaskManager$Stub$Proxy: int getTaskForActivity(android.os.IBinder,boolean)>
	<android.app.IActivityTaskManager$Stub$Proxy: android.app.ActivityManager$TaskSnapshot getTaskSnapshot(int,boolean)>
	<android.app.IActivityTaskManager$Stub$Proxy: java.util.List getTasks(int)>
	<android.app.IActivityTaskManager$Stub$Proxy: android.os.IBinder getUriPermissionOwnerForActivity(android.os.IBinder)>
	<android.app.IActivityTaskManager$Stub$Proxy: android.window.IWindowOrganizerController getWindowOrganizerController()>
	<android.app.IActivityTaskManager$Stub$Proxy: void invalidateHomeTaskSnapshot(android.os.IBinder)>
	<android.app.IActivityTaskManager$Stub$Proxy: boolean isActivityStartAllowedOnDisplay(int,android.content.Intent,java.lang.String,int)>
	<android.app.IActivityTaskManager$Stub$Proxy: boolean isAssistDataAllowedOnCurrentActivity()>
	<android.app.IActivityTaskManager$Stub$Proxy: boolean isImmersive(android.os.IBinder)>
	<android.app.IActivityTaskManager$Stub$Proxy: boolean isInLockTaskMode()>
	<android.app.IActivityTaskManager$Stub$Proxy: boolean isRootVoiceInteraction(android.os.IBinder)>
	<android.app.IActivityTaskManager$Stub$Proxy: boolean isTopActivityImmersive()>
	<android.app.IActivityTaskManager$Stub$Proxy: boolean isTopOfTask(android.os.IBinder)>
	<android.app.IActivityTaskManager$Stub$Proxy: void keyguardGoingAway(int)>
	<android.app.IActivityTaskManager$Stub$Proxy: boolean launchAssistIntent(android.content.Intent,int,java.lang.String,int,android.os.Bundle)>
	<android.app.IActivityTaskManager$Stub$Proxy: boolean moveActivityTaskToBack(android.os.IBinder,boolean)>
	<android.app.IActivityTaskManager$Stub$Proxy: void moveStackToDisplay(int,int)>
	<android.app.IActivityTaskManager$Stub$Proxy: void moveTaskToFront(android.app.IApplicationThread,java.lang.String,int,int,android.os.Bundle)>
	<android.app.IActivityTaskManager$Stub$Proxy: void moveTaskToStack(int,int,boolean)>
	<android.app.IActivityTaskManager$Stub$Proxy: boolean moveTopActivityToPinnedStack(int,android.graphics.Rect)>
	<android.app.IActivityTaskManager$Stub$Proxy: boolean navigateUpTo(android.os.IBinder,android.content.Intent,int,android.content.Intent)>
	<android.app.IActivityTaskManager$Stub$Proxy: void notifyActivityDrawn(android.os.IBinder)>
	<android.app.IActivityTaskManager$Stub$Proxy: void notifyEnterAnimationComplete(android.os.IBinder)>
	<android.app.IActivityTaskManager$Stub$Proxy: void notifyLaunchTaskBehindComplete(android.os.IBinder)>
	<android.app.IActivityTaskManager$Stub$Proxy: void onBackPressedOnTaskRoot(android.os.IBinder,android.app.IRequestFinishCallback)>
	<android.app.IActivityTaskManager$Stub$Proxy: void overridePendingTransition(android.os.IBinder,java.lang.String,int,int)>
	<android.app.IActivityTaskManager$Stub$Proxy: void positionTaskInStack(int,int,int)>
	<android.app.IActivityTaskManager$Stub$Proxy: void registerRemoteAnimationForNextActivityStart(java.lang.String,android.view.RemoteAnimationAdapter)>
	<android.app.IActivityTaskManager$Stub$Proxy: void registerRemoteAnimations(android.os.IBinder,android.view.RemoteAnimationDefinition)>
	<android.app.IActivityTaskManager$Stub$Proxy: void registerRemoteAnimationsForDisplay(int,android.view.RemoteAnimationDefinition)>
	<android.app.IActivityTaskManager$Stub$Proxy: void registerTaskStackListener(android.app.ITaskStackListener)>
	<android.app.IActivityTaskManager$Stub$Proxy: boolean releaseActivityInstance(android.os.IBinder)>
	<android.app.IActivityTaskManager$Stub$Proxy: void releaseSomeActivities(android.app.IApplicationThread)>
	<android.app.IActivityTaskManager$Stub$Proxy: void removeAllVisibleRecentTasks()>
	<android.app.IActivityTaskManager$Stub$Proxy: void removeStack(int)>
	<android.app.IActivityTaskManager$Stub$Proxy: void removeStacksInWindowingModes([I)>
	<android.app.IActivityTaskManager$Stub$Proxy: void removeStacksWithActivityTypes([I)>
	<android.app.IActivityTaskManager$Stub$Proxy: boolean removeTask(int)>
	<android.app.IActivityTaskManager$Stub$Proxy: void reportActivityFullyDrawn(android.os.IBinder,boolean)>
	<android.app.IActivityTaskManager$Stub$Proxy: void reportAssistContextExtras(android.os.IBinder,android.os.Bundle,android.app.assist.AssistStructure,android.app.assist.AssistContent,android.net.Uri)>
	<android.app.IActivityTaskManager$Stub$Proxy: void reportSizeConfigurations(android.os.IBinder,[I,[I,[I)>
	<android.app.IActivityTaskManager$Stub$Proxy: boolean requestAssistContextExtras(int,android.app.IAssistDataReceiver,android.os.Bundle,android.os.IBinder,boolean,boolean)>
	<android.app.IActivityTaskManager$Stub$Proxy: boolean requestAutofillData(android.app.IAssistDataReceiver,android.os.Bundle,android.os.IBinder,int)>
	<android.app.IActivityTaskManager$Stub$Proxy: void requestPictureInPictureMode(android.os.IBinder)>
	<android.app.IActivityTaskManager$Stub$Proxy: android.os.IBinder requestStartActivityPermissionToken(android.os.IBinder)>
	<android.app.IActivityTaskManager$Stub$Proxy: void resizeDockedStack(android.graphics.Rect,android.graphics.Rect,android.graphics.Rect,android.graphics.Rect,android.graphics.Rect)>
	<android.app.IActivityTaskManager$Stub$Proxy: boolean resizeTask(int,android.graphics.Rect,int)>
	<android.app.IActivityTaskManager$Stub$Proxy: void restartActivityProcessIfVisible(android.os.IBinder)>
	<android.app.IActivityTaskManager$Stub$Proxy: void resumeAppSwitches()>
	<android.app.IActivityTaskManager$Stub$Proxy: void setActivityController(android.app.IActivityController,boolean)>
	<android.app.IActivityTaskManager$Stub$Proxy: void setDisablePreviewScreenshots(android.os.IBinder,boolean)>
	<android.app.IActivityTaskManager$Stub$Proxy: void setDisplayToSingleTaskInstance(int)>
	<android.app.IActivityTaskManager$Stub$Proxy: void setFocusedStack(int)>
	<android.app.IActivityTaskManager$Stub$Proxy: void setFocusedTask(int)>
	<android.app.IActivityTaskManager$Stub$Proxy: void setFrontActivityScreenCompatMode(int)>
	<android.app.IActivityTaskManager$Stub$Proxy: void setImmersive(android.os.IBinder,boolean)>
	<android.app.IActivityTaskManager$Stub$Proxy: void setInheritShowWhenLocked(android.os.IBinder,boolean)>
	<android.app.IActivityTaskManager$Stub$Proxy: void setLockScreenShown(boolean,boolean)>
	<android.app.IActivityTaskManager$Stub$Proxy: void setPackageAskScreenCompat(java.lang.String,boolean)>
	<android.app.IActivityTaskManager$Stub$Proxy: void setPackageScreenCompatMode(java.lang.String,int)>
	<android.app.IActivityTaskManager$Stub$Proxy: void setPersistentVrThread(int)>
	<android.app.IActivityTaskManager$Stub$Proxy: void setPictureInPictureParams(android.os.IBinder,android.app.PictureInPictureParams)>
	<android.app.IActivityTaskManager$Stub$Proxy: void setRequestedOrientation(android.os.IBinder,int)>
	<android.app.IActivityTaskManager$Stub$Proxy: void setShowWhenLocked(android.os.IBinder,boolean)>
	<android.app.IActivityTaskManager$Stub$Proxy: void setSplitScreenResizing(boolean)>
	<android.app.IActivityTaskManager$Stub$Proxy: void setTaskDescription(android.os.IBinder,android.app.ActivityManager$TaskDescription)>
	<android.app.IActivityTaskManager$Stub$Proxy: void setTaskResizeable(int,int)>
	<android.app.IActivityTaskManager$Stub$Proxy: boolean setTaskWindowingMode(int,int,boolean)>
	<android.app.IActivityTaskManager$Stub$Proxy: boolean setTaskWindowingModeSplitScreenPrimary(int,boolean)>
	<android.app.IActivityTaskManager$Stub$Proxy: void setTurnScreenOn(android.os.IBinder,boolean)>
	<android.app.IActivityTaskManager$Stub$Proxy: void setVoiceKeepAwake(android.service.voice.IVoiceInteractionSession,boolean)>
	<android.app.IActivityTaskManager$Stub$Proxy: int setVrMode(android.os.IBinder,boolean,android.content.ComponentName)>
	<android.app.IActivityTaskManager$Stub$Proxy: void setVrThread(int)>
	<android.app.IActivityTaskManager$Stub$Proxy: boolean shouldUpRecreateTask(android.os.IBinder,java.lang.String)>
	<android.app.IActivityTaskManager$Stub$Proxy: boolean showAssistFromActivity(android.os.IBinder,android.os.Bundle)>
	<android.app.IActivityTaskManager$Stub$Proxy: void showLockTaskEscapeMessage(android.os.IBinder)>
	<android.app.IActivityTaskManager$Stub$Proxy: int startActivities(android.app.IApplicationThread,java.lang.String,java.lang.String,[Landroid.content.Intent;,[Ljava.lang.String;,android.os.IBinder,android.os.Bundle,int)>
	<android.app.IActivityTaskManager$Stub$Proxy: int startActivity(android.app.IApplicationThread,java.lang.String,java.lang.String,android.content.Intent,java.lang.String,android.os.IBinder,java.lang.String,int,int,android.app.ProfilerInfo,android.os.Bundle)>
	<android.app.IActivityTaskManager$Stub$Proxy: android.app.WaitResult startActivityAndWait(android.app.IApplicationThread,java.lang.String,java.lang.String,android.content.Intent,java.lang.String,android.os.IBinder,java.lang.String,int,int,android.app.ProfilerInfo,android.os.Bundle,int)>
	<android.app.IActivityTaskManager$Stub$Proxy: int startActivityAsCaller(android.app.IApplicationThread,java.lang.String,android.content.Intent,java.lang.String,android.os.IBinder,java.lang.String,int,int,android.app.ProfilerInfo,android.os.Bundle,android.os.IBinder,boolean,int)>
	<android.app.IActivityTaskManager$Stub$Proxy: int startActivityAsUser(android.app.IApplicationThread,java.lang.String,java.lang.String,android.content.Intent,java.lang.String,android.os.IBinder,java.lang.String,int,int,android.app.ProfilerInfo,android.os.Bundle,int)>
	<android.app.IActivityTaskManager$Stub$Proxy: int startActivityFromRecents(int,android.os.Bundle)>
	<android.app.IActivityTaskManager$Stub$Proxy: int startActivityIntentSender(android.app.IApplicationThread,android.content.IIntentSender,android.os.IBinder,android.content.Intent,java.lang.String,android.os.IBinder,java.lang.String,int,int,int,android.os.Bundle)>
	<android.app.IActivityTaskManager$Stub$Proxy: int startActivityWithConfig(android.app.IApplicationThread,java.lang.String,java.lang.String,android.content.Intent,java.lang.String,android.os.IBinder,java.lang.String,int,int,android.content.res.Configuration,android.os.Bundle,int)>
	<android.app.IActivityTaskManager$Stub$Proxy: int startAssistantActivity(java.lang.String,java.lang.String,int,int,android.content.Intent,java.lang.String,android.os.Bundle,int)>
	<android.app.IActivityTaskManager$Stub$Proxy: boolean startDreamActivity(android.content.Intent)>
	<android.app.IActivityTaskManager$Stub$Proxy: void startLocalVoiceInteraction(android.os.IBinder,android.os.Bundle)>
	<android.app.IActivityTaskManager$Stub$Proxy: void startLockTaskModeByToken(android.os.IBinder)>
	<android.app.IActivityTaskManager$Stub$Proxy: boolean startNextMatchingActivity(android.os.IBinder,android.content.Intent,android.os.Bundle)>
	<android.app.IActivityTaskManager$Stub$Proxy: void startRecentsActivity(android.content.Intent,android.app.IAssistDataReceiver,android.view.IRecentsAnimationRunner)>
	<android.app.IActivityTaskManager$Stub$Proxy: void startSystemLockTaskMode(int)>
	<android.app.IActivityTaskManager$Stub$Proxy: int startVoiceActivity(java.lang.String,java.lang.String,int,int,android.content.Intent,java.lang.String,android.service.voice.IVoiceInteractionSession,com.android.internal.app.IVoiceInteractor,int,android.app.ProfilerInfo,android.os.Bundle,int)>
	<android.app.IActivityTaskManager$Stub$Proxy: void stopAppSwitches()>
	<android.app.IActivityTaskManager$Stub$Proxy: void stopLocalVoiceInteraction(android.os.IBinder)>
	<android.app.IActivityTaskManager$Stub$Proxy: void stopLockTaskModeByToken(android.os.IBinder)>
	<android.app.IActivityTaskManager$Stub$Proxy: void stopSystemLockTaskMode()>
	<android.app.IActivityTaskManager$Stub$Proxy: boolean supportsLocalVoiceInteraction()>
	<android.app.IActivityTaskManager$Stub$Proxy: void suppressResizeConfigChanges(boolean)>
	<android.app.IActivityTaskManager$Stub$Proxy: void toggleFreeformWindowingMode(android.os.IBinder)>
	<android.app.IActivityTaskManager$Stub$Proxy: void unhandledBack()>
	<android.app.IActivityTaskManager$Stub$Proxy: void unregisterRemoteAnimations(android.os.IBinder)>
	<android.app.IActivityTaskManager$Stub$Proxy: void unregisterTaskStackListener(android.app.ITaskStackListener)>
	<android.app.IActivityTaskManager$Stub$Proxy: boolean updateConfiguration(android.content.res.Configuration)>
	<android.app.IActivityTaskManager$Stub$Proxy: void updateLockTaskFeatures(int,int)>
	<android.app.IActivityTaskManager$Stub$Proxy: void updateLockTaskPackages(int,[Ljava.lang.String;)>
	<android.app.IActivityTaskManager$Stub$Proxy: boolean willActivityBeVisible(android.os.IBinder)>

Name: adb
StubClassName: null
isAvaliable: false
Methods : 0 

Name: alarm
StubClassName: android.app.IAlarmManager
isAvaliable: true
Methods : 9 
	<android.app.IAlarmManager$Stub$Proxy: android.os.IBinder asBinder()>
	<android.app.IAlarmManager$Stub$Proxy: long currentNetworkTimeMillis()>
	<android.app.IAlarmManager$Stub$Proxy: java.lang.String getInterfaceDescriptor()>
	<android.app.IAlarmManager$Stub$Proxy: android.app.AlarmManager$AlarmClockInfo getNextAlarmClock(int)>
	<android.app.IAlarmManager$Stub$Proxy: long getNextWakeFromIdleTime()>
	<android.app.IAlarmManager$Stub$Proxy: void remove(android.app.PendingIntent,android.app.IAlarmListener)>
	<android.app.IAlarmManager$Stub$Proxy: void set(java.lang.String,int,long,long,long,int,android.app.PendingIntent,android.app.IAlarmListener,java.lang.String,android.os.WorkSource,android.app.AlarmManager$AlarmClockInfo)>
	<android.app.IAlarmManager$Stub$Proxy: boolean setTime(long)>
	<android.app.IAlarmManager$Stub$Proxy: void setTimeZone(java.lang.String)>

Name: android.hardware.identity.IIdentityCredentialStore/default
StubClassName: null
isAvaliable: false
Methods : 0 

Name: android.hardware.power.IPower/default
StubClassName: null
isAvaliable: false
Methods : 0 

Name: android.hardware.rebootescrow.IRebootEscrow/default
StubClassName: null
isAvaliable: false
Methods : 0 

Name: android.os.UpdateEngineService
StubClassName: null
isAvaliable: false
Methods : 0 

Name: android.security.identity
StubClassName: android.security.identity.ICredentialStoreFactory
isAvaliable: true
Methods : 3 
	<android.security.identity.ICredentialStoreFactory$Stub$Proxy: android.os.IBinder asBinder()>
	<android.security.identity.ICredentialStoreFactory$Stub$Proxy: android.security.identity.ICredentialStore getCredentialStore(int)>
	<android.security.identity.ICredentialStoreFactory$Stub$Proxy: java.lang.String getInterfaceDescriptor()>

Name: android.security.keystore
StubClassName: android.security.keystore.IKeystoreService
isAvaliable: true
Methods : 39 
	<android.security.keystore.IKeystoreService$Stub$Proxy: int abort(android.security.keystore.IKeystoreResponseCallback,android.os.IBinder)>
	<android.security.keystore.IKeystoreService$Stub$Proxy: int addAuthToken([B)>
	<android.security.keystore.IKeystoreService$Stub$Proxy: int addRngEntropy(android.security.keystore.IKeystoreResponseCallback,[B,int)>
	<android.security.keystore.IKeystoreService$Stub$Proxy: android.os.IBinder asBinder()>
	<android.security.keystore.IKeystoreService$Stub$Proxy: int attestDeviceIds(android.security.keystore.IKeystoreCertificateChainCallback,android.security.keymaster.KeymasterArguments)>
	<android.security.keystore.IKeystoreService$Stub$Proxy: int attestKey(android.security.keystore.IKeystoreCertificateChainCallback,java.lang.String,android.security.keymaster.KeymasterArguments)>
	<android.security.keystore.IKeystoreService$Stub$Proxy: int begin(android.security.keystore.IKeystoreOperationResultCallback,android.os.IBinder,java.lang.String,int,boolean,android.security.keymaster.KeymasterArguments,[B,int)>
	<android.security.keystore.IKeystoreService$Stub$Proxy: int cancelConfirmationPrompt(android.os.IBinder)>
	<android.security.keystore.IKeystoreService$Stub$Proxy: int clear_uid(long)>
	<android.security.keystore.IKeystoreService$Stub$Proxy: int del(java.lang.String,int)>
	<android.security.keystore.IKeystoreService$Stub$Proxy: int exist(java.lang.String,int)>
	<android.security.keystore.IKeystoreService$Stub$Proxy: int exportKey(android.security.keystore.IKeystoreExportKeyCallback,java.lang.String,int,android.security.keymaster.KeymasterBlob,android.security.keymaster.KeymasterBlob,int)>
	<android.security.keystore.IKeystoreService$Stub$Proxy: int finish(android.security.keystore.IKeystoreOperationResultCallback,android.os.IBinder,android.security.keymaster.KeymasterArguments,[B,[B,[B)>
	<android.security.keystore.IKeystoreService$Stub$Proxy: int generateKey(android.security.keystore.IKeystoreKeyCharacteristicsCallback,java.lang.String,android.security.keymaster.KeymasterArguments,[B,int,int)>
	<android.security.keystore.IKeystoreService$Stub$Proxy: [B get(java.lang.String,int)>
	<android.security.keystore.IKeystoreService$Stub$Proxy: java.lang.String getInterfaceDescriptor()>
	<android.security.keystore.IKeystoreService$Stub$Proxy: int getKeyCharacteristics(android.security.keystore.IKeystoreKeyCharacteristicsCallback,java.lang.String,android.security.keymaster.KeymasterBlob,android.security.keymaster.KeymasterBlob,int)>
	<android.security.keystore.IKeystoreService$Stub$Proxy: int getState(int)>
	<android.security.keystore.IKeystoreService$Stub$Proxy: void getTokensForCredstore(long,long,int,android.security.keystore.ICredstoreTokenCallback)>
	<android.security.keystore.IKeystoreService$Stub$Proxy: long getmtime(java.lang.String,int)>
	<android.security.keystore.IKeystoreService$Stub$Proxy: java.lang.String grant(java.lang.String,int)>
	<android.security.keystore.IKeystoreService$Stub$Proxy: int importKey(android.security.keystore.IKeystoreKeyCharacteristicsCallback,java.lang.String,android.security.keymaster.KeymasterArguments,int,[B,int,int)>
	<android.security.keystore.IKeystoreService$Stub$Proxy: int importWrappedKey(android.security.keystore.IKeystoreKeyCharacteristicsCallback,java.lang.String,[B,java.lang.String,[B,android.security.keymaster.KeymasterArguments,long,long)>
	<android.security.keystore.IKeystoreService$Stub$Proxy: int insert(java.lang.String,[B,int,int)>
	<android.security.keystore.IKeystoreService$Stub$Proxy: boolean isConfirmationPromptSupported()>
	<android.security.keystore.IKeystoreService$Stub$Proxy: int isEmpty(int)>
	<android.security.keystore.IKeystoreService$Stub$Proxy: int is_hardware_backed(java.lang.String)>
	<android.security.keystore.IKeystoreService$Stub$Proxy: [Ljava.lang.String; list(java.lang.String,int)>
	<android.security.keystore.IKeystoreService$Stub$Proxy: int listUidsOfAuthBoundKeys(java.util.List)>
	<android.security.keystore.IKeystoreService$Stub$Proxy: int lock(int)>
	<android.security.keystore.IKeystoreService$Stub$Proxy: int onDeviceOffBody()>
	<android.security.keystore.IKeystoreService$Stub$Proxy: int onKeyguardVisibilityChanged(boolean,int)>
	<android.security.keystore.IKeystoreService$Stub$Proxy: int onUserAdded(int,int)>
	<android.security.keystore.IKeystoreService$Stub$Proxy: int onUserPasswordChanged(int,java.lang.String)>
	<android.security.keystore.IKeystoreService$Stub$Proxy: int onUserRemoved(int)>
	<android.security.keystore.IKeystoreService$Stub$Proxy: int presentConfirmationPrompt(android.os.IBinder,java.lang.String,[B,java.lang.String,int)>
	<android.security.keystore.IKeystoreService$Stub$Proxy: int ungrant(java.lang.String,int)>
	<android.security.keystore.IKeystoreService$Stub$Proxy: int unlock(int,java.lang.String)>
	<android.security.keystore.IKeystoreService$Stub$Proxy: int update(android.security.keystore.IKeystoreOperationResultCallback,android.os.IBinder,android.security.keymaster.KeymasterArguments,[B)>

Name: android.service.gatekeeper.IGateKeeperService
StubClassName: android.service.gatekeeper.IGateKeeperService
isAvaliable: true
Methods : 8 
	<android.service.gatekeeper.IGateKeeperService$Stub$Proxy: android.os.IBinder asBinder()>
	<android.service.gatekeeper.IGateKeeperService$Stub$Proxy: void clearSecureUserId(int)>
	<android.service.gatekeeper.IGateKeeperService$Stub$Proxy: android.service.gatekeeper.GateKeeperResponse enroll(int,[B,[B,[B)>
	<android.service.gatekeeper.IGateKeeperService$Stub$Proxy: java.lang.String getInterfaceDescriptor()>
	<android.service.gatekeeper.IGateKeeperService$Stub$Proxy: long getSecureUserId(int)>
	<android.service.gatekeeper.IGateKeeperService$Stub$Proxy: void reportDeviceSetupComplete()>
	<android.service.gatekeeper.IGateKeeperService$Stub$Proxy: android.service.gatekeeper.GateKeeperResponse verify(int,[B,[B)>
	<android.service.gatekeeper.IGateKeeperService$Stub$Proxy: android.service.gatekeeper.GateKeeperResponse verifyChallenge(int,long,[B,[B)>

Name: app_binding
StubClassName: null
isAvaliable: false
Methods : 0 

Name: app_integrity
StubClassName: null
isAvaliable: false
Methods : 0 

Name: app_prediction
StubClassName: android.app.prediction.IPredictionManager
isAvaliable: true
Methods : 10 
	<android.app.prediction.IPredictionManager$Stub$Proxy: android.os.IBinder asBinder()>
	<android.app.prediction.IPredictionManager$Stub$Proxy: void createPredictionSession(android.app.prediction.AppPredictionContext,android.app.prediction.AppPredictionSessionId)>
	<android.app.prediction.IPredictionManager$Stub$Proxy: java.lang.String getInterfaceDescriptor()>
	<android.app.prediction.IPredictionManager$Stub$Proxy: void notifyAppTargetEvent(android.app.prediction.AppPredictionSessionId,android.app.prediction.AppTargetEvent)>
	<android.app.prediction.IPredictionManager$Stub$Proxy: void notifyLaunchLocationShown(android.app.prediction.AppPredictionSessionId,java.lang.String,android.content.pm.ParceledListSlice)>
	<android.app.prediction.IPredictionManager$Stub$Proxy: void onDestroyPredictionSession(android.app.prediction.AppPredictionSessionId)>
	<android.app.prediction.IPredictionManager$Stub$Proxy: void registerPredictionUpdates(android.app.prediction.AppPredictionSessionId,android.app.prediction.IPredictionCallback)>
	<android.app.prediction.IPredictionManager$Stub$Proxy: void requestPredictionUpdate(android.app.prediction.AppPredictionSessionId)>
	<android.app.prediction.IPredictionManager$Stub$Proxy: void sortAppTargets(android.app.prediction.AppPredictionSessionId,android.content.pm.ParceledListSlice,android.app.prediction.IPredictionCallback)>
	<android.app.prediction.IPredictionManager$Stub$Proxy: void unregisterPredictionUpdates(android.app.prediction.AppPredictionSessionId,android.app.prediction.IPredictionCallback)>

Name: appops
StubClassName: com.android.internal.app.IAppOpsService
isAvaliable: true
Methods : 48 
	<com.android.internal.app.IAppOpsService$Stub$Proxy: void addHistoricalOps(android.app.AppOpsManager$HistoricalOps)>
	<com.android.internal.app.IAppOpsService$Stub$Proxy: android.os.IBinder asBinder()>
	<com.android.internal.app.IAppOpsService$Stub$Proxy: int checkAudioOperation(int,int,int,java.lang.String)>
	<com.android.internal.app.IAppOpsService$Stub$Proxy: int checkOperation(int,int,java.lang.String)>
	<com.android.internal.app.IAppOpsService$Stub$Proxy: int checkOperationRaw(int,int,java.lang.String)>
	<com.android.internal.app.IAppOpsService$Stub$Proxy: int checkPackage(int,java.lang.String)>
	<com.android.internal.app.IAppOpsService$Stub$Proxy: void clearHistory()>
	<com.android.internal.app.IAppOpsService$Stub$Proxy: void collectNoteOpCallsForValidation(java.lang.String,int,java.lang.String,long)>
	<com.android.internal.app.IAppOpsService$Stub$Proxy: android.app.RuntimeAppOpAccessMessage collectRuntimeAppOpAccessMessage()>
	<com.android.internal.app.IAppOpsService$Stub$Proxy: java.util.List extractAsyncOps(java.lang.String)>
	<com.android.internal.app.IAppOpsService$Stub$Proxy: void finishOperation(android.os.IBinder,int,int,java.lang.String,java.lang.String)>
	<com.android.internal.app.IAppOpsService$Stub$Proxy: void getHistoricalOps(int,java.lang.String,java.lang.String,java.util.List,int,long,long,int,android.os.RemoteCallback)>
	<com.android.internal.app.IAppOpsService$Stub$Proxy: void getHistoricalOpsFromDiskRaw(int,java.lang.String,java.lang.String,java.util.List,int,long,long,int,android.os.RemoteCallback)>
	<com.android.internal.app.IAppOpsService$Stub$Proxy: java.lang.String getInterfaceDescriptor()>
	<com.android.internal.app.IAppOpsService$Stub$Proxy: java.util.List getOpsForPackage(int,java.lang.String,[I)>
	<com.android.internal.app.IAppOpsService$Stub$Proxy: java.util.List getPackagesForOps([I)>
	<com.android.internal.app.IAppOpsService$Stub$Proxy: java.util.List getUidOps(int,[I)>
	<com.android.internal.app.IAppOpsService$Stub$Proxy: boolean isOperationActive(int,int,java.lang.String)>
	<com.android.internal.app.IAppOpsService$Stub$Proxy: int noteOperation(int,int,java.lang.String,java.lang.String,boolean,java.lang.String,boolean)>
	<com.android.internal.app.IAppOpsService$Stub$Proxy: int noteProxyOperation(int,int,java.lang.String,java.lang.String,int,java.lang.String,java.lang.String,boolean,java.lang.String,boolean)>
	<com.android.internal.app.IAppOpsService$Stub$Proxy: void offsetHistory(long)>
	<com.android.internal.app.IAppOpsService$Stub$Proxy: int permissionToOpCode(java.lang.String)>
	<com.android.internal.app.IAppOpsService$Stub$Proxy: void rebootHistory(long)>
	<com.android.internal.app.IAppOpsService$Stub$Proxy: void reloadNonHistoricalState()>
	<com.android.internal.app.IAppOpsService$Stub$Proxy: void removeUser(int)>
	<com.android.internal.app.IAppOpsService$Stub$Proxy: com.android.internal.app.MessageSamplingConfig reportRuntimeAppOpAccessMessageAndGetConfig(java.lang.String,android.app.SyncNotedAppOp,java.lang.String)>
	<com.android.internal.app.IAppOpsService$Stub$Proxy: void resetAllModes(int,java.lang.String)>
	<com.android.internal.app.IAppOpsService$Stub$Proxy: void resetHistoryParameters()>
	<com.android.internal.app.IAppOpsService$Stub$Proxy: void setAudioRestriction(int,int,int,int,[Ljava.lang.String;)>
	<com.android.internal.app.IAppOpsService$Stub$Proxy: void setCameraAudioRestriction(int)>
	<com.android.internal.app.IAppOpsService$Stub$Proxy: void setHistoryParameters(int,long,int)>
	<com.android.internal.app.IAppOpsService$Stub$Proxy: void setMode(int,int,java.lang.String,int)>
	<com.android.internal.app.IAppOpsService$Stub$Proxy: void setUidMode(int,int,int)>
	<com.android.internal.app.IAppOpsService$Stub$Proxy: void setUserRestriction(int,boolean,android.os.IBinder,int,[Ljava.lang.String;)>
	<com.android.internal.app.IAppOpsService$Stub$Proxy: void setUserRestrictions(android.os.Bundle,android.os.IBinder,int)>
	<com.android.internal.app.IAppOpsService$Stub$Proxy: boolean shouldCollectNotes(int)>
	<com.android.internal.app.IAppOpsService$Stub$Proxy: int startOperation(android.os.IBinder,int,int,java.lang.String,java.lang.String,boolean,boolean,java.lang.String,boolean)>
	<com.android.internal.app.IAppOpsService$Stub$Proxy: void startWatchingActive([I,com.android.internal.app.IAppOpsActiveCallback)>
	<com.android.internal.app.IAppOpsService$Stub$Proxy: void startWatchingAsyncNoted(java.lang.String,com.android.internal.app.IAppOpsAsyncNotedCallback)>
	<com.android.internal.app.IAppOpsService$Stub$Proxy: void startWatchingMode(int,java.lang.String,com.android.internal.app.IAppOpsCallback)>
	<com.android.internal.app.IAppOpsService$Stub$Proxy: void startWatchingModeWithFlags(int,java.lang.String,int,com.android.internal.app.IAppOpsCallback)>
	<com.android.internal.app.IAppOpsService$Stub$Proxy: void startWatchingNoted([I,com.android.internal.app.IAppOpsNotedCallback)>
	<com.android.internal.app.IAppOpsService$Stub$Proxy: void startWatchingStarted([I,com.android.internal.app.IAppOpsStartedCallback)>
	<com.android.internal.app.IAppOpsService$Stub$Proxy: void stopWatchingActive(com.android.internal.app.IAppOpsActiveCallback)>
	<com.android.internal.app.IAppOpsService$Stub$Proxy: void stopWatchingAsyncNoted(java.lang.String,com.android.internal.app.IAppOpsAsyncNotedCallback)>
	<com.android.internal.app.IAppOpsService$Stub$Proxy: void stopWatchingMode(com.android.internal.app.IAppOpsCallback)>
	<com.android.internal.app.IAppOpsService$Stub$Proxy: void stopWatchingNoted(com.android.internal.app.IAppOpsNotedCallback)>
	<com.android.internal.app.IAppOpsService$Stub$Proxy: void stopWatchingStarted(com.android.internal.app.IAppOpsStartedCallback)>

Name: appwidget
StubClassName: com.android.internal.appwidget.IAppWidgetService
isAvaliable: true
Methods : 29 
	<com.android.internal.appwidget.IAppWidgetService$Stub$Proxy: int allocateAppWidgetId(java.lang.String,int)>
	<com.android.internal.appwidget.IAppWidgetService$Stub$Proxy: android.os.IBinder asBinder()>
	<com.android.internal.appwidget.IAppWidgetService$Stub$Proxy: boolean bindAppWidgetId(java.lang.String,int,int,android.content.ComponentName,android.os.Bundle)>
	<com.android.internal.appwidget.IAppWidgetService$Stub$Proxy: boolean bindRemoteViewsService(java.lang.String,int,android.content.Intent,android.app.IApplicationThread,android.os.IBinder,android.app.IServiceConnection,int)>
	<com.android.internal.appwidget.IAppWidgetService$Stub$Proxy: android.content.IntentSender createAppWidgetConfigIntentSender(java.lang.String,int,int)>
	<com.android.internal.appwidget.IAppWidgetService$Stub$Proxy: void deleteAllHosts()>
	<com.android.internal.appwidget.IAppWidgetService$Stub$Proxy: void deleteAppWidgetId(java.lang.String,int)>
	<com.android.internal.appwidget.IAppWidgetService$Stub$Proxy: void deleteHost(java.lang.String,int)>
	<com.android.internal.appwidget.IAppWidgetService$Stub$Proxy: [I getAppWidgetIds(android.content.ComponentName)>
	<com.android.internal.appwidget.IAppWidgetService$Stub$Proxy: [I getAppWidgetIdsForHost(java.lang.String,int)>
	<com.android.internal.appwidget.IAppWidgetService$Stub$Proxy: android.appwidget.AppWidgetProviderInfo getAppWidgetInfo(java.lang.String,int)>
	<com.android.internal.appwidget.IAppWidgetService$Stub$Proxy: android.os.Bundle getAppWidgetOptions(java.lang.String,int)>
	<com.android.internal.appwidget.IAppWidgetService$Stub$Proxy: android.widget.RemoteViews getAppWidgetViews(java.lang.String,int)>
	<com.android.internal.appwidget.IAppWidgetService$Stub$Proxy: android.content.pm.ParceledListSlice getInstalledProvidersForProfile(int,int,java.lang.String)>
	<com.android.internal.appwidget.IAppWidgetService$Stub$Proxy: java.lang.String getInterfaceDescriptor()>
	<com.android.internal.appwidget.IAppWidgetService$Stub$Proxy: boolean hasBindAppWidgetPermission(java.lang.String,int)>
	<com.android.internal.appwidget.IAppWidgetService$Stub$Proxy: boolean isBoundWidgetPackage(java.lang.String,int)>
	<com.android.internal.appwidget.IAppWidgetService$Stub$Proxy: boolean isRequestPinAppWidgetSupported()>
	<com.android.internal.appwidget.IAppWidgetService$Stub$Proxy: void noteAppWidgetTapped(java.lang.String,int)>
	<com.android.internal.appwidget.IAppWidgetService$Stub$Proxy: void notifyAppWidgetViewDataChanged(java.lang.String,[I,int)>
	<com.android.internal.appwidget.IAppWidgetService$Stub$Proxy: void partiallyUpdateAppWidgetIds(java.lang.String,[I,android.widget.RemoteViews)>
	<com.android.internal.appwidget.IAppWidgetService$Stub$Proxy: boolean requestPinAppWidget(java.lang.String,android.content.ComponentName,android.os.Bundle,android.content.IntentSender)>
	<com.android.internal.appwidget.IAppWidgetService$Stub$Proxy: void setBindAppWidgetPermission(java.lang.String,int,boolean)>
	<com.android.internal.appwidget.IAppWidgetService$Stub$Proxy: android.content.pm.ParceledListSlice startListening(com.android.internal.appwidget.IAppWidgetHost,java.lang.String,int,[I)>
	<com.android.internal.appwidget.IAppWidgetService$Stub$Proxy: void stopListening(java.lang.String,int)>
	<com.android.internal.appwidget.IAppWidgetService$Stub$Proxy: void updateAppWidgetIds(java.lang.String,[I,android.widget.RemoteViews)>
	<com.android.internal.appwidget.IAppWidgetService$Stub$Proxy: void updateAppWidgetOptions(java.lang.String,int,android.os.Bundle)>
	<com.android.internal.appwidget.IAppWidgetService$Stub$Proxy: void updateAppWidgetProvider(android.content.ComponentName,android.widget.RemoteViews)>
	<com.android.internal.appwidget.IAppWidgetService$Stub$Proxy: void updateAppWidgetProviderInfo(android.content.ComponentName,java.lang.String)>

Name: audio
StubClassName: android.media.IAudioService
isAvaliable: true
Methods : 118 
	<android.media.IAudioService$Stub$Proxy: int abandonAudioFocus(android.media.IAudioFocusDispatcher,java.lang.String,android.media.AudioAttributes,java.lang.String)>
	<android.media.IAudioService$Stub$Proxy: int addMixForPolicy(android.media.audiopolicy.AudioPolicyConfig,android.media.audiopolicy.IAudioPolicyCallback)>
	<android.media.IAudioService$Stub$Proxy: void adjustStreamVolume(int,int,int,java.lang.String)>
	<android.media.IAudioService$Stub$Proxy: void adjustSuggestedStreamVolume(int,int,int,java.lang.String,java.lang.String)>
	<android.media.IAudioService$Stub$Proxy: android.os.IBinder asBinder()>
	<android.media.IAudioService$Stub$Proxy: void avrcpSupportsAbsoluteVolume(java.lang.String,boolean)>
	<android.media.IAudioService$Stub$Proxy: void disableRingtoneSync(int)>
	<android.media.IAudioService$Stub$Proxy: void disableSafeMediaVolume(java.lang.String)>
	<android.media.IAudioService$Stub$Proxy: int dispatchFocusChange(android.media.AudioFocusInfo,int,android.media.audiopolicy.IAudioPolicyCallback)>
	<android.media.IAudioService$Stub$Proxy: void forceRemoteSubmixFullVolume(boolean,android.os.IBinder)>
	<android.media.IAudioService$Stub$Proxy: void forceVolumeControlStream(int,android.os.IBinder)>
	<android.media.IAudioService$Stub$Proxy: java.util.List getActivePlaybackConfigurations()>
	<android.media.IAudioService$Stub$Proxy: java.util.List getActiveRecordingConfigurations()>
	<android.media.IAudioService$Stub$Proxy: int getAllowedCapturePolicy()>
	<android.media.IAudioService$Stub$Proxy: java.util.List getAudioProductStrategies()>
	<android.media.IAudioService$Stub$Proxy: java.util.List getAudioVolumeGroups()>
	<android.media.IAudioService$Stub$Proxy: int getCurrentAudioFocus()>
	<android.media.IAudioService$Stub$Proxy: int getDeviceVolumeBehavior(android.media.AudioDeviceAttributes)>
	<android.media.IAudioService$Stub$Proxy: java.util.List getDevicesForAttributes(android.media.AudioAttributes)>
	<android.media.IAudioService$Stub$Proxy: int getFocusRampTimeMs(int,android.media.AudioAttributes)>
	<android.media.IAudioService$Stub$Proxy: java.lang.String getInterfaceDescriptor()>
	<android.media.IAudioService$Stub$Proxy: int getLastAudibleStreamVolume(int)>
	<android.media.IAudioService$Stub$Proxy: int getMaxVolumeIndexForAttributes(android.media.AudioAttributes)>
	<android.media.IAudioService$Stub$Proxy: int getMinVolumeIndexForAttributes(android.media.AudioAttributes)>
	<android.media.IAudioService$Stub$Proxy: int getMode()>
	<android.media.IAudioService$Stub$Proxy: android.media.AudioDeviceAttributes getPreferredDeviceForStrategy(int)>
	<android.media.IAudioService$Stub$Proxy: int getRingerModeExternal()>
	<android.media.IAudioService$Stub$Proxy: int getRingerModeInternal()>
	<android.media.IAudioService$Stub$Proxy: android.media.IRingtonePlayer getRingtonePlayer()>
	<android.media.IAudioService$Stub$Proxy: int getStreamMaxVolume(int)>
	<android.media.IAudioService$Stub$Proxy: int getStreamMinVolume(int)>
	<android.media.IAudioService$Stub$Proxy: int getStreamVolume(int)>
	<android.media.IAudioService$Stub$Proxy: [I getSupportedSystemUsages()>
	<android.media.IAudioService$Stub$Proxy: int getUiSoundsStreamType()>
	<android.media.IAudioService$Stub$Proxy: int getVibrateSetting(int)>
	<android.media.IAudioService$Stub$Proxy: int getVolumeIndexForAttributes(android.media.AudioAttributes)>
	<android.media.IAudioService$Stub$Proxy: void handleBluetoothA2dpDeviceConfigChange(android.bluetooth.BluetoothDevice)>
	<android.media.IAudioService$Stub$Proxy: void handleVolumeKey(android.view.KeyEvent,boolean,java.lang.String,java.lang.String)>
	<android.media.IAudioService$Stub$Proxy: boolean hasHapticChannels(android.net.Uri)>
	<android.media.IAudioService$Stub$Proxy: boolean hasRegisteredDynamicPolicy()>
	<android.media.IAudioService$Stub$Proxy: boolean isAudioServerRunning()>
	<android.media.IAudioService$Stub$Proxy: boolean isBluetoothA2dpOn()>
	<android.media.IAudioService$Stub$Proxy: boolean isBluetoothScoOn()>
	<android.media.IAudioService$Stub$Proxy: boolean isCallScreeningModeSupported()>
	<android.media.IAudioService$Stub$Proxy: boolean isCameraSoundForced()>
	<android.media.IAudioService$Stub$Proxy: boolean isHdmiSystemAudioSupported()>
	<android.media.IAudioService$Stub$Proxy: boolean isMasterMute()>
	<android.media.IAudioService$Stub$Proxy: boolean isMicrophoneMuted()>
	<android.media.IAudioService$Stub$Proxy: boolean isSpeakerphoneOn()>
	<android.media.IAudioService$Stub$Proxy: boolean isStreamAffectedByMute(int)>
	<android.media.IAudioService$Stub$Proxy: boolean isStreamAffectedByRingerMode(int)>
	<android.media.IAudioService$Stub$Proxy: boolean isStreamMute(int)>
	<android.media.IAudioService$Stub$Proxy: boolean isValidRingerMode(int)>
	<android.media.IAudioService$Stub$Proxy: boolean loadSoundEffects()>
	<android.media.IAudioService$Stub$Proxy: void notifyVolumeControllerVisible(android.media.IVolumeController,boolean)>
	<android.media.IAudioService$Stub$Proxy: void playSoundEffect(int)>
	<android.media.IAudioService$Stub$Proxy: void playSoundEffectVolume(int,float)>
	<android.media.IAudioService$Stub$Proxy: void playerAttributes(int,android.media.AudioAttributes)>
	<android.media.IAudioService$Stub$Proxy: void playerEvent(int,int)>
	<android.media.IAudioService$Stub$Proxy: void playerHasOpPlayAudio(int,boolean)>
	<android.media.IAudioService$Stub$Proxy: void recorderEvent(int,int)>
	<android.media.IAudioService$Stub$Proxy: java.lang.String registerAudioPolicy(android.media.audiopolicy.AudioPolicyConfig,android.media.audiopolicy.IAudioPolicyCallback,boolean,boolean,boolean,boolean,android.media.projection.IMediaProjection)>
	<android.media.IAudioService$Stub$Proxy: void registerAudioServerStateDispatcher(android.media.IAudioServerStateDispatcher)>
	<android.media.IAudioService$Stub$Proxy: void registerPlaybackCallback(android.media.IPlaybackConfigDispatcher)>
	<android.media.IAudioService$Stub$Proxy: void registerRecordingCallback(android.media.IRecordingConfigDispatcher)>
	<android.media.IAudioService$Stub$Proxy: void registerStrategyPreferredDeviceDispatcher(android.media.IStrategyPreferredDeviceDispatcher)>
	<android.media.IAudioService$Stub$Proxy: void releasePlayer(int)>
	<android.media.IAudioService$Stub$Proxy: void releaseRecorder(int)>
	<android.media.IAudioService$Stub$Proxy: void reloadAudioSettings()>
	<android.media.IAudioService$Stub$Proxy: int removeMixForPolicy(android.media.audiopolicy.AudioPolicyConfig,android.media.audiopolicy.IAudioPolicyCallback)>
	<android.media.IAudioService$Stub$Proxy: int removePreferredDeviceForStrategy(int)>
	<android.media.IAudioService$Stub$Proxy: int removeUidDeviceAffinity(android.media.audiopolicy.IAudioPolicyCallback,int)>
	<android.media.IAudioService$Stub$Proxy: int removeUserIdDeviceAffinity(android.media.audiopolicy.IAudioPolicyCallback,int)>
	<android.media.IAudioService$Stub$Proxy: int requestAudioFocus(android.media.AudioAttributes,int,android.os.IBinder,android.media.IAudioFocusDispatcher,java.lang.String,java.lang.String,int,android.media.audiopolicy.IAudioPolicyCallback,int)>
	<android.media.IAudioService$Stub$Proxy: int setAllowedCapturePolicy(int)>
	<android.media.IAudioService$Stub$Proxy: void setBluetoothA2dpDeviceConnectionStateSuppressNoisyIntent(android.bluetooth.BluetoothDevice,int,int,boolean,int)>
	<android.media.IAudioService$Stub$Proxy: void setBluetoothA2dpOn(boolean)>
	<android.media.IAudioService$Stub$Proxy: void setBluetoothHearingAidDeviceConnectionState(android.bluetooth.BluetoothDevice,int,boolean,int)>
	<android.media.IAudioService$Stub$Proxy: void setBluetoothScoOn(boolean)>
	<android.media.IAudioService$Stub$Proxy: void setDeviceVolumeBehavior(android.media.AudioDeviceAttributes,int,java.lang.String)>
	<android.media.IAudioService$Stub$Proxy: int setFocusPropertiesForPolicy(int,android.media.audiopolicy.IAudioPolicyCallback)>
	<android.media.IAudioService$Stub$Proxy: void setFocusRequestResultFromExtPolicy(android.media.AudioFocusInfo,int,android.media.audiopolicy.IAudioPolicyCallback)>
	<android.media.IAudioService$Stub$Proxy: int setHdmiSystemAudioSupported(boolean)>
	<android.media.IAudioService$Stub$Proxy: void setMasterMute(boolean,int,java.lang.String,int)>
	<android.media.IAudioService$Stub$Proxy: void setMicrophoneMute(boolean,java.lang.String,int)>
	<android.media.IAudioService$Stub$Proxy: void setMicrophoneMuteFromSwitch(boolean)>
	<android.media.IAudioService$Stub$Proxy: void setMode(int,android.os.IBinder,java.lang.String)>
	<android.media.IAudioService$Stub$Proxy: void setMultiAudioFocusEnabled(boolean)>
	<android.media.IAudioService$Stub$Proxy: int setPreferredDeviceForStrategy(int,android.media.AudioDeviceAttributes)>
	<android.media.IAudioService$Stub$Proxy: void setRingerModeExternal(int,java.lang.String)>
	<android.media.IAudioService$Stub$Proxy: void setRingerModeInternal(int,java.lang.String)>
	<android.media.IAudioService$Stub$Proxy: void setRingtonePlayer(android.media.IRingtonePlayer)>
	<android.media.IAudioService$Stub$Proxy: void setRttEnabled(boolean)>
	<android.media.IAudioService$Stub$Proxy: void setSpeakerphoneOn(android.os.IBinder,boolean)>
	<android.media.IAudioService$Stub$Proxy: void setStreamVolume(int,int,int,java.lang.String)>
	<android.media.IAudioService$Stub$Proxy: void setSupportedSystemUsages([I)>
	<android.media.IAudioService$Stub$Proxy: int setUidDeviceAffinity(android.media.audiopolicy.IAudioPolicyCallback,int,[I,[Ljava.lang.String;)>
	<android.media.IAudioService$Stub$Proxy: int setUserIdDeviceAffinity(android.media.audiopolicy.IAudioPolicyCallback,int,[I,[Ljava.lang.String;)>
	<android.media.IAudioService$Stub$Proxy: void setVibrateSetting(int,int)>
	<android.media.IAudioService$Stub$Proxy: void setVolumeController(android.media.IVolumeController)>
	<android.media.IAudioService$Stub$Proxy: void setVolumeIndexForAttributes(android.media.AudioAttributes,int,int,java.lang.String)>
	<android.media.IAudioService$Stub$Proxy: void setVolumePolicy(android.media.VolumePolicy)>
	<android.media.IAudioService$Stub$Proxy: void setWiredDeviceConnectionState(int,int,java.lang.String,java.lang.String,java.lang.String)>
	<android.media.IAudioService$Stub$Proxy: boolean shouldVibrate(int)>
	<android.media.IAudioService$Stub$Proxy: void startBluetoothSco(android.os.IBinder,int)>
	<android.media.IAudioService$Stub$Proxy: void startBluetoothScoVirtualCall(android.os.IBinder)>
	<android.media.IAudioService$Stub$Proxy: android.media.AudioRoutesInfo startWatchingRoutes(android.media.IAudioRoutesObserver)>
	<android.media.IAudioService$Stub$Proxy: void stopBluetoothSco(android.os.IBinder)>
	<android.media.IAudioService$Stub$Proxy: int trackPlayer(android.media.PlayerBase$PlayerIdCard)>
	<android.media.IAudioService$Stub$Proxy: int trackRecorder(android.os.IBinder)>
	<android.media.IAudioService$Stub$Proxy: void unloadSoundEffects()>
	<android.media.IAudioService$Stub$Proxy: void unregisterAudioFocusClient(java.lang.String)>
	<android.media.IAudioService$Stub$Proxy: void unregisterAudioPolicy(android.media.audiopolicy.IAudioPolicyCallback)>
	<android.media.IAudioService$Stub$Proxy: void unregisterAudioPolicyAsync(android.media.audiopolicy.IAudioPolicyCallback)>
	<android.media.IAudioService$Stub$Proxy: void unregisterAudioServerStateDispatcher(android.media.IAudioServerStateDispatcher)>
	<android.media.IAudioService$Stub$Proxy: void unregisterPlaybackCallback(android.media.IPlaybackConfigDispatcher)>
	<android.media.IAudioService$Stub$Proxy: void unregisterRecordingCallback(android.media.IRecordingConfigDispatcher)>
	<android.media.IAudioService$Stub$Proxy: void unregisterStrategyPreferredDeviceDispatcher(android.media.IStrategyPreferredDeviceDispatcher)>

Name: auth
StubClassName: android.hardware.biometrics.IAuthService
isAvaliable: true
Methods : 10 
	<android.hardware.biometrics.IAuthService$Stub$Proxy: android.os.IBinder asBinder()>
	<android.hardware.biometrics.IAuthService$Stub$Proxy: void authenticate(android.os.IBinder,long,int,android.hardware.biometrics.IBiometricServiceReceiver,java.lang.String,android.os.Bundle)>
	<android.hardware.biometrics.IAuthService$Stub$Proxy: int canAuthenticate(java.lang.String,int,int)>
	<android.hardware.biometrics.IAuthService$Stub$Proxy: void cancelAuthentication(android.os.IBinder,java.lang.String)>
	<android.hardware.biometrics.IAuthService$Stub$Proxy: [J getAuthenticatorIds()>
	<android.hardware.biometrics.IAuthService$Stub$Proxy: java.lang.String getInterfaceDescriptor()>
	<android.hardware.biometrics.IAuthService$Stub$Proxy: boolean hasEnrolledBiometrics(int,java.lang.String)>
	<android.hardware.biometrics.IAuthService$Stub$Proxy: void registerEnabledOnKeyguardCallback(android.hardware.biometrics.IBiometricEnabledOnKeyguardCallback)>
	<android.hardware.biometrics.IAuthService$Stub$Proxy: void resetLockout([B)>
	<android.hardware.biometrics.IAuthService$Stub$Proxy: void setActiveUser(int)>

Name: autofill
StubClassName: android.view.autofill.IAutoFillManager
isAvaliable: true
Methods : 25 
	<android.view.autofill.IAutoFillManager$Stub$Proxy: void addClient(android.view.autofill.IAutoFillManagerClient,android.content.ComponentName,int,com.android.internal.os.IResultReceiver)>
	<android.view.autofill.IAutoFillManager$Stub$Proxy: android.os.IBinder asBinder()>
	<android.view.autofill.IAutoFillManager$Stub$Proxy: void cancelSession(int,int)>
	<android.view.autofill.IAutoFillManager$Stub$Proxy: void disableOwnedAutofillServices(int)>
	<android.view.autofill.IAutoFillManager$Stub$Proxy: void finishSession(int,int)>
	<android.view.autofill.IAutoFillManager$Stub$Proxy: void getAutofillServiceComponentName(com.android.internal.os.IResultReceiver)>
	<android.view.autofill.IAutoFillManager$Stub$Proxy: void getAvailableFieldClassificationAlgorithms(com.android.internal.os.IResultReceiver)>
	<android.view.autofill.IAutoFillManager$Stub$Proxy: void getDefaultFieldClassificationAlgorithm(com.android.internal.os.IResultReceiver)>
	<android.view.autofill.IAutoFillManager$Stub$Proxy: void getFillEventHistory(com.android.internal.os.IResultReceiver)>
	<android.view.autofill.IAutoFillManager$Stub$Proxy: java.lang.String getInterfaceDescriptor()>
	<android.view.autofill.IAutoFillManager$Stub$Proxy: void getUserData(com.android.internal.os.IResultReceiver)>
	<android.view.autofill.IAutoFillManager$Stub$Proxy: void getUserDataId(com.android.internal.os.IResultReceiver)>
	<android.view.autofill.IAutoFillManager$Stub$Proxy: void isFieldClassificationEnabled(com.android.internal.os.IResultReceiver)>
	<android.view.autofill.IAutoFillManager$Stub$Proxy: void isServiceEnabled(int,java.lang.String,com.android.internal.os.IResultReceiver)>
	<android.view.autofill.IAutoFillManager$Stub$Proxy: void isServiceSupported(int,com.android.internal.os.IResultReceiver)>
	<android.view.autofill.IAutoFillManager$Stub$Proxy: void onPendingSaveUi(int,android.os.IBinder)>
	<android.view.autofill.IAutoFillManager$Stub$Proxy: void removeClient(android.view.autofill.IAutoFillManagerClient,int)>
	<android.view.autofill.IAutoFillManager$Stub$Proxy: void restoreSession(int,android.os.IBinder,android.os.IBinder,com.android.internal.os.IResultReceiver)>
	<android.view.autofill.IAutoFillManager$Stub$Proxy: void setAugmentedAutofillWhitelist(java.util.List,java.util.List,com.android.internal.os.IResultReceiver)>
	<android.view.autofill.IAutoFillManager$Stub$Proxy: void setAuthenticationResult(android.os.Bundle,int,int,int)>
	<android.view.autofill.IAutoFillManager$Stub$Proxy: void setAutofillFailure(int,java.util.List,int)>
	<android.view.autofill.IAutoFillManager$Stub$Proxy: void setHasCallback(int,int,boolean)>
	<android.view.autofill.IAutoFillManager$Stub$Proxy: void setUserData(android.service.autofill.UserData)>
	<android.view.autofill.IAutoFillManager$Stub$Proxy: void startSession(android.os.IBinder,android.os.IBinder,android.view.autofill.AutofillId,android.graphics.Rect,android.view.autofill.AutofillValue,int,boolean,int,android.content.ComponentName,boolean,com.android.internal.os.IResultReceiver)>
	<android.view.autofill.IAutoFillManager$Stub$Proxy: void updateSession(int,android.view.autofill.AutofillId,android.graphics.Rect,android.view.autofill.AutofillValue,int,int,int)>

Name: backup
StubClassName: android.app.backup.IBackupManager
isAvaliable: true
Methods : 62 
	<android.app.backup.IBackupManager$Stub$Proxy: void acknowledgeFullBackupOrRestore(int,boolean,java.lang.String,java.lang.String,android.app.backup.IFullBackupRestoreObserver)>
	<android.app.backup.IBackupManager$Stub$Proxy: void acknowledgeFullBackupOrRestoreForUser(int,int,boolean,java.lang.String,java.lang.String,android.app.backup.IFullBackupRestoreObserver)>
	<android.app.backup.IBackupManager$Stub$Proxy: void adbBackup(int,android.os.ParcelFileDescriptor,boolean,boolean,boolean,boolean,boolean,boolean,boolean,boolean,[Ljava.lang.String;)>
	<android.app.backup.IBackupManager$Stub$Proxy: void adbRestore(int,android.os.ParcelFileDescriptor)>
	<android.app.backup.IBackupManager$Stub$Proxy: void agentConnected(java.lang.String,android.os.IBinder)>
	<android.app.backup.IBackupManager$Stub$Proxy: void agentConnectedForUser(int,java.lang.String,android.os.IBinder)>
	<android.app.backup.IBackupManager$Stub$Proxy: void agentDisconnected(java.lang.String)>
	<android.app.backup.IBackupManager$Stub$Proxy: void agentDisconnectedForUser(int,java.lang.String)>
	<android.app.backup.IBackupManager$Stub$Proxy: android.os.IBinder asBinder()>
	<android.app.backup.IBackupManager$Stub$Proxy: void backupNow()>
	<android.app.backup.IBackupManager$Stub$Proxy: void backupNowForUser(int)>
	<android.app.backup.IBackupManager$Stub$Proxy: android.app.backup.IRestoreSession beginRestoreSessionForUser(int,java.lang.String,java.lang.String)>
	<android.app.backup.IBackupManager$Stub$Proxy: void cancelBackups()>
	<android.app.backup.IBackupManager$Stub$Proxy: void cancelBackupsForUser(int)>
	<android.app.backup.IBackupManager$Stub$Proxy: void clearBackupData(java.lang.String,java.lang.String)>
	<android.app.backup.IBackupManager$Stub$Proxy: void clearBackupDataForUser(int,java.lang.String,java.lang.String)>
	<android.app.backup.IBackupManager$Stub$Proxy: void dataChanged(java.lang.String)>
	<android.app.backup.IBackupManager$Stub$Proxy: void dataChangedForUser(int,java.lang.String)>
	<android.app.backup.IBackupManager$Stub$Proxy: void excludeKeysFromRestore(java.lang.String,java.util.List)>
	<android.app.backup.IBackupManager$Stub$Proxy: [Ljava.lang.String; filterAppsEligibleForBackupForUser(int,[Ljava.lang.String;)>
	<android.app.backup.IBackupManager$Stub$Proxy: void fullTransportBackupForUser(int,[Ljava.lang.String;)>
	<android.app.backup.IBackupManager$Stub$Proxy: long getAvailableRestoreTokenForUser(int,java.lang.String)>
	<android.app.backup.IBackupManager$Stub$Proxy: android.content.Intent getConfigurationIntent(java.lang.String)>
	<android.app.backup.IBackupManager$Stub$Proxy: android.content.Intent getConfigurationIntentForUser(int,java.lang.String)>
	<android.app.backup.IBackupManager$Stub$Proxy: java.lang.String getCurrentTransport()>
	<android.app.backup.IBackupManager$Stub$Proxy: android.content.ComponentName getCurrentTransportComponentForUser(int)>
	<android.app.backup.IBackupManager$Stub$Proxy: java.lang.String getCurrentTransportForUser(int)>
	<android.app.backup.IBackupManager$Stub$Proxy: android.content.Intent getDataManagementIntent(java.lang.String)>
	<android.app.backup.IBackupManager$Stub$Proxy: android.content.Intent getDataManagementIntentForUser(int,java.lang.String)>
	<android.app.backup.IBackupManager$Stub$Proxy: java.lang.CharSequence getDataManagementLabelForUser(int,java.lang.String)>
	<android.app.backup.IBackupManager$Stub$Proxy: java.lang.String getDestinationString(java.lang.String)>
	<android.app.backup.IBackupManager$Stub$Proxy: java.lang.String getDestinationStringForUser(int,java.lang.String)>
	<android.app.backup.IBackupManager$Stub$Proxy: java.lang.String getInterfaceDescriptor()>
	<android.app.backup.IBackupManager$Stub$Proxy: [Ljava.lang.String; getTransportWhitelist()>
	<android.app.backup.IBackupManager$Stub$Proxy: android.os.UserHandle getUserForAncestralSerialNumber(long)>
	<android.app.backup.IBackupManager$Stub$Proxy: boolean hasBackupPassword()>
	<android.app.backup.IBackupManager$Stub$Proxy: void initializeTransportsForUser(int,[Ljava.lang.String;,android.app.backup.IBackupObserver)>
	<android.app.backup.IBackupManager$Stub$Proxy: boolean isAppEligibleForBackupForUser(int,java.lang.String)>
	<android.app.backup.IBackupManager$Stub$Proxy: boolean isBackupEnabled()>
	<android.app.backup.IBackupManager$Stub$Proxy: boolean isBackupEnabledForUser(int)>
	<android.app.backup.IBackupManager$Stub$Proxy: boolean isBackupServiceActive(int)>
	<android.app.backup.IBackupManager$Stub$Proxy: boolean isUserReadyForBackup(int)>
	<android.app.backup.IBackupManager$Stub$Proxy: [Landroid.content.ComponentName; listAllTransportComponentsForUser(int)>
	<android.app.backup.IBackupManager$Stub$Proxy: [Ljava.lang.String; listAllTransports()>
	<android.app.backup.IBackupManager$Stub$Proxy: [Ljava.lang.String; listAllTransportsForUser(int)>
	<android.app.backup.IBackupManager$Stub$Proxy: void opComplete(int,long)>
	<android.app.backup.IBackupManager$Stub$Proxy: void opCompleteForUser(int,int,long)>
	<android.app.backup.IBackupManager$Stub$Proxy: int requestBackup([Ljava.lang.String;,android.app.backup.IBackupObserver,android.app.backup.IBackupManagerMonitor,int)>
	<android.app.backup.IBackupManager$Stub$Proxy: int requestBackupForUser(int,[Ljava.lang.String;,android.app.backup.IBackupObserver,android.app.backup.IBackupManagerMonitor,int)>
	<android.app.backup.IBackupManager$Stub$Proxy: void restoreAtInstall(java.lang.String,int)>
	<android.app.backup.IBackupManager$Stub$Proxy: void restoreAtInstallForUser(int,java.lang.String,int)>
	<android.app.backup.IBackupManager$Stub$Proxy: java.lang.String selectBackupTransport(java.lang.String)>
	<android.app.backup.IBackupManager$Stub$Proxy: void selectBackupTransportAsyncForUser(int,android.content.ComponentName,android.app.backup.ISelectBackupTransportCallback)>
	<android.app.backup.IBackupManager$Stub$Proxy: java.lang.String selectBackupTransportForUser(int,java.lang.String)>
	<android.app.backup.IBackupManager$Stub$Proxy: void setAncestralSerialNumber(long)>
	<android.app.backup.IBackupManager$Stub$Proxy: void setAutoRestore(boolean)>
	<android.app.backup.IBackupManager$Stub$Proxy: void setAutoRestoreForUser(int,boolean)>
	<android.app.backup.IBackupManager$Stub$Proxy: void setBackupEnabled(boolean)>
	<android.app.backup.IBackupManager$Stub$Proxy: void setBackupEnabledForUser(int,boolean)>
	<android.app.backup.IBackupManager$Stub$Proxy: boolean setBackupPassword(java.lang.String,java.lang.String)>
	<android.app.backup.IBackupManager$Stub$Proxy: void setBackupServiceActive(int,boolean)>
	<android.app.backup.IBackupManager$Stub$Proxy: void updateTransportAttributesForUser(int,android.content.ComponentName,java.lang.String,android.content.Intent,java.lang.String,android.content.Intent,java.lang.CharSequence)>

Name: battery
StubClassName: null
isAvaliable: false
Methods : 0 

Name: batteryproperties
StubClassName: android.os.IBatteryPropertiesRegistrar
isAvaliable: true
Methods : 4 
	<android.os.IBatteryPropertiesRegistrar$Stub$Proxy: android.os.IBinder asBinder()>
	<android.os.IBatteryPropertiesRegistrar$Stub$Proxy: java.lang.String getInterfaceDescriptor()>
	<android.os.IBatteryPropertiesRegistrar$Stub$Proxy: int getProperty(int,android.os.BatteryProperty)>
	<android.os.IBatteryPropertiesRegistrar$Stub$Proxy: void scheduleUpdate()>

Name: batterystats
StubClassName: com.android.internal.app.IBatteryStats
isAvaliable: true
Methods : 91 
	<com.android.internal.app.IBatteryStats$Stub$Proxy: android.os.IBinder asBinder()>
	<com.android.internal.app.IBatteryStats$Stub$Proxy: long computeBatteryTimeRemaining()>
	<com.android.internal.app.IBatteryStats$Stub$Proxy: long computeChargeTimeRemaining()>
	<com.android.internal.app.IBatteryStats$Stub$Proxy: long getAwakeTimeBattery()>
	<com.android.internal.app.IBatteryStats$Stub$Proxy: long getAwakeTimePlugged()>
	<com.android.internal.app.IBatteryStats$Stub$Proxy: android.os.connectivity.CellularBatteryStats getCellularBatteryStats()>
	<com.android.internal.app.IBatteryStats$Stub$Proxy: android.os.connectivity.GpsBatteryStats getGpsBatteryStats()>
	<com.android.internal.app.IBatteryStats$Stub$Proxy: java.lang.String getInterfaceDescriptor()>
	<com.android.internal.app.IBatteryStats$Stub$Proxy: [B getStatistics()>
	<com.android.internal.app.IBatteryStats$Stub$Proxy: android.os.ParcelFileDescriptor getStatisticsStream()>
	<com.android.internal.app.IBatteryStats$Stub$Proxy: android.os.connectivity.WifiBatteryStats getWifiBatteryStats()>
	<com.android.internal.app.IBatteryStats$Stub$Proxy: boolean isCharging()>
	<com.android.internal.app.IBatteryStats$Stub$Proxy: void noteBleScanResults(android.os.WorkSource,int)>
	<com.android.internal.app.IBatteryStats$Stub$Proxy: void noteBleScanStarted(android.os.WorkSource,boolean)>
	<com.android.internal.app.IBatteryStats$Stub$Proxy: void noteBleScanStopped(android.os.WorkSource,boolean)>
	<com.android.internal.app.IBatteryStats$Stub$Proxy: void noteBluetoothControllerActivity(android.bluetooth.BluetoothActivityEnergyInfo)>
	<com.android.internal.app.IBatteryStats$Stub$Proxy: void noteChangeWakelockFromSource(android.os.WorkSource,int,java.lang.String,java.lang.String,int,android.os.WorkSource,int,java.lang.String,java.lang.String,int,boolean)>
	<com.android.internal.app.IBatteryStats$Stub$Proxy: void noteConnectivityChanged(int,java.lang.String)>
	<com.android.internal.app.IBatteryStats$Stub$Proxy: void noteDeviceIdleMode(int,java.lang.String,int)>
	<com.android.internal.app.IBatteryStats$Stub$Proxy: void noteEvent(int,java.lang.String,int)>
	<com.android.internal.app.IBatteryStats$Stub$Proxy: void noteFlashlightOff(int)>
	<com.android.internal.app.IBatteryStats$Stub$Proxy: void noteFlashlightOn(int)>
	<com.android.internal.app.IBatteryStats$Stub$Proxy: void noteFullWifiLockAcquired(int)>
	<com.android.internal.app.IBatteryStats$Stub$Proxy: void noteFullWifiLockAcquiredFromSource(android.os.WorkSource)>
	<com.android.internal.app.IBatteryStats$Stub$Proxy: void noteFullWifiLockReleased(int)>
	<com.android.internal.app.IBatteryStats$Stub$Proxy: void noteFullWifiLockReleasedFromSource(android.os.WorkSource)>
	<com.android.internal.app.IBatteryStats$Stub$Proxy: void noteGpsChanged(android.os.WorkSource,android.os.WorkSource)>
	<com.android.internal.app.IBatteryStats$Stub$Proxy: void noteGpsSignalQuality(int)>
	<com.android.internal.app.IBatteryStats$Stub$Proxy: void noteInteractive(boolean)>
	<com.android.internal.app.IBatteryStats$Stub$Proxy: void noteJobFinish(java.lang.String,int,int)>
	<com.android.internal.app.IBatteryStats$Stub$Proxy: void noteJobStart(java.lang.String,int)>
	<com.android.internal.app.IBatteryStats$Stub$Proxy: void noteLongPartialWakelockFinish(java.lang.String,java.lang.String,int)>
	<com.android.internal.app.IBatteryStats$Stub$Proxy: void noteLongPartialWakelockFinishFromSource(java.lang.String,java.lang.String,android.os.WorkSource)>
	<com.android.internal.app.IBatteryStats$Stub$Proxy: void noteLongPartialWakelockStart(java.lang.String,java.lang.String,int)>
	<com.android.internal.app.IBatteryStats$Stub$Proxy: void noteLongPartialWakelockStartFromSource(java.lang.String,java.lang.String,android.os.WorkSource)>
	<com.android.internal.app.IBatteryStats$Stub$Proxy: void noteMobileRadioPowerState(int,long,int)>
	<com.android.internal.app.IBatteryStats$Stub$Proxy: void noteModemControllerActivity(android.telephony.ModemActivityInfo)>
	<com.android.internal.app.IBatteryStats$Stub$Proxy: void noteNetworkInterfaceType(java.lang.String,int)>
	<com.android.internal.app.IBatteryStats$Stub$Proxy: void noteNetworkStatsEnabled()>
	<com.android.internal.app.IBatteryStats$Stub$Proxy: void notePhoneDataConnectionState(int,boolean,int)>
	<com.android.internal.app.IBatteryStats$Stub$Proxy: void notePhoneOff()>
	<com.android.internal.app.IBatteryStats$Stub$Proxy: void notePhoneOn()>
	<com.android.internal.app.IBatteryStats$Stub$Proxy: void notePhoneSignalStrength(android.telephony.SignalStrength)>
	<com.android.internal.app.IBatteryStats$Stub$Proxy: void notePhoneState(int)>
	<com.android.internal.app.IBatteryStats$Stub$Proxy: void noteResetAudio()>
	<com.android.internal.app.IBatteryStats$Stub$Proxy: void noteResetBleScan()>
	<com.android.internal.app.IBatteryStats$Stub$Proxy: void noteResetCamera()>
	<com.android.internal.app.IBatteryStats$Stub$Proxy: void noteResetFlashlight()>
	<com.android.internal.app.IBatteryStats$Stub$Proxy: void noteResetVideo()>
	<com.android.internal.app.IBatteryStats$Stub$Proxy: void noteScreenBrightness(int)>
	<com.android.internal.app.IBatteryStats$Stub$Proxy: void noteScreenState(int)>
	<com.android.internal.app.IBatteryStats$Stub$Proxy: void noteStartAudio(int)>
	<com.android.internal.app.IBatteryStats$Stub$Proxy: void noteStartCamera(int)>
	<com.android.internal.app.IBatteryStats$Stub$Proxy: void noteStartSensor(int,int)>
	<com.android.internal.app.IBatteryStats$Stub$Proxy: void noteStartVideo(int)>
	<com.android.internal.app.IBatteryStats$Stub$Proxy: void noteStartWakelock(int,int,java.lang.String,java.lang.String,int,boolean)>
	<com.android.internal.app.IBatteryStats$Stub$Proxy: void noteStartWakelockFromSource(android.os.WorkSource,int,java.lang.String,java.lang.String,int,boolean)>
	<com.android.internal.app.IBatteryStats$Stub$Proxy: void noteStopAudio(int)>
	<com.android.internal.app.IBatteryStats$Stub$Proxy: void noteStopCamera(int)>
	<com.android.internal.app.IBatteryStats$Stub$Proxy: void noteStopSensor(int,int)>
	<com.android.internal.app.IBatteryStats$Stub$Proxy: void noteStopVideo(int)>
	<com.android.internal.app.IBatteryStats$Stub$Proxy: void noteStopWakelock(int,int,java.lang.String,java.lang.String,int)>
	<com.android.internal.app.IBatteryStats$Stub$Proxy: void noteStopWakelockFromSource(android.os.WorkSource,int,java.lang.String,java.lang.String,int)>
	<com.android.internal.app.IBatteryStats$Stub$Proxy: void noteSyncFinish(java.lang.String,int)>
	<com.android.internal.app.IBatteryStats$Stub$Proxy: void noteSyncStart(java.lang.String,int)>
	<com.android.internal.app.IBatteryStats$Stub$Proxy: void noteUserActivity(int,int)>
	<com.android.internal.app.IBatteryStats$Stub$Proxy: void noteVibratorOff(int)>
	<com.android.internal.app.IBatteryStats$Stub$Proxy: void noteVibratorOn(int,long)>
	<com.android.internal.app.IBatteryStats$Stub$Proxy: void noteWakeUp(java.lang.String,int)>
	<com.android.internal.app.IBatteryStats$Stub$Proxy: void noteWifiBatchedScanStartedFromSource(android.os.WorkSource,int)>
	<com.android.internal.app.IBatteryStats$Stub$Proxy: void noteWifiBatchedScanStoppedFromSource(android.os.WorkSource)>
	<com.android.internal.app.IBatteryStats$Stub$Proxy: void noteWifiControllerActivity(android.os.connectivity.WifiActivityEnergyInfo)>
	<com.android.internal.app.IBatteryStats$Stub$Proxy: void noteWifiMulticastDisabled(int)>
	<com.android.internal.app.IBatteryStats$Stub$Proxy: void noteWifiMulticastEnabled(int)>
	<com.android.internal.app.IBatteryStats$Stub$Proxy: void noteWifiOff()>
	<com.android.internal.app.IBatteryStats$Stub$Proxy: void noteWifiOn()>
	<com.android.internal.app.IBatteryStats$Stub$Proxy: void noteWifiRadioPowerState(int,long,int)>
	<com.android.internal.app.IBatteryStats$Stub$Proxy: void noteWifiRssiChanged(int)>
	<com.android.internal.app.IBatteryStats$Stub$Proxy: void noteWifiRunning(android.os.WorkSource)>
	<com.android.internal.app.IBatteryStats$Stub$Proxy: void noteWifiRunningChanged(android.os.WorkSource,android.os.WorkSource)>
	<com.android.internal.app.IBatteryStats$Stub$Proxy: void noteWifiScanStarted(int)>
	<com.android.internal.app.IBatteryStats$Stub$Proxy: void noteWifiScanStartedFromSource(android.os.WorkSource)>
	<com.android.internal.app.IBatteryStats$Stub$Proxy: void noteWifiScanStopped(int)>
	<com.android.internal.app.IBatteryStats$Stub$Proxy: void noteWifiScanStoppedFromSource(android.os.WorkSource)>
	<com.android.internal.app.IBatteryStats$Stub$Proxy: void noteWifiState(int,java.lang.String)>
	<com.android.internal.app.IBatteryStats$Stub$Proxy: void noteWifiStopped(android.os.WorkSource)>
	<com.android.internal.app.IBatteryStats$Stub$Proxy: void noteWifiSupplicantStateChanged(int,boolean)>
	<com.android.internal.app.IBatteryStats$Stub$Proxy: void setBatteryState(int,int,int,int,int,int,int,int,long)>
	<com.android.internal.app.IBatteryStats$Stub$Proxy: boolean setChargingStateUpdateDelayMillis(int)>
	<com.android.internal.app.IBatteryStats$Stub$Proxy: android.os.health.HealthStatsParceler takeUidSnapshot(int)>
	<com.android.internal.app.IBatteryStats$Stub$Proxy: [Landroid.os.health.HealthStatsParceler; takeUidSnapshots([I)>

Name: binder_calls_stats
StubClassName: null
isAvaliable: false
Methods : 0 

Name: biometric
StubClassName: android.hardware.biometrics.IBiometricService
isAvaliable: true
Methods : 12 
	<android.hardware.biometrics.IBiometricService$Stub$Proxy: android.os.IBinder asBinder()>
	<android.hardware.biometrics.IBiometricService$Stub$Proxy: void authenticate(android.os.IBinder,long,int,android.hardware.biometrics.IBiometricServiceReceiver,java.lang.String,android.os.Bundle,int,int,int)>
	<android.hardware.biometrics.IBiometricService$Stub$Proxy: int canAuthenticate(java.lang.String,int,int,int)>
	<android.hardware.biometrics.IBiometricService$Stub$Proxy: void cancelAuthentication(android.os.IBinder,java.lang.String,int,int,int)>
	<android.hardware.biometrics.IBiometricService$Stub$Proxy: [J getAuthenticatorIds(int)>
	<android.hardware.biometrics.IBiometricService$Stub$Proxy: java.lang.String getInterfaceDescriptor()>
	<android.hardware.biometrics.IBiometricService$Stub$Proxy: boolean hasEnrolledBiometrics(int,java.lang.String)>
	<android.hardware.biometrics.IBiometricService$Stub$Proxy: void onReadyForAuthentication(int,boolean,int)>
	<android.hardware.biometrics.IBiometricService$Stub$Proxy: void registerAuthenticator(int,int,int,android.hardware.biometrics.IBiometricAuthenticator)>
	<android.hardware.biometrics.IBiometricService$Stub$Proxy: void registerEnabledOnKeyguardCallback(android.hardware.biometrics.IBiometricEnabledOnKeyguardCallback,int)>
	<android.hardware.biometrics.IBiometricService$Stub$Proxy: void resetLockout([B)>
	<android.hardware.biometrics.IBiometricService$Stub$Proxy: void setActiveUser(int)>

Name: blob_store
StubClassName: android.app.blob.IBlobStoreManager
isAvaliable: true
Methods : 14 
	<android.app.blob.IBlobStoreManager$Stub$Proxy: void abandonSession(long,java.lang.String)>
	<android.app.blob.IBlobStoreManager$Stub$Proxy: void acquireLease(android.app.blob.BlobHandle,int,java.lang.CharSequence,long,java.lang.String)>
	<android.app.blob.IBlobStoreManager$Stub$Proxy: android.os.IBinder asBinder()>
	<android.app.blob.IBlobStoreManager$Stub$Proxy: long createSession(android.app.blob.BlobHandle,java.lang.String)>
	<android.app.blob.IBlobStoreManager$Stub$Proxy: void deleteBlob(long)>
	<android.app.blob.IBlobStoreManager$Stub$Proxy: java.lang.String getInterfaceDescriptor()>
	<android.app.blob.IBlobStoreManager$Stub$Proxy: android.app.blob.LeaseInfo getLeaseInfo(android.app.blob.BlobHandle,java.lang.String)>
	<android.app.blob.IBlobStoreManager$Stub$Proxy: java.util.List getLeasedBlobs(java.lang.String)>
	<android.app.blob.IBlobStoreManager$Stub$Proxy: long getRemainingLeaseQuotaBytes(java.lang.String)>
	<android.app.blob.IBlobStoreManager$Stub$Proxy: android.os.ParcelFileDescriptor openBlob(android.app.blob.BlobHandle,java.lang.String)>
	<android.app.blob.IBlobStoreManager$Stub$Proxy: android.app.blob.IBlobStoreSession openSession(long,java.lang.String)>
	<android.app.blob.IBlobStoreManager$Stub$Proxy: java.util.List queryBlobsForUser(int)>
	<android.app.blob.IBlobStoreManager$Stub$Proxy: void releaseLease(android.app.blob.BlobHandle,java.lang.String)>
	<android.app.blob.IBlobStoreManager$Stub$Proxy: void waitForIdle(android.os.RemoteCallback)>

Name: bluetooth_manager
StubClassName: android.bluetooth.IBluetoothManager
isAvaliable: true
Methods : 23 
	<android.bluetooth.IBluetoothManager$Stub$Proxy: android.os.IBinder asBinder()>
	<android.bluetooth.IBluetoothManager$Stub$Proxy: boolean bindBluetoothProfileService(int,android.bluetooth.IBluetoothProfileServiceConnection)>
	<android.bluetooth.IBluetoothManager$Stub$Proxy: boolean disable(java.lang.String,boolean)>
	<android.bluetooth.IBluetoothManager$Stub$Proxy: boolean disableBle(java.lang.String,android.os.IBinder)>
	<android.bluetooth.IBluetoothManager$Stub$Proxy: boolean enable(java.lang.String)>
	<android.bluetooth.IBluetoothManager$Stub$Proxy: boolean enableBle(java.lang.String,android.os.IBinder)>
	<android.bluetooth.IBluetoothManager$Stub$Proxy: boolean enableNoAutoConnect(java.lang.String)>
	<android.bluetooth.IBluetoothManager$Stub$Proxy: java.lang.String getAddress()>
	<android.bluetooth.IBluetoothManager$Stub$Proxy: android.bluetooth.IBluetoothGatt getBluetoothGatt()>
	<android.bluetooth.IBluetoothManager$Stub$Proxy: java.lang.String getInterfaceDescriptor()>
	<android.bluetooth.IBluetoothManager$Stub$Proxy: java.lang.String getName()>
	<android.bluetooth.IBluetoothManager$Stub$Proxy: int getState()>
	<android.bluetooth.IBluetoothManager$Stub$Proxy: java.util.List getSystemConfigEnabledProfilesForPackage(java.lang.String)>
	<android.bluetooth.IBluetoothManager$Stub$Proxy: boolean isBleAppPresent()>
	<android.bluetooth.IBluetoothManager$Stub$Proxy: boolean isBleScanAlwaysAvailable()>
	<android.bluetooth.IBluetoothManager$Stub$Proxy: boolean isEnabled()>
	<android.bluetooth.IBluetoothManager$Stub$Proxy: boolean isHearingAidProfileSupported()>
	<android.bluetooth.IBluetoothManager$Stub$Proxy: boolean onFactoryReset()>
	<android.bluetooth.IBluetoothManager$Stub$Proxy: android.bluetooth.IBluetooth registerAdapter(android.bluetooth.IBluetoothManagerCallback)>
	<android.bluetooth.IBluetoothManager$Stub$Proxy: void registerStateChangeCallback(android.bluetooth.IBluetoothStateChangeCallback)>
	<android.bluetooth.IBluetoothManager$Stub$Proxy: void unbindBluetoothProfileService(int,android.bluetooth.IBluetoothProfileServiceConnection)>
	<android.bluetooth.IBluetoothManager$Stub$Proxy: void unregisterAdapter(android.bluetooth.IBluetoothManagerCallback)>
	<android.bluetooth.IBluetoothManager$Stub$Proxy: void unregisterStateChangeCallback(android.bluetooth.IBluetoothStateChangeCallback)>

Name: bugreport
StubClassName: null
isAvaliable: false
Methods : 0 

Name: cacheinfo
StubClassName: null
isAvaliable: false
Methods : 0 

Name: carrier_config
StubClassName: com.android.internal.telephony.ICarrierConfigLoader
isAvaliable: true
Methods : 8 
	<com.android.internal.telephony.ICarrierConfigLoader$Stub$Proxy: android.os.IBinder asBinder()>
	<com.android.internal.telephony.ICarrierConfigLoader$Stub$Proxy: android.os.PersistableBundle getConfigForSubId(int,java.lang.String)>
	<com.android.internal.telephony.ICarrierConfigLoader$Stub$Proxy: android.os.PersistableBundle getConfigForSubIdWithFeature(int,java.lang.String,java.lang.String)>
	<com.android.internal.telephony.ICarrierConfigLoader$Stub$Proxy: java.lang.String getDefaultCarrierServicePackageName()>
	<com.android.internal.telephony.ICarrierConfigLoader$Stub$Proxy: java.lang.String getInterfaceDescriptor()>
	<com.android.internal.telephony.ICarrierConfigLoader$Stub$Proxy: void notifyConfigChangedForSubId(int)>
	<com.android.internal.telephony.ICarrierConfigLoader$Stub$Proxy: void overrideConfig(int,android.os.PersistableBundle,boolean)>
	<com.android.internal.telephony.ICarrierConfigLoader$Stub$Proxy: void updateConfigForPhoneId(int,java.lang.String)>

Name: clipboard
StubClassName: android.content.IClipboard
isAvaliable: true
Methods : 10 
	<android.content.IClipboard$Stub$Proxy: void addPrimaryClipChangedListener(android.content.IOnPrimaryClipChangedListener,java.lang.String,int)>
	<android.content.IClipboard$Stub$Proxy: android.os.IBinder asBinder()>
	<android.content.IClipboard$Stub$Proxy: void clearPrimaryClip(java.lang.String,int)>
	<android.content.IClipboard$Stub$Proxy: java.lang.String getInterfaceDescriptor()>
	<android.content.IClipboard$Stub$Proxy: android.content.ClipData getPrimaryClip(java.lang.String,int)>
	<android.content.IClipboard$Stub$Proxy: android.content.ClipDescription getPrimaryClipDescription(java.lang.String,int)>
	<android.content.IClipboard$Stub$Proxy: boolean hasClipboardText(java.lang.String,int)>
	<android.content.IClipboard$Stub$Proxy: boolean hasPrimaryClip(java.lang.String,int)>
	<android.content.IClipboard$Stub$Proxy: void removePrimaryClipChangedListener(android.content.IOnPrimaryClipChangedListener,java.lang.String,int)>
	<android.content.IClipboard$Stub$Proxy: void setPrimaryClip(android.content.ClipData,java.lang.String,int)>

Name: cneservice
StubClassName: null
isAvaliable: false
Methods : 0 

Name: color_display
StubClassName: null
isAvaliable: false
Methods : 0 

Name: companiondevice
StubClassName: android.companion.ICompanionDeviceManager
isAvaliable: true
Methods : 9 
	<android.companion.ICompanionDeviceManager$Stub$Proxy: android.os.IBinder asBinder()>
	<android.companion.ICompanionDeviceManager$Stub$Proxy: void associate(android.companion.AssociationRequest,android.companion.IFindDeviceCallback,java.lang.String)>
	<android.companion.ICompanionDeviceManager$Stub$Proxy: void disassociate(java.lang.String,java.lang.String)>
	<android.companion.ICompanionDeviceManager$Stub$Proxy: java.util.List getAssociations(java.lang.String,int)>
	<android.companion.ICompanionDeviceManager$Stub$Proxy: java.lang.String getInterfaceDescriptor()>
	<android.companion.ICompanionDeviceManager$Stub$Proxy: boolean hasNotificationAccess(android.content.ComponentName)>
	<android.companion.ICompanionDeviceManager$Stub$Proxy: boolean isDeviceAssociatedForWifiConnection(java.lang.String,java.lang.String,int)>
	<android.companion.ICompanionDeviceManager$Stub$Proxy: android.app.PendingIntent requestNotificationAccess(android.content.ComponentName)>
	<android.companion.ICompanionDeviceManager$Stub$Proxy: void stopScan(android.companion.AssociationRequest,android.companion.IFindDeviceCallback,java.lang.String)>

Name: connectivity
StubClassName: android.net.IConnectivityManager
isAvaliable: true
Methods : 91 
	<android.net.IConnectivityManager$Stub$Proxy: boolean addVpnAddress(java.lang.String,int)>
	<android.net.IConnectivityManager$Stub$Proxy: android.os.IBinder asBinder()>
	<android.net.IConnectivityManager$Stub$Proxy: int checkMobileProvisioning(int)>
	<android.net.IConnectivityManager$Stub$Proxy: void declareNetworkRequestUnfulfillable(android.net.NetworkRequest)>
	<android.net.IConnectivityManager$Stub$Proxy: void deleteVpnProfile(java.lang.String)>
	<android.net.IConnectivityManager$Stub$Proxy: android.os.ParcelFileDescriptor establishVpn(com.android.internal.net.VpnConfig)>
	<android.net.IConnectivityManager$Stub$Proxy: void factoryReset()>
	<android.net.IConnectivityManager$Stub$Proxy: android.net.LinkProperties getActiveLinkProperties()>
	<android.net.IConnectivityManager$Stub$Proxy: android.net.Network getActiveNetwork()>
	<android.net.IConnectivityManager$Stub$Proxy: android.net.Network getActiveNetworkForUid(int,boolean)>
	<android.net.IConnectivityManager$Stub$Proxy: android.net.NetworkInfo getActiveNetworkInfo()>
	<android.net.IConnectivityManager$Stub$Proxy: android.net.NetworkInfo getActiveNetworkInfoForUid(int,boolean)>
	<android.net.IConnectivityManager$Stub$Proxy: android.net.NetworkQuotaInfo getActiveNetworkQuotaInfo()>
	<android.net.IConnectivityManager$Stub$Proxy: [Landroid.net.NetworkInfo; getAllNetworkInfo()>
	<android.net.IConnectivityManager$Stub$Proxy: [Landroid.net.NetworkState; getAllNetworkState()>
	<android.net.IConnectivityManager$Stub$Proxy: [Landroid.net.Network; getAllNetworks()>
	<android.net.IConnectivityManager$Stub$Proxy: java.lang.String getAlwaysOnVpnPackage(int)>
	<android.net.IConnectivityManager$Stub$Proxy: java.lang.String getCaptivePortalServerUrl()>
	<android.net.IConnectivityManager$Stub$Proxy: int getConnectionOwnerUid(android.net.ConnectionInfo)>
	<android.net.IConnectivityManager$Stub$Proxy: [Landroid.net.NetworkCapabilities; getDefaultNetworkCapabilitiesForUser(int,java.lang.String)>
	<android.net.IConnectivityManager$Stub$Proxy: android.net.NetworkRequest getDefaultRequest()>
	<android.net.IConnectivityManager$Stub$Proxy: android.net.ProxyInfo getGlobalProxy()>
	<android.net.IConnectivityManager$Stub$Proxy: java.lang.String getInterfaceDescriptor()>
	<android.net.IConnectivityManager$Stub$Proxy: int getLastTetherError(java.lang.String)>
	<android.net.IConnectivityManager$Stub$Proxy: com.android.internal.net.LegacyVpnInfo getLegacyVpnInfo(int)>
	<android.net.IConnectivityManager$Stub$Proxy: android.net.LinkProperties getLinkProperties(android.net.Network)>
	<android.net.IConnectivityManager$Stub$Proxy: android.net.LinkProperties getLinkPropertiesForType(int)>
	<android.net.IConnectivityManager$Stub$Proxy: java.lang.String getMobileProvisioningUrl()>
	<android.net.IConnectivityManager$Stub$Proxy: int getMultipathPreference(android.net.Network)>
	<android.net.IConnectivityManager$Stub$Proxy: android.net.NetworkCapabilities getNetworkCapabilities(android.net.Network,java.lang.String)>
	<android.net.IConnectivityManager$Stub$Proxy: android.net.Network getNetworkForType(int)>
	<android.net.IConnectivityManager$Stub$Proxy: android.net.NetworkInfo getNetworkInfo(int)>
	<android.net.IConnectivityManager$Stub$Proxy: android.net.NetworkInfo getNetworkInfoForUid(android.net.Network,int,boolean)>
	<android.net.IConnectivityManager$Stub$Proxy: [B getNetworkWatchlistConfigHash()>
	<android.net.IConnectivityManager$Stub$Proxy: android.net.ProxyInfo getProxyForNetwork(android.net.Network)>
	<android.net.IConnectivityManager$Stub$Proxy: int getRestoreDefaultNetworkDelay(int)>
	<android.net.IConnectivityManager$Stub$Proxy: [Ljava.lang.String; getTetherableIfaces()>
	<android.net.IConnectivityManager$Stub$Proxy: [Ljava.lang.String; getTetherableUsbRegexs()>
	<android.net.IConnectivityManager$Stub$Proxy: [Ljava.lang.String; getTetherableWifiRegexs()>
	<android.net.IConnectivityManager$Stub$Proxy: [Ljava.lang.String; getTetheredIfaces()>
	<android.net.IConnectivityManager$Stub$Proxy: [Ljava.lang.String; getTetheringErroredIfaces()>
	<android.net.IConnectivityManager$Stub$Proxy: com.android.internal.net.VpnConfig getVpnConfig(int)>
	<android.net.IConnectivityManager$Stub$Proxy: java.util.List getVpnLockdownWhitelist(int)>
	<android.net.IConnectivityManager$Stub$Proxy: boolean isActiveNetworkMetered()>
	<android.net.IConnectivityManager$Stub$Proxy: boolean isAlwaysOnVpnPackageSupported(int,java.lang.String)>
	<android.net.IConnectivityManager$Stub$Proxy: boolean isCallerCurrentAlwaysOnVpnApp()>
	<android.net.IConnectivityManager$Stub$Proxy: boolean isCallerCurrentAlwaysOnVpnLockdownApp()>
	<android.net.IConnectivityManager$Stub$Proxy: boolean isNetworkSupported(int)>
	<android.net.IConnectivityManager$Stub$Proxy: boolean isVpnLockdownEnabled(int)>
	<android.net.IConnectivityManager$Stub$Proxy: android.net.NetworkRequest listenForNetwork(android.net.NetworkCapabilities,android.os.Messenger,android.os.IBinder,java.lang.String)>
	<android.net.IConnectivityManager$Stub$Proxy: void pendingListenForNetwork(android.net.NetworkCapabilities,android.app.PendingIntent,java.lang.String)>
	<android.net.IConnectivityManager$Stub$Proxy: android.net.NetworkRequest pendingRequestForNetwork(android.net.NetworkCapabilities,android.app.PendingIntent,java.lang.String)>
	<android.net.IConnectivityManager$Stub$Proxy: boolean prepareVpn(java.lang.String,java.lang.String,int)>
	<android.net.IConnectivityManager$Stub$Proxy: boolean provisionVpnProfile(com.android.internal.net.VpnProfile,java.lang.String)>
	<android.net.IConnectivityManager$Stub$Proxy: void registerConnectivityDiagnosticsCallback(android.net.IConnectivityDiagnosticsCallback,android.net.NetworkRequest,java.lang.String)>
	<android.net.IConnectivityManager$Stub$Proxy: android.net.Network registerNetworkAgent(android.os.Messenger,android.net.NetworkInfo,android.net.LinkProperties,android.net.NetworkCapabilities,int,android.net.NetworkAgentConfig,int)>
	<android.net.IConnectivityManager$Stub$Proxy: int registerNetworkFactory(android.os.Messenger,java.lang.String)>
	<android.net.IConnectivityManager$Stub$Proxy: int registerNetworkProvider(android.os.Messenger,java.lang.String)>
	<android.net.IConnectivityManager$Stub$Proxy: void releaseNetworkRequest(android.net.NetworkRequest)>
	<android.net.IConnectivityManager$Stub$Proxy: void releasePendingNetworkRequest(android.app.PendingIntent)>
	<android.net.IConnectivityManager$Stub$Proxy: boolean removeVpnAddress(java.lang.String,int)>
	<android.net.IConnectivityManager$Stub$Proxy: void reportInetCondition(int,int)>
	<android.net.IConnectivityManager$Stub$Proxy: void reportNetworkConnectivity(android.net.Network,boolean)>
	<android.net.IConnectivityManager$Stub$Proxy: boolean requestBandwidthUpdate(android.net.Network)>
	<android.net.IConnectivityManager$Stub$Proxy: android.net.NetworkRequest requestNetwork(android.net.NetworkCapabilities,android.os.Messenger,int,android.os.IBinder,int,java.lang.String)>
	<android.net.IConnectivityManager$Stub$Proxy: boolean requestRouteToHostAddress(int,[B)>
	<android.net.IConnectivityManager$Stub$Proxy: void setAcceptPartialConnectivity(android.net.Network,boolean,boolean)>
	<android.net.IConnectivityManager$Stub$Proxy: void setAcceptUnvalidated(android.net.Network,boolean,boolean)>
	<android.net.IConnectivityManager$Stub$Proxy: void setAirplaneMode(boolean)>
	<android.net.IConnectivityManager$Stub$Proxy: boolean setAlwaysOnVpnPackage(int,java.lang.String,boolean,java.util.List)>
	<android.net.IConnectivityManager$Stub$Proxy: void setAvoidUnvalidated(android.net.Network)>
	<android.net.IConnectivityManager$Stub$Proxy: void setGlobalProxy(android.net.ProxyInfo)>
	<android.net.IConnectivityManager$Stub$Proxy: void setProvisioningNotificationVisible(boolean,int,java.lang.String)>
	<android.net.IConnectivityManager$Stub$Proxy: boolean setUnderlyingNetworksForVpn([Landroid.net.Network;)>
	<android.net.IConnectivityManager$Stub$Proxy: void setVpnPackageAuthorization(java.lang.String,int,int)>
	<android.net.IConnectivityManager$Stub$Proxy: boolean shouldAvoidBadWifi()>
	<android.net.IConnectivityManager$Stub$Proxy: void simulateDataStall(int,long,android.net.Network,android.os.PersistableBundle)>
	<android.net.IConnectivityManager$Stub$Proxy: void startCaptivePortalApp(android.net.Network)>
	<android.net.IConnectivityManager$Stub$Proxy: void startCaptivePortalAppInternal(android.net.Network,android.os.Bundle)>
	<android.net.IConnectivityManager$Stub$Proxy: void startLegacyVpn(com.android.internal.net.VpnProfile)>
	<android.net.IConnectivityManager$Stub$Proxy: void startNattKeepalive(android.net.Network,int,android.net.ISocketKeepaliveCallback,java.lang.String,int,java.lang.String)>
	<android.net.IConnectivityManager$Stub$Proxy: void startNattKeepaliveWithFd(android.net.Network,java.io.FileDescriptor,int,int,android.net.ISocketKeepaliveCallback,java.lang.String,java.lang.String)>
	<android.net.IConnectivityManager$Stub$Proxy: android.os.IBinder startOrGetTestNetworkService()>
	<android.net.IConnectivityManager$Stub$Proxy: void startTcpKeepalive(android.net.Network,java.io.FileDescriptor,int,android.net.ISocketKeepaliveCallback)>
	<android.net.IConnectivityManager$Stub$Proxy: void startVpnProfile(java.lang.String)>
	<android.net.IConnectivityManager$Stub$Proxy: void stopKeepalive(android.net.Network,int)>
	<android.net.IConnectivityManager$Stub$Proxy: void stopVpnProfile(java.lang.String)>
	<android.net.IConnectivityManager$Stub$Proxy: void unregisterConnectivityDiagnosticsCallback(android.net.IConnectivityDiagnosticsCallback)>
	<android.net.IConnectivityManager$Stub$Proxy: void unregisterNetworkFactory(android.os.Messenger)>
	<android.net.IConnectivityManager$Stub$Proxy: void unregisterNetworkProvider(android.os.Messenger)>
	<android.net.IConnectivityManager$Stub$Proxy: boolean updateLockdownVpn()>

Name: connmetrics
StubClassName: android.net.IIpConnectivityMetrics
isAvaliable: true
Methods : 5 
	<android.net.IIpConnectivityMetrics$Stub$Proxy: boolean addNetdEventCallback(int,android.net.INetdEventCallback)>
	<android.net.IIpConnectivityMetrics$Stub$Proxy: android.os.IBinder asBinder()>
	<android.net.IIpConnectivityMetrics$Stub$Proxy: java.lang.String getInterfaceDescriptor()>
	<android.net.IIpConnectivityMetrics$Stub$Proxy: int logEvent(android.net.ConnectivityMetricsEvent)>
	<android.net.IIpConnectivityMetrics$Stub$Proxy: boolean removeNetdEventCallback(int)>

Name: consumer_ir
StubClassName: android.hardware.IConsumerIrService
isAvaliable: true
Methods : 5 
	<android.hardware.IConsumerIrService$Stub$Proxy: android.os.IBinder asBinder()>
	<android.hardware.IConsumerIrService$Stub$Proxy: [I getCarrierFrequencies()>
	<android.hardware.IConsumerIrService$Stub$Proxy: java.lang.String getInterfaceDescriptor()>
	<android.hardware.IConsumerIrService$Stub$Proxy: boolean hasIrEmitter()>
	<android.hardware.IConsumerIrService$Stub$Proxy: void transmit(java.lang.String,int,[I)>

Name: content
StubClassName: android.content.IContentService
isAvaliable: true
Methods : 42 
	<android.content.IContentService$Stub$Proxy: void addPeriodicSync(android.accounts.Account,java.lang.String,android.os.Bundle,long)>
	<android.content.IContentService$Stub$Proxy: void addStatusChangeListener(int,android.content.ISyncStatusObserver)>
	<android.content.IContentService$Stub$Proxy: android.os.IBinder asBinder()>
	<android.content.IContentService$Stub$Proxy: void cancelRequest(android.content.SyncRequest)>
	<android.content.IContentService$Stub$Proxy: void cancelSync(android.accounts.Account,java.lang.String,android.content.ComponentName)>
	<android.content.IContentService$Stub$Proxy: void cancelSyncAsUser(android.accounts.Account,java.lang.String,android.content.ComponentName,int)>
	<android.content.IContentService$Stub$Proxy: android.os.Bundle getCache(java.lang.String,android.net.Uri,int)>
	<android.content.IContentService$Stub$Proxy: java.util.List getCurrentSyncs()>
	<android.content.IContentService$Stub$Proxy: java.util.List getCurrentSyncsAsUser(int)>
	<android.content.IContentService$Stub$Proxy: java.lang.String getInterfaceDescriptor()>
	<android.content.IContentService$Stub$Proxy: int getIsSyncable(android.accounts.Account,java.lang.String)>
	<android.content.IContentService$Stub$Proxy: int getIsSyncableAsUser(android.accounts.Account,java.lang.String,int)>
	<android.content.IContentService$Stub$Proxy: boolean getMasterSyncAutomatically()>
	<android.content.IContentService$Stub$Proxy: boolean getMasterSyncAutomaticallyAsUser(int)>
	<android.content.IContentService$Stub$Proxy: java.util.List getPeriodicSyncs(android.accounts.Account,java.lang.String,android.content.ComponentName)>
	<android.content.IContentService$Stub$Proxy: [Ljava.lang.String; getSyncAdapterPackagesForAuthorityAsUser(java.lang.String,int)>
	<android.content.IContentService$Stub$Proxy: [Landroid.content.SyncAdapterType; getSyncAdapterTypes()>
	<android.content.IContentService$Stub$Proxy: [Landroid.content.SyncAdapterType; getSyncAdapterTypesAsUser(int)>
	<android.content.IContentService$Stub$Proxy: boolean getSyncAutomatically(android.accounts.Account,java.lang.String)>
	<android.content.IContentService$Stub$Proxy: boolean getSyncAutomaticallyAsUser(android.accounts.Account,java.lang.String,int)>
	<android.content.IContentService$Stub$Proxy: android.content.SyncStatusInfo getSyncStatus(android.accounts.Account,java.lang.String,android.content.ComponentName)>
	<android.content.IContentService$Stub$Proxy: android.content.SyncStatusInfo getSyncStatusAsUser(android.accounts.Account,java.lang.String,android.content.ComponentName,int)>
	<android.content.IContentService$Stub$Proxy: boolean isSyncActive(android.accounts.Account,java.lang.String,android.content.ComponentName)>
	<android.content.IContentService$Stub$Proxy: boolean isSyncPending(android.accounts.Account,java.lang.String,android.content.ComponentName)>
	<android.content.IContentService$Stub$Proxy: boolean isSyncPendingAsUser(android.accounts.Account,java.lang.String,android.content.ComponentName,int)>
	<android.content.IContentService$Stub$Proxy: void notifyChange([Landroid.net.Uri;,android.database.IContentObserver,boolean,int,int,int,java.lang.String)>
	<android.content.IContentService$Stub$Proxy: void onDbCorruption(java.lang.String,java.lang.String,java.lang.String)>
	<android.content.IContentService$Stub$Proxy: void putCache(java.lang.String,android.net.Uri,android.os.Bundle,int)>
	<android.content.IContentService$Stub$Proxy: void registerContentObserver(android.net.Uri,boolean,android.database.IContentObserver,int,int)>
	<android.content.IContentService$Stub$Proxy: void removePeriodicSync(android.accounts.Account,java.lang.String,android.os.Bundle)>
	<android.content.IContentService$Stub$Proxy: void removeStatusChangeListener(android.content.ISyncStatusObserver)>
	<android.content.IContentService$Stub$Proxy: void requestSync(android.accounts.Account,java.lang.String,android.os.Bundle,java.lang.String)>
	<android.content.IContentService$Stub$Proxy: void resetTodayStats()>
	<android.content.IContentService$Stub$Proxy: void setIsSyncable(android.accounts.Account,java.lang.String,int)>
	<android.content.IContentService$Stub$Proxy: void setIsSyncableAsUser(android.accounts.Account,java.lang.String,int,int)>
	<android.content.IContentService$Stub$Proxy: void setMasterSyncAutomatically(boolean)>
	<android.content.IContentService$Stub$Proxy: void setMasterSyncAutomaticallyAsUser(boolean,int)>
	<android.content.IContentService$Stub$Proxy: void setSyncAutomatically(android.accounts.Account,java.lang.String,boolean)>
	<android.content.IContentService$Stub$Proxy: void setSyncAutomaticallyAsUser(android.accounts.Account,java.lang.String,boolean,int)>
	<android.content.IContentService$Stub$Proxy: void sync(android.content.SyncRequest,java.lang.String)>
	<android.content.IContentService$Stub$Proxy: void syncAsUser(android.content.SyncRequest,int,java.lang.String)>
	<android.content.IContentService$Stub$Proxy: void unregisterContentObserver(android.database.IContentObserver)>

Name: content_capture
StubClassName: android.view.contentcapture.IContentCaptureManager
isAvaliable: true
Methods : 10 
	<android.view.contentcapture.IContentCaptureManager$Stub$Proxy: android.os.IBinder asBinder()>
	<android.view.contentcapture.IContentCaptureManager$Stub$Proxy: void finishSession(int)>
	<android.view.contentcapture.IContentCaptureManager$Stub$Proxy: void getContentCaptureConditions(java.lang.String,com.android.internal.os.IResultReceiver)>
	<android.view.contentcapture.IContentCaptureManager$Stub$Proxy: java.lang.String getInterfaceDescriptor()>
	<android.view.contentcapture.IContentCaptureManager$Stub$Proxy: void getServiceComponentName(com.android.internal.os.IResultReceiver)>
	<android.view.contentcapture.IContentCaptureManager$Stub$Proxy: void getServiceSettingsActivity(com.android.internal.os.IResultReceiver)>
	<android.view.contentcapture.IContentCaptureManager$Stub$Proxy: void isContentCaptureFeatureEnabled(com.android.internal.os.IResultReceiver)>
	<android.view.contentcapture.IContentCaptureManager$Stub$Proxy: void removeData(android.view.contentcapture.DataRemovalRequest)>
	<android.view.contentcapture.IContentCaptureManager$Stub$Proxy: void shareData(android.view.contentcapture.DataShareRequest,android.view.contentcapture.IDataShareWriteAdapter)>
	<android.view.contentcapture.IContentCaptureManager$Stub$Proxy: void startSession(android.os.IBinder,android.content.ComponentName,int,int,com.android.internal.os.IResultReceiver)>

Name: content_suggestions
StubClassName: android.app.contentsuggestions.IContentSuggestionsManager
isAvaliable: true
Methods : 8 
	<android.app.contentsuggestions.IContentSuggestionsManager$Stub$Proxy: android.os.IBinder asBinder()>
	<android.app.contentsuggestions.IContentSuggestionsManager$Stub$Proxy: void classifyContentSelections(int,android.app.contentsuggestions.ClassificationsRequest,android.app.contentsuggestions.IClassificationsCallback)>
	<android.app.contentsuggestions.IContentSuggestionsManager$Stub$Proxy: java.lang.String getInterfaceDescriptor()>
	<android.app.contentsuggestions.IContentSuggestionsManager$Stub$Proxy: void isEnabled(int,com.android.internal.os.IResultReceiver)>
	<android.app.contentsuggestions.IContentSuggestionsManager$Stub$Proxy: void notifyInteraction(int,java.lang.String,android.os.Bundle)>
	<android.app.contentsuggestions.IContentSuggestionsManager$Stub$Proxy: void provideContextBitmap(int,android.graphics.Bitmap,android.os.Bundle)>
	<android.app.contentsuggestions.IContentSuggestionsManager$Stub$Proxy: void provideContextImage(int,int,android.os.Bundle)>
	<android.app.contentsuggestions.IContentSuggestionsManager$Stub$Proxy: void suggestContentSelections(int,android.app.contentsuggestions.SelectionsRequest,android.app.contentsuggestions.ISelectionsCallback)>

Name: contexthub
StubClassName: android.hardware.location.IContextHubService
isAvaliable: true
Methods : 18 
	<android.hardware.location.IContextHubService$Stub$Proxy: android.os.IBinder asBinder()>
	<android.hardware.location.IContextHubService$Stub$Proxy: android.hardware.location.IContextHubClient createClient(int,android.hardware.location.IContextHubClientCallback)>
	<android.hardware.location.IContextHubService$Stub$Proxy: android.hardware.location.IContextHubClient createPendingIntentClient(int,android.app.PendingIntent,long)>
	<android.hardware.location.IContextHubService$Stub$Proxy: void disableNanoApp(int,android.hardware.location.IContextHubTransactionCallback,long)>
	<android.hardware.location.IContextHubService$Stub$Proxy: void enableNanoApp(int,android.hardware.location.IContextHubTransactionCallback,long)>
	<android.hardware.location.IContextHubService$Stub$Proxy: [I findNanoAppOnHub(int,android.hardware.location.NanoAppFilter)>
	<android.hardware.location.IContextHubService$Stub$Proxy: [I getContextHubHandles()>
	<android.hardware.location.IContextHubService$Stub$Proxy: android.hardware.location.ContextHubInfo getContextHubInfo(int)>
	<android.hardware.location.IContextHubService$Stub$Proxy: java.util.List getContextHubs()>
	<android.hardware.location.IContextHubService$Stub$Proxy: java.lang.String getInterfaceDescriptor()>
	<android.hardware.location.IContextHubService$Stub$Proxy: android.hardware.location.NanoAppInstanceInfo getNanoAppInstanceInfo(int)>
	<android.hardware.location.IContextHubService$Stub$Proxy: int loadNanoApp(int,android.hardware.location.NanoApp)>
	<android.hardware.location.IContextHubService$Stub$Proxy: void loadNanoAppOnHub(int,android.hardware.location.IContextHubTransactionCallback,android.hardware.location.NanoAppBinary)>
	<android.hardware.location.IContextHubService$Stub$Proxy: void queryNanoApps(int,android.hardware.location.IContextHubTransactionCallback)>
	<android.hardware.location.IContextHubService$Stub$Proxy: int registerCallback(android.hardware.location.IContextHubCallback)>
	<android.hardware.location.IContextHubService$Stub$Proxy: int sendMessage(int,int,android.hardware.location.ContextHubMessage)>
	<android.hardware.location.IContextHubService$Stub$Proxy: int unloadNanoApp(int)>
	<android.hardware.location.IContextHubService$Stub$Proxy: void unloadNanoAppFromHub(int,android.hardware.location.IContextHubTransactionCallback,long)>

Name: country_detector
StubClassName: android.location.ICountryDetector
isAvaliable: true
Methods : 5 
	<android.location.ICountryDetector$Stub$Proxy: void addCountryListener(android.location.ICountryListener)>
	<android.location.ICountryDetector$Stub$Proxy: android.os.IBinder asBinder()>
	<android.location.ICountryDetector$Stub$Proxy: android.location.Country detectCountry()>
	<android.location.ICountryDetector$Stub$Proxy: java.lang.String getInterfaceDescriptor()>
	<android.location.ICountryDetector$Stub$Proxy: void removeCountryListener(android.location.ICountryListener)>

Name: cpuinfo
StubClassName: null
isAvaliable: false
Methods : 0 

Name: crossprofileapps
StubClassName: android.content.pm.ICrossProfileApps
isAvaliable: true
Methods : 12 
	<android.content.pm.ICrossProfileApps$Stub$Proxy: android.os.IBinder asBinder()>
	<android.content.pm.ICrossProfileApps$Stub$Proxy: boolean canConfigureInteractAcrossProfiles(java.lang.String)>
	<android.content.pm.ICrossProfileApps$Stub$Proxy: boolean canInteractAcrossProfiles(java.lang.String)>
	<android.content.pm.ICrossProfileApps$Stub$Proxy: boolean canRequestInteractAcrossProfiles(java.lang.String)>
	<android.content.pm.ICrossProfileApps$Stub$Proxy: boolean canUserAttemptToConfigureInteractAcrossProfiles(java.lang.String)>
	<android.content.pm.ICrossProfileApps$Stub$Proxy: void clearInteractAcrossProfilesAppOps()>
	<android.content.pm.ICrossProfileApps$Stub$Proxy: java.lang.String getInterfaceDescriptor()>
	<android.content.pm.ICrossProfileApps$Stub$Proxy: java.util.List getTargetUserProfiles(java.lang.String)>
	<android.content.pm.ICrossProfileApps$Stub$Proxy: void resetInteractAcrossProfilesAppOps(java.util.List)>
	<android.content.pm.ICrossProfileApps$Stub$Proxy: void setInteractAcrossProfilesAppOp(java.lang.String,int)>
	<android.content.pm.ICrossProfileApps$Stub$Proxy: void startActivityAsUser(android.app.IApplicationThread,java.lang.String,java.lang.String,android.content.ComponentName,int,boolean)>
	<android.content.pm.ICrossProfileApps$Stub$Proxy: void startActivityAsUserByIntent(android.app.IApplicationThread,java.lang.String,java.lang.String,android.content.Intent,int,android.os.IBinder,android.os.Bundle)>

Name: dataloader_manager
StubClassName: null
isAvaliable: false
Methods : 0 

Name: dbinfo
StubClassName: null
isAvaliable: false
Methods : 0 

Name: device_config
StubClassName: null
isAvaliable: false
Methods : 0 

Name: device_identifiers
StubClassName: android.os.IDeviceIdentifiersPolicyService
isAvaliable: true
Methods : 4 
	<android.os.IDeviceIdentifiersPolicyService$Stub$Proxy: android.os.IBinder asBinder()>
	<android.os.IDeviceIdentifiersPolicyService$Stub$Proxy: java.lang.String getInterfaceDescriptor()>
	<android.os.IDeviceIdentifiersPolicyService$Stub$Proxy: java.lang.String getSerial()>
	<android.os.IDeviceIdentifiersPolicyService$Stub$Proxy: java.lang.String getSerialForPackage(java.lang.String,java.lang.String)>

Name: device_policy
StubClassName: android.app.admin.IDevicePolicyManager
isAvaliable: true
Methods : 313 
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: void addCrossProfileIntentFilter(android.content.ComponentName,android.content.IntentFilter,int)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: boolean addCrossProfileWidgetProvider(android.content.ComponentName,java.lang.String)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: int addOverrideApn(android.content.ComponentName,android.telephony.data.ApnSetting)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: void addPersistentPreferredActivity(android.content.ComponentName,android.content.IntentFilter,android.content.ComponentName)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: boolean approveCaCert(java.lang.String,int,boolean)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: android.os.IBinder asBinder()>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: boolean bindDeviceAdminServiceAsUser(android.content.ComponentName,android.app.IApplicationThread,android.os.IBinder,android.content.Intent,android.app.IServiceConnection,int,int)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: boolean canProfileOwnerResetPasswordWhenLocked(int)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: boolean checkDeviceIdentifierAccess(java.lang.String,int,int)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: int checkProvisioningPreCondition(java.lang.String,java.lang.String)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: void choosePrivateKeyAlias(int,android.net.Uri,java.lang.String,android.os.IBinder)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: void clearApplicationUserData(android.content.ComponentName,java.lang.String,android.content.pm.IPackageDataObserver)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: void clearCrossProfileIntentFilters(android.content.ComponentName)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: void clearDeviceOwner(java.lang.String)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: void clearPackagePersistentPreferredActivities(android.content.ComponentName,java.lang.String)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: void clearProfileOwner(android.content.ComponentName)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: boolean clearResetPasswordToken(android.content.ComponentName)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: void clearSystemUpdatePolicyFreezePeriodRecord()>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: android.content.Intent createAdminSupportIntent(java.lang.String)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: android.os.UserHandle createAndManageUser(android.content.ComponentName,java.lang.String,android.content.ComponentName,android.os.PersistableBundle,int)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: void enableSystemApp(android.content.ComponentName,java.lang.String,java.lang.String)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: int enableSystemAppWithIntent(android.content.ComponentName,java.lang.String,android.content.Intent)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: void enforceCanManageCaCerts(android.content.ComponentName,java.lang.String)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: long forceNetworkLogs()>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: void forceRemoveActiveAdmin(android.content.ComponentName,int)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: long forceSecurityLogs()>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: void forceUpdateUserSetupComplete()>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: boolean generateKeyPair(android.content.ComponentName,java.lang.String,java.lang.String,android.security.keystore.ParcelableKeyGenParameterSpec,int,android.security.keymaster.KeymasterCertificateChain)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: [Ljava.lang.String; getAccountTypesWithManagementDisabled()>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: [Ljava.lang.String; getAccountTypesWithManagementDisabledAsUser(int,boolean)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: java.util.List getActiveAdmins(int)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: java.util.List getAffiliationIds(android.content.ComponentName)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: java.util.List getAllCrossProfilePackages()>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: java.util.List getAlwaysOnVpnLockdownWhitelist(android.content.ComponentName)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: java.lang.String getAlwaysOnVpnPackage(android.content.ComponentName)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: java.lang.String getAlwaysOnVpnPackageForUser(int)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: android.os.Bundle getApplicationRestrictions(android.content.ComponentName,java.lang.String,java.lang.String)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: java.lang.String getApplicationRestrictionsManagingPackage(android.content.ComponentName)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: boolean getAutoTimeEnabled(android.content.ComponentName)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: boolean getAutoTimeRequired()>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: boolean getAutoTimeZoneEnabled(android.content.ComponentName)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: java.util.List getBindDeviceAdminTargetUsers(android.content.ComponentName)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: boolean getBluetoothContactSharingDisabled(android.content.ComponentName)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: boolean getBluetoothContactSharingDisabledForUser(int)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: boolean getCameraDisabled(android.content.ComponentName,int,boolean)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: java.lang.String getCertInstallerPackage(android.content.ComponentName)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: java.util.List getCrossProfileCalendarPackages(android.content.ComponentName)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: java.util.List getCrossProfileCalendarPackagesForUser(int)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: boolean getCrossProfileCallerIdDisabled(android.content.ComponentName)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: boolean getCrossProfileCallerIdDisabledForUser(int)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: boolean getCrossProfileContactsSearchDisabled(android.content.ComponentName)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: boolean getCrossProfileContactsSearchDisabledForUser(int)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: java.util.List getCrossProfilePackages(android.content.ComponentName)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: java.util.List getCrossProfileWidgetProviders(android.content.ComponentName)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: int getCurrentFailedPasswordAttempts(int,boolean)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: java.util.List getDefaultCrossProfilePackages()>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: java.util.List getDelegatePackages(android.content.ComponentName,java.lang.String)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: java.util.List getDelegatedScopes(android.content.ComponentName,java.lang.String)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: android.content.ComponentName getDeviceOwnerComponent(boolean)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: java.lang.CharSequence getDeviceOwnerLockScreenInfo()>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: java.lang.String getDeviceOwnerName()>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: java.lang.CharSequence getDeviceOwnerOrganizationName()>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: int getDeviceOwnerUserId()>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: java.util.List getDisallowedSystemApps(android.content.ComponentName,int,java.lang.String)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: boolean getDoNotAskCredentialsOnBoot()>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: java.lang.CharSequence getEndUserSessionMessage(android.content.ComponentName)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: android.app.admin.FactoryResetProtectionPolicy getFactoryResetProtectionPolicy(android.content.ComponentName)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: boolean getForceEphemeralUsers(android.content.ComponentName)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: java.lang.String getGlobalPrivateDnsHost(android.content.ComponentName)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: int getGlobalPrivateDnsMode(android.content.ComponentName)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: android.content.ComponentName getGlobalProxyAdmin(int)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: java.lang.String getInterfaceDescriptor()>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: java.util.List getKeepUninstalledPackages(android.content.ComponentName,java.lang.String)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: int getKeyguardDisabledFeatures(android.content.ComponentName,int,boolean)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: long getLastBugReportRequestTime()>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: long getLastNetworkLogRetrievalTime()>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: long getLastSecurityLogRetrievalTime()>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: int getLockTaskFeatures(android.content.ComponentName)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: [Ljava.lang.String; getLockTaskPackages(android.content.ComponentName)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: java.lang.CharSequence getLongSupportMessage(android.content.ComponentName)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: java.lang.CharSequence getLongSupportMessageForUser(android.content.ComponentName,int)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: long getManagedProfileMaximumTimeOff(android.content.ComponentName)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: int getMaximumFailedPasswordsForWipe(android.content.ComponentName,int,boolean)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: long getMaximumTimeToLock(android.content.ComponentName,int,boolean)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: java.util.List getMeteredDataDisabledPackages(android.content.ComponentName)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: int getOrganizationColor(android.content.ComponentName)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: int getOrganizationColorForUser(int)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: java.lang.CharSequence getOrganizationName(android.content.ComponentName)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: java.lang.CharSequence getOrganizationNameForUser(int)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: java.util.List getOverrideApns(android.content.ComponentName)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: android.content.pm.StringParceledListSlice getOwnerInstalledCaCerts(android.os.UserHandle)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: int getPasswordComplexity(boolean)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: long getPasswordExpiration(android.content.ComponentName,int,boolean)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: long getPasswordExpirationTimeout(android.content.ComponentName,int,boolean)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: int getPasswordHistoryLength(android.content.ComponentName,int,boolean)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: int getPasswordMinimumLength(android.content.ComponentName,int,boolean)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: int getPasswordMinimumLetters(android.content.ComponentName,int,boolean)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: int getPasswordMinimumLowerCase(android.content.ComponentName,int,boolean)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: android.app.admin.PasswordMetrics getPasswordMinimumMetrics(int)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: int getPasswordMinimumNonLetter(android.content.ComponentName,int,boolean)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: int getPasswordMinimumNumeric(android.content.ComponentName,int,boolean)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: int getPasswordMinimumSymbols(android.content.ComponentName,int,boolean)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: int getPasswordMinimumUpperCase(android.content.ComponentName,int,boolean)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: int getPasswordQuality(android.content.ComponentName,int,boolean)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: android.app.admin.SystemUpdateInfo getPendingSystemUpdate(android.content.ComponentName)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: int getPermissionGrantState(android.content.ComponentName,java.lang.String,java.lang.String,java.lang.String)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: int getPermissionPolicy(android.content.ComponentName)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: java.util.List getPermittedAccessibilityServices(android.content.ComponentName)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: java.util.List getPermittedAccessibilityServicesForUser(int)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: java.util.List getPermittedCrossProfileNotificationListeners(android.content.ComponentName)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: java.util.List getPermittedInputMethods(android.content.ComponentName)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: java.util.List getPermittedInputMethodsForCurrentUser()>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: int getPersonalAppsSuspendedReasons(android.content.ComponentName)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: android.content.ComponentName getProfileOwner(int)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: android.content.ComponentName getProfileOwnerAsUser(int)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: java.lang.String getProfileOwnerName(int)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: android.content.ComponentName getProfileOwnerOrDeviceOwnerSupervisionComponent(android.os.UserHandle)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: int getProfileWithMinimumFailedPasswordsForWipe(int,boolean)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: void getRemoveWarning(android.content.ComponentName,android.os.RemoteCallback,int)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: long getRequiredStrongAuthTimeout(android.content.ComponentName,int,boolean)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: android.content.ComponentName getRestrictionsProvider(int)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: boolean getScreenCaptureDisabled(android.content.ComponentName,int,boolean)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: java.util.List getSecondaryUsers(android.content.ComponentName)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: java.lang.CharSequence getShortSupportMessage(android.content.ComponentName)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: java.lang.CharSequence getShortSupportMessageForUser(android.content.ComponentName,int)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: java.lang.CharSequence getStartUserSessionMessage(android.content.ComponentName)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: boolean getStorageEncryption(android.content.ComponentName,int)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: int getStorageEncryptionStatus(java.lang.String,int)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: android.app.admin.SystemUpdatePolicy getSystemUpdatePolicy()>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: android.os.PersistableBundle getTransferOwnershipBundle()>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: java.util.List getTrustAgentConfiguration(android.content.ComponentName,android.content.ComponentName,int,boolean)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: java.util.List getUserControlDisabledPackages(android.content.ComponentName)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: int getUserProvisioningState()>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: android.os.Bundle getUserRestrictions(android.content.ComponentName,boolean)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: java.lang.String getWifiMacAddress(android.content.ComponentName)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: boolean hasDeviceOwner()>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: boolean hasGrantedPolicy(android.content.ComponentName,int,int)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: boolean hasLockdownAdminConfiguredNetworks(android.content.ComponentName)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: boolean hasUserSetupCompleted()>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: boolean installCaCert(android.content.ComponentName,java.lang.String,[B)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: boolean installExistingPackage(android.content.ComponentName,java.lang.String,java.lang.String)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: boolean installKeyPair(android.content.ComponentName,java.lang.String,[B,[B,[B,java.lang.String,boolean,boolean)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: void installUpdateFromFile(android.content.ComponentName,android.os.ParcelFileDescriptor,android.app.admin.StartInstallingUpdateCallback)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: boolean isAccessibilityServicePermittedByAdmin(android.content.ComponentName,java.lang.String,int)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: boolean isActivePasswordSufficient(int,boolean)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: boolean isAdminActive(android.content.ComponentName,int)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: boolean isAffiliatedUser()>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: boolean isAlwaysOnVpnLockdownEnabled(android.content.ComponentName)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: boolean isAlwaysOnVpnLockdownEnabledForUser(int)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: boolean isApplicationHidden(android.content.ComponentName,java.lang.String,java.lang.String,boolean)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: boolean isBackupServiceEnabled(android.content.ComponentName)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: boolean isCaCertApproved(java.lang.String,int)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: boolean isCallerApplicationRestrictionsManagingPackage(java.lang.String)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: boolean isCommonCriteriaModeEnabled(android.content.ComponentName)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: boolean isCurrentInputMethodSetByOwner()>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: boolean isDeviceProvisioned()>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: boolean isDeviceProvisioningConfigApplied()>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: boolean isEphemeralUser(android.content.ComponentName)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: boolean isFactoryResetProtectionPolicySupported()>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: boolean isInputMethodPermittedByAdmin(android.content.ComponentName,java.lang.String,int)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: boolean isLockTaskPermitted(java.lang.String)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: boolean isLogoutEnabled()>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: boolean isManagedKiosk()>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: boolean isManagedProfile(android.content.ComponentName)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: boolean isMasterVolumeMuted(android.content.ComponentName)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: boolean isMeteredDataDisabledPackageForUser(android.content.ComponentName,java.lang.String,int)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: boolean isNetworkLoggingEnabled(android.content.ComponentName,java.lang.String)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: boolean isNotificationListenerServicePermitted(java.lang.String,int)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: boolean isOrganizationOwnedDeviceWithManagedProfile()>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: boolean isOverrideApnEnabled(android.content.ComponentName)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: boolean isPackageAllowedToAccessCalendarForUser(java.lang.String,int)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: boolean isPackageSuspended(android.content.ComponentName,java.lang.String,java.lang.String)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: boolean isPasswordSufficientAfterProfileUnification(int,int)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: boolean isProfileActivePasswordSufficientForParent(int)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: boolean isProvisioningAllowed(java.lang.String,java.lang.String)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: boolean isRemovingAdmin(android.content.ComponentName,int)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: boolean isResetPasswordTokenActive(android.content.ComponentName)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: boolean isSecondaryLockscreenEnabled(android.os.UserHandle)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: boolean isSecurityLoggingEnabled(android.content.ComponentName)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: boolean isSeparateProfileChallengeAllowed(int)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: boolean isSystemOnlyUser(android.content.ComponentName)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: boolean isUnattendedManagedKiosk()>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: boolean isUninstallBlocked(android.content.ComponentName,java.lang.String)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: boolean isUninstallInQueue(java.lang.String)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: boolean isUsingUnifiedPassword(android.content.ComponentName)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: void lockNow(int,boolean)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: int logoutUser(android.content.ComponentName)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: void markProfileOwnerOnOrganizationOwnedDevice(android.content.ComponentName,int)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: void notifyLockTaskModeChanged(boolean,java.lang.String,int)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: void notifyPendingSystemUpdate(android.app.admin.SystemUpdateInfo)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: boolean packageHasActiveAdmins(java.lang.String,int)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: void reboot(android.content.ComponentName)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: void removeActiveAdmin(android.content.ComponentName,int)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: boolean removeCrossProfileWidgetProvider(android.content.ComponentName,java.lang.String)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: boolean removeKeyPair(android.content.ComponentName,java.lang.String,java.lang.String)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: boolean removeOverrideApn(android.content.ComponentName,int)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: boolean removeUser(android.content.ComponentName,android.os.UserHandle)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: void reportFailedBiometricAttempt(int)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: void reportFailedPasswordAttempt(int)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: void reportKeyguardDismissed(int)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: void reportKeyguardSecured(int)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: void reportPasswordChanged(int)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: void reportSuccessfulBiometricAttempt(int)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: void reportSuccessfulPasswordAttempt(int)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: boolean requestBugreport(android.content.ComponentName)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: boolean resetPassword(java.lang.String,int)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: boolean resetPasswordWithToken(android.content.ComponentName,java.lang.String,[B,int)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: java.util.List retrieveNetworkLogs(android.content.ComponentName,java.lang.String,long)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: android.content.pm.ParceledListSlice retrievePreRebootSecurityLogs(android.content.ComponentName)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: android.content.pm.ParceledListSlice retrieveSecurityLogs(android.content.ComponentName)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: void setAccountManagementDisabled(android.content.ComponentName,java.lang.String,boolean,boolean)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: void setActiveAdmin(android.content.ComponentName,boolean,int)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: void setAffiliationIds(android.content.ComponentName,java.util.List)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: boolean setAlwaysOnVpnPackage(android.content.ComponentName,java.lang.String,boolean,java.util.List)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: boolean setApplicationHidden(android.content.ComponentName,java.lang.String,java.lang.String,boolean,boolean)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: void setApplicationRestrictions(android.content.ComponentName,java.lang.String,java.lang.String,android.os.Bundle)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: boolean setApplicationRestrictionsManagingPackage(android.content.ComponentName,java.lang.String)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: void setAutoTimeEnabled(android.content.ComponentName,boolean)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: void setAutoTimeRequired(android.content.ComponentName,boolean)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: void setAutoTimeZoneEnabled(android.content.ComponentName,boolean)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: void setBackupServiceEnabled(android.content.ComponentName,boolean)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: void setBluetoothContactSharingDisabled(android.content.ComponentName,boolean)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: void setCameraDisabled(android.content.ComponentName,boolean,boolean)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: void setCertInstallerPackage(android.content.ComponentName,java.lang.String)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: void setCommonCriteriaModeEnabled(android.content.ComponentName,boolean)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: void setConfiguredNetworksLockdownState(android.content.ComponentName,boolean)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: void setCrossProfileCalendarPackages(android.content.ComponentName,java.util.List)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: void setCrossProfileCallerIdDisabled(android.content.ComponentName,boolean)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: void setCrossProfileContactsSearchDisabled(android.content.ComponentName,boolean)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: void setCrossProfilePackages(android.content.ComponentName,java.util.List)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: void setDefaultSmsApplication(android.content.ComponentName,java.lang.String,boolean)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: void setDelegatedScopes(android.content.ComponentName,java.lang.String,java.util.List)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: boolean setDeviceOwner(android.content.ComponentName,java.lang.String,int)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: void setDeviceOwnerLockScreenInfo(android.content.ComponentName,java.lang.CharSequence)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: void setDeviceProvisioningConfigApplied()>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: void setEndUserSessionMessage(android.content.ComponentName,java.lang.CharSequence)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: void setFactoryResetProtectionPolicy(android.content.ComponentName,android.app.admin.FactoryResetProtectionPolicy)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: void setForceEphemeralUsers(android.content.ComponentName,boolean)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: int setGlobalPrivateDns(android.content.ComponentName,int,java.lang.String)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: android.content.ComponentName setGlobalProxy(android.content.ComponentName,java.lang.String,java.lang.String)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: void setGlobalSetting(android.content.ComponentName,java.lang.String,java.lang.String)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: void setKeepUninstalledPackages(android.content.ComponentName,java.lang.String,java.util.List)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: boolean setKeyGrantForApp(android.content.ComponentName,java.lang.String,java.lang.String,java.lang.String,boolean)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: boolean setKeyPairCertificate(android.content.ComponentName,java.lang.String,java.lang.String,[B,[B,boolean)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: boolean setKeyguardDisabled(android.content.ComponentName,boolean)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: void setKeyguardDisabledFeatures(android.content.ComponentName,int,boolean)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: void setLocationEnabled(android.content.ComponentName,boolean)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: void setLockTaskFeatures(android.content.ComponentName,int)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: void setLockTaskPackages(android.content.ComponentName,[Ljava.lang.String;)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: void setLogoutEnabled(android.content.ComponentName,boolean)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: void setLongSupportMessage(android.content.ComponentName,java.lang.CharSequence)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: void setManagedProfileMaximumTimeOff(android.content.ComponentName,long)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: void setMasterVolumeMuted(android.content.ComponentName,boolean)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: void setMaximumFailedPasswordsForWipe(android.content.ComponentName,int,boolean)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: void setMaximumTimeToLock(android.content.ComponentName,long,boolean)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: java.util.List setMeteredDataDisabledPackages(android.content.ComponentName,java.util.List)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: void setNetworkLoggingEnabled(android.content.ComponentName,java.lang.String,boolean)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: void setOrganizationColor(android.content.ComponentName,int)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: void setOrganizationColorForUser(int,int)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: void setOrganizationName(android.content.ComponentName,java.lang.CharSequence)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: void setOverrideApnsEnabled(android.content.ComponentName,boolean)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: [Ljava.lang.String; setPackagesSuspended(android.content.ComponentName,java.lang.String,[Ljava.lang.String;,boolean)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: void setPasswordExpirationTimeout(android.content.ComponentName,long,boolean)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: void setPasswordHistoryLength(android.content.ComponentName,int,boolean)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: void setPasswordMinimumLength(android.content.ComponentName,int,boolean)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: void setPasswordMinimumLetters(android.content.ComponentName,int,boolean)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: void setPasswordMinimumLowerCase(android.content.ComponentName,int,boolean)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: void setPasswordMinimumNonLetter(android.content.ComponentName,int,boolean)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: void setPasswordMinimumNumeric(android.content.ComponentName,int,boolean)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: void setPasswordMinimumSymbols(android.content.ComponentName,int,boolean)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: void setPasswordMinimumUpperCase(android.content.ComponentName,int,boolean)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: void setPasswordQuality(android.content.ComponentName,int,boolean)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: void setPermissionGrantState(android.content.ComponentName,java.lang.String,java.lang.String,java.lang.String,int,android.os.RemoteCallback)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: void setPermissionPolicy(android.content.ComponentName,java.lang.String,int)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: boolean setPermittedAccessibilityServices(android.content.ComponentName,java.util.List)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: boolean setPermittedCrossProfileNotificationListeners(android.content.ComponentName,java.util.List)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: boolean setPermittedInputMethods(android.content.ComponentName,java.util.List)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: void setPersonalAppsSuspended(android.content.ComponentName,boolean)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: void setProfileEnabled(android.content.ComponentName)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: void setProfileName(android.content.ComponentName,java.lang.String)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: boolean setProfileOwner(android.content.ComponentName,java.lang.String,int)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: void setRecommendedGlobalProxy(android.content.ComponentName,android.net.ProxyInfo)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: void setRequiredStrongAuthTimeout(android.content.ComponentName,long,boolean)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: boolean setResetPasswordToken(android.content.ComponentName,[B)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: void setRestrictionsProvider(android.content.ComponentName,android.content.ComponentName)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: void setScreenCaptureDisabled(android.content.ComponentName,boolean,boolean)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: void setSecondaryLockscreenEnabled(android.content.ComponentName,boolean)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: void setSecureSetting(android.content.ComponentName,java.lang.String,java.lang.String)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: void setSecurityLoggingEnabled(android.content.ComponentName,boolean)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: void setShortSupportMessage(android.content.ComponentName,java.lang.CharSequence)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: void setStartUserSessionMessage(android.content.ComponentName,java.lang.CharSequence)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: boolean setStatusBarDisabled(android.content.ComponentName,boolean)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: int setStorageEncryption(android.content.ComponentName,boolean)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: void setSystemSetting(android.content.ComponentName,java.lang.String,java.lang.String)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: void setSystemUpdatePolicy(android.content.ComponentName,android.app.admin.SystemUpdatePolicy)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: boolean setTime(android.content.ComponentName,long)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: boolean setTimeZone(android.content.ComponentName,java.lang.String)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: void setTrustAgentConfiguration(android.content.ComponentName,android.content.ComponentName,android.os.PersistableBundle,boolean)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: void setUninstallBlocked(android.content.ComponentName,java.lang.String,java.lang.String,boolean)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: void setUserControlDisabledPackages(android.content.ComponentName,java.util.List)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: void setUserIcon(android.content.ComponentName,android.graphics.Bitmap)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: void setUserProvisioningState(int,int)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: void setUserRestriction(android.content.ComponentName,java.lang.String,boolean,boolean)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: void startManagedQuickContact(java.lang.String,long,boolean,long,android.content.Intent)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: int startUserInBackground(android.content.ComponentName,android.os.UserHandle)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: boolean startViewCalendarEventInManagedProfile(java.lang.String,long,long,long,boolean,int)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: int stopUser(android.content.ComponentName,android.os.UserHandle)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: boolean switchUser(android.content.ComponentName,android.os.UserHandle)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: void transferOwnership(android.content.ComponentName,android.content.ComponentName,android.os.PersistableBundle)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: void uninstallCaCerts(android.content.ComponentName,java.lang.String,[Ljava.lang.String;)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: void uninstallPackageWithActiveAdmins(java.lang.String)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: boolean updateOverrideApn(android.content.ComponentName,int,android.telephony.data.ApnSetting)>
	<android.app.admin.IDevicePolicyManager$Stub$Proxy: void wipeDataWithReason(int,java.lang.String,boolean)>

Name: deviceidle
StubClassName: android.os.IDeviceIdleController
isAvaliable: true
Methods : 26 
	<android.os.IDeviceIdleController$Stub$Proxy: void addPowerSaveTempWhitelistApp(java.lang.String,long,int,java.lang.String)>
	<android.os.IDeviceIdleController$Stub$Proxy: long addPowerSaveTempWhitelistAppForMms(java.lang.String,int,java.lang.String)>
	<android.os.IDeviceIdleController$Stub$Proxy: long addPowerSaveTempWhitelistAppForSms(java.lang.String,int,java.lang.String)>
	<android.os.IDeviceIdleController$Stub$Proxy: void addPowerSaveWhitelistApp(java.lang.String)>
	<android.os.IDeviceIdleController$Stub$Proxy: int addPowerSaveWhitelistApps(java.util.List)>
	<android.os.IDeviceIdleController$Stub$Proxy: android.os.IBinder asBinder()>
	<android.os.IDeviceIdleController$Stub$Proxy: void exitIdle(java.lang.String)>
	<android.os.IDeviceIdleController$Stub$Proxy: [I getAppIdTempWhitelist()>
	<android.os.IDeviceIdleController$Stub$Proxy: [I getAppIdUserWhitelist()>
	<android.os.IDeviceIdleController$Stub$Proxy: [I getAppIdWhitelist()>
	<android.os.IDeviceIdleController$Stub$Proxy: [I getAppIdWhitelistExceptIdle()>
	<android.os.IDeviceIdleController$Stub$Proxy: [Ljava.lang.String; getFullPowerWhitelist()>
	<android.os.IDeviceIdleController$Stub$Proxy: [Ljava.lang.String; getFullPowerWhitelistExceptIdle()>
	<android.os.IDeviceIdleController$Stub$Proxy: java.lang.String getInterfaceDescriptor()>
	<android.os.IDeviceIdleController$Stub$Proxy: [Ljava.lang.String; getRemovedSystemPowerWhitelistApps()>
	<android.os.IDeviceIdleController$Stub$Proxy: [Ljava.lang.String; getSystemPowerWhitelist()>
	<android.os.IDeviceIdleController$Stub$Proxy: [Ljava.lang.String; getSystemPowerWhitelistExceptIdle()>
	<android.os.IDeviceIdleController$Stub$Proxy: [Ljava.lang.String; getUserPowerWhitelist()>
	<android.os.IDeviceIdleController$Stub$Proxy: boolean isPowerSaveWhitelistApp(java.lang.String)>
	<android.os.IDeviceIdleController$Stub$Proxy: boolean isPowerSaveWhitelistExceptIdleApp(java.lang.String)>
	<android.os.IDeviceIdleController$Stub$Proxy: void removePowerSaveWhitelistApp(java.lang.String)>
	<android.os.IDeviceIdleController$Stub$Proxy: void removeSystemPowerWhitelistApp(java.lang.String)>
	<android.os.IDeviceIdleController$Stub$Proxy: void resetPreIdleTimeoutMode()>
	<android.os.IDeviceIdleController$Stub$Proxy: void restoreSystemPowerWhitelistApp(java.lang.String)>
	<android.os.IDeviceIdleController$Stub$Proxy: int setPreIdleTimeoutMode(int)>
	<android.os.IDeviceIdleController$Stub$Proxy: long whitelistAppTemporarily(java.lang.String,int,java.lang.String)>

Name: devicestoragemonitor
StubClassName: null
isAvaliable: false
Methods : 0 

Name: diskstats
StubClassName: null
isAvaliable: false
Methods : 0 

Name: display
StubClassName: android.hardware.display.IDisplayManager
isAvaliable: true
Methods : 32 
	<android.hardware.display.IDisplayManager$Stub$Proxy: android.os.IBinder asBinder()>
	<android.hardware.display.IDisplayManager$Stub$Proxy: void connectWifiDisplay(java.lang.String)>
	<android.hardware.display.IDisplayManager$Stub$Proxy: int createVirtualDisplay(android.hardware.display.VirtualDisplayConfig,android.hardware.display.IVirtualDisplayCallback,android.media.projection.IMediaProjection,java.lang.String)>
	<android.hardware.display.IDisplayManager$Stub$Proxy: void disconnectWifiDisplay()>
	<android.hardware.display.IDisplayManager$Stub$Proxy: void forgetWifiDisplay(java.lang.String)>
	<android.hardware.display.IDisplayManager$Stub$Proxy: android.content.pm.ParceledListSlice getAmbientBrightnessStats()>
	<android.hardware.display.IDisplayManager$Stub$Proxy: android.hardware.display.BrightnessConfiguration getBrightnessConfigurationForUser(int)>
	<android.hardware.display.IDisplayManager$Stub$Proxy: android.content.pm.ParceledListSlice getBrightnessEvents(java.lang.String)>
	<android.hardware.display.IDisplayManager$Stub$Proxy: android.hardware.display.BrightnessConfiguration getDefaultBrightnessConfiguration()>
	<android.hardware.display.IDisplayManager$Stub$Proxy: [I getDisplayIds()>
	<android.hardware.display.IDisplayManager$Stub$Proxy: android.view.DisplayInfo getDisplayInfo(int)>
	<android.hardware.display.IDisplayManager$Stub$Proxy: java.lang.String getInterfaceDescriptor()>
	<android.hardware.display.IDisplayManager$Stub$Proxy: android.hardware.display.Curve getMinimumBrightnessCurve()>
	<android.hardware.display.IDisplayManager$Stub$Proxy: int getPreferredWideGamutColorSpaceId()>
	<android.hardware.display.IDisplayManager$Stub$Proxy: android.graphics.Point getStableDisplaySize()>
	<android.hardware.display.IDisplayManager$Stub$Proxy: android.hardware.display.WifiDisplayStatus getWifiDisplayStatus()>
	<android.hardware.display.IDisplayManager$Stub$Proxy: boolean isMinimalPostProcessingRequested(int)>
	<android.hardware.display.IDisplayManager$Stub$Proxy: boolean isUidPresentOnDisplay(int,int)>
	<android.hardware.display.IDisplayManager$Stub$Proxy: void pauseWifiDisplay()>
	<android.hardware.display.IDisplayManager$Stub$Proxy: void registerCallback(android.hardware.display.IDisplayManagerCallback)>
	<android.hardware.display.IDisplayManager$Stub$Proxy: void releaseVirtualDisplay(android.hardware.display.IVirtualDisplayCallback)>
	<android.hardware.display.IDisplayManager$Stub$Proxy: void renameWifiDisplay(java.lang.String,java.lang.String)>
	<android.hardware.display.IDisplayManager$Stub$Proxy: void requestColorMode(int,int)>
	<android.hardware.display.IDisplayManager$Stub$Proxy: void resizeVirtualDisplay(android.hardware.display.IVirtualDisplayCallback,int,int,int)>
	<android.hardware.display.IDisplayManager$Stub$Proxy: void resumeWifiDisplay()>
	<android.hardware.display.IDisplayManager$Stub$Proxy: void setBrightnessConfigurationForUser(android.hardware.display.BrightnessConfiguration,int,java.lang.String)>
	<android.hardware.display.IDisplayManager$Stub$Proxy: void setTemporaryAutoBrightnessAdjustment(float)>
	<android.hardware.display.IDisplayManager$Stub$Proxy: void setTemporaryBrightness(float)>
	<android.hardware.display.IDisplayManager$Stub$Proxy: void setVirtualDisplayState(android.hardware.display.IVirtualDisplayCallback,boolean)>
	<android.hardware.display.IDisplayManager$Stub$Proxy: void setVirtualDisplaySurface(android.hardware.display.IVirtualDisplayCallback,android.view.Surface)>
	<android.hardware.display.IDisplayManager$Stub$Proxy: void startWifiDisplayScan()>
	<android.hardware.display.IDisplayManager$Stub$Proxy: void stopWifiDisplayScan()>

Name: dnsresolver
StubClassName: null
isAvaliable: false
Methods : 0 

Name: dreams
StubClassName: android.service.dreams.IDreamManager
isAvaliable: true
Methods : 15 
	<android.service.dreams.IDreamManager$Stub$Proxy: android.os.IBinder asBinder()>
	<android.service.dreams.IDreamManager$Stub$Proxy: void awaken()>
	<android.service.dreams.IDreamManager$Stub$Proxy: void dream()>
	<android.service.dreams.IDreamManager$Stub$Proxy: void finishSelf(android.os.IBinder,boolean)>
	<android.service.dreams.IDreamManager$Stub$Proxy: void forceAmbientDisplayEnabled(boolean)>
	<android.service.dreams.IDreamManager$Stub$Proxy: android.content.ComponentName getDefaultDreamComponentForUser(int)>
	<android.service.dreams.IDreamManager$Stub$Proxy: [Landroid.content.ComponentName; getDreamComponents()>
	<android.service.dreams.IDreamManager$Stub$Proxy: [Landroid.content.ComponentName; getDreamComponentsForUser(int)>
	<android.service.dreams.IDreamManager$Stub$Proxy: java.lang.String getInterfaceDescriptor()>
	<android.service.dreams.IDreamManager$Stub$Proxy: boolean isDreaming()>
	<android.service.dreams.IDreamManager$Stub$Proxy: void setDreamComponents([Landroid.content.ComponentName;)>
	<android.service.dreams.IDreamManager$Stub$Proxy: void setDreamComponentsForUser(int,[Landroid.content.ComponentName;)>
	<android.service.dreams.IDreamManager$Stub$Proxy: void startDozing(android.os.IBinder,int,int)>
	<android.service.dreams.IDreamManager$Stub$Proxy: void stopDozing(android.os.IBinder)>
	<android.service.dreams.IDreamManager$Stub$Proxy: void testDream(int,android.content.ComponentName)>

Name: drm.drmManager
StubClassName: null
isAvaliable: true
Methods : 0 

Name: dropbox
StubClassName: com.android.internal.os.IDropBoxManagerService
isAvaliable: true
Methods : 5 
	<com.android.internal.os.IDropBoxManagerService$Stub$Proxy: void add(android.os.DropBoxManager$Entry)>
	<com.android.internal.os.IDropBoxManagerService$Stub$Proxy: android.os.IBinder asBinder()>
	<com.android.internal.os.IDropBoxManagerService$Stub$Proxy: java.lang.String getInterfaceDescriptor()>
	<com.android.internal.os.IDropBoxManagerService$Stub$Proxy: android.os.DropBoxManager$Entry getNextEntry(java.lang.String,long,java.lang.String)>
	<com.android.internal.os.IDropBoxManagerService$Stub$Proxy: boolean isTagEnabled(java.lang.String)>

Name: dynamic_system
StubClassName: null
isAvaliable: false
Methods : 0 

Name: econtroller
StubClassName: com.android.internal.telephony.euicc.IEuiccController
isAvaliable: true
Methods : 18 
	<com.android.internal.telephony.euicc.IEuiccController$Stub$Proxy: android.os.IBinder asBinder()>
	<com.android.internal.telephony.euicc.IEuiccController$Stub$Proxy: void continueOperation(int,android.content.Intent,android.os.Bundle)>
	<com.android.internal.telephony.euicc.IEuiccController$Stub$Proxy: void deleteSubscription(int,int,java.lang.String,android.app.PendingIntent)>
	<com.android.internal.telephony.euicc.IEuiccController$Stub$Proxy: void downloadSubscription(int,android.telephony.euicc.DownloadableSubscription,boolean,java.lang.String,android.os.Bundle,android.app.PendingIntent)>
	<com.android.internal.telephony.euicc.IEuiccController$Stub$Proxy: void eraseSubscriptions(int,android.app.PendingIntent)>
	<com.android.internal.telephony.euicc.IEuiccController$Stub$Proxy: void eraseSubscriptionsWithOptions(int,int,android.app.PendingIntent)>
	<com.android.internal.telephony.euicc.IEuiccController$Stub$Proxy: void getDefaultDownloadableSubscriptionList(int,java.lang.String,android.app.PendingIntent)>
	<com.android.internal.telephony.euicc.IEuiccController$Stub$Proxy: void getDownloadableSubscriptionMetadata(int,android.telephony.euicc.DownloadableSubscription,java.lang.String,android.app.PendingIntent)>
	<com.android.internal.telephony.euicc.IEuiccController$Stub$Proxy: java.lang.String getEid(int,java.lang.String)>
	<com.android.internal.telephony.euicc.IEuiccController$Stub$Proxy: android.telephony.euicc.EuiccInfo getEuiccInfo(int)>
	<com.android.internal.telephony.euicc.IEuiccController$Stub$Proxy: java.lang.String getInterfaceDescriptor()>
	<com.android.internal.telephony.euicc.IEuiccController$Stub$Proxy: int getOtaStatus(int)>
	<com.android.internal.telephony.euicc.IEuiccController$Stub$Proxy: java.util.List getSupportedCountries(boolean)>
	<com.android.internal.telephony.euicc.IEuiccController$Stub$Proxy: boolean isSupportedCountry(java.lang.String)>
	<com.android.internal.telephony.euicc.IEuiccController$Stub$Proxy: void retainSubscriptionsForFactoryReset(int,android.app.PendingIntent)>
	<com.android.internal.telephony.euicc.IEuiccController$Stub$Proxy: void setSupportedCountries(boolean,java.util.List)>
	<com.android.internal.telephony.euicc.IEuiccController$Stub$Proxy: void switchToSubscription(int,int,java.lang.String,android.app.PendingIntent)>
	<com.android.internal.telephony.euicc.IEuiccController$Stub$Proxy: void updateSubscriptionNickname(int,int,java.lang.String,java.lang.String,android.app.PendingIntent)>

Name: emergency_affordance
StubClassName: null
isAvaliable: false
Methods : 0 

Name: ethernet
StubClassName: android.net.IEthernetManager
isAvaliable: true
Methods : 11 
	<android.net.IEthernetManager$Stub$Proxy: void addListener(android.net.IEthernetServiceListener)>
	<android.net.IEthernetManager$Stub$Proxy: android.os.IBinder asBinder()>
	<android.net.IEthernetManager$Stub$Proxy: [Ljava.lang.String; getAvailableInterfaces()>
	<android.net.IEthernetManager$Stub$Proxy: android.net.IpConfiguration getConfiguration(java.lang.String)>
	<android.net.IEthernetManager$Stub$Proxy: java.lang.String getInterfaceDescriptor()>
	<android.net.IEthernetManager$Stub$Proxy: boolean isAvailable(java.lang.String)>
	<android.net.IEthernetManager$Stub$Proxy: void releaseTetheredInterface(android.net.ITetheredInterfaceCallback)>
	<android.net.IEthernetManager$Stub$Proxy: void removeListener(android.net.IEthernetServiceListener)>
	<android.net.IEthernetManager$Stub$Proxy: void requestTetheredInterface(android.net.ITetheredInterfaceCallback)>
	<android.net.IEthernetManager$Stub$Proxy: void setConfiguration(java.lang.String,android.net.IpConfiguration)>
	<android.net.IEthernetManager$Stub$Proxy: void setIncludeTestInterfaces(boolean)>

Name: euicc_card_controller
StubClassName: com.android.internal.telephony.euicc.IEuiccCardController
isAvaliable: true
Methods : 24 
	<com.android.internal.telephony.euicc.IEuiccCardController$Stub$Proxy: android.os.IBinder asBinder()>
	<com.android.internal.telephony.euicc.IEuiccCardController$Stub$Proxy: void authenticateServer(java.lang.String,java.lang.String,java.lang.String,[B,[B,[B,[B,com.android.internal.telephony.euicc.IAuthenticateServerCallback)>
	<com.android.internal.telephony.euicc.IEuiccCardController$Stub$Proxy: void cancelSession(java.lang.String,java.lang.String,[B,int,com.android.internal.telephony.euicc.ICancelSessionCallback)>
	<com.android.internal.telephony.euicc.IEuiccCardController$Stub$Proxy: void deleteProfile(java.lang.String,java.lang.String,java.lang.String,com.android.internal.telephony.euicc.IDeleteProfileCallback)>
	<com.android.internal.telephony.euicc.IEuiccCardController$Stub$Proxy: void disableProfile(java.lang.String,java.lang.String,java.lang.String,boolean,com.android.internal.telephony.euicc.IDisableProfileCallback)>
	<com.android.internal.telephony.euicc.IEuiccCardController$Stub$Proxy: void getAllProfiles(java.lang.String,java.lang.String,com.android.internal.telephony.euicc.IGetAllProfilesCallback)>
	<com.android.internal.telephony.euicc.IEuiccCardController$Stub$Proxy: void getDefaultSmdpAddress(java.lang.String,java.lang.String,com.android.internal.telephony.euicc.IGetDefaultSmdpAddressCallback)>
	<com.android.internal.telephony.euicc.IEuiccCardController$Stub$Proxy: void getEuiccChallenge(java.lang.String,java.lang.String,com.android.internal.telephony.euicc.IGetEuiccChallengeCallback)>
	<com.android.internal.telephony.euicc.IEuiccCardController$Stub$Proxy: void getEuiccInfo1(java.lang.String,java.lang.String,com.android.internal.telephony.euicc.IGetEuiccInfo1Callback)>
	<com.android.internal.telephony.euicc.IEuiccCardController$Stub$Proxy: void getEuiccInfo2(java.lang.String,java.lang.String,com.android.internal.telephony.euicc.IGetEuiccInfo2Callback)>
	<com.android.internal.telephony.euicc.IEuiccCardController$Stub$Proxy: java.lang.String getInterfaceDescriptor()>
	<com.android.internal.telephony.euicc.IEuiccCardController$Stub$Proxy: void getProfile(java.lang.String,java.lang.String,java.lang.String,com.android.internal.telephony.euicc.IGetProfileCallback)>
	<com.android.internal.telephony.euicc.IEuiccCardController$Stub$Proxy: void getRulesAuthTable(java.lang.String,java.lang.String,com.android.internal.telephony.euicc.IGetRulesAuthTableCallback)>
	<com.android.internal.telephony.euicc.IEuiccCardController$Stub$Proxy: void getSmdsAddress(java.lang.String,java.lang.String,com.android.internal.telephony.euicc.IGetSmdsAddressCallback)>
	<com.android.internal.telephony.euicc.IEuiccCardController$Stub$Proxy: void listNotifications(java.lang.String,java.lang.String,int,com.android.internal.telephony.euicc.IListNotificationsCallback)>
	<com.android.internal.telephony.euicc.IEuiccCardController$Stub$Proxy: void loadBoundProfilePackage(java.lang.String,java.lang.String,[B,com.android.internal.telephony.euicc.ILoadBoundProfilePackageCallback)>
	<com.android.internal.telephony.euicc.IEuiccCardController$Stub$Proxy: void prepareDownload(java.lang.String,java.lang.String,[B,[B,[B,[B,com.android.internal.telephony.euicc.IPrepareDownloadCallback)>
	<com.android.internal.telephony.euicc.IEuiccCardController$Stub$Proxy: void removeNotificationFromList(java.lang.String,java.lang.String,int,com.android.internal.telephony.euicc.IRemoveNotificationFromListCallback)>
	<com.android.internal.telephony.euicc.IEuiccCardController$Stub$Proxy: void resetMemory(java.lang.String,java.lang.String,int,com.android.internal.telephony.euicc.IResetMemoryCallback)>
	<com.android.internal.telephony.euicc.IEuiccCardController$Stub$Proxy: void retrieveNotification(java.lang.String,java.lang.String,int,com.android.internal.telephony.euicc.IRetrieveNotificationCallback)>
	<com.android.internal.telephony.euicc.IEuiccCardController$Stub$Proxy: void retrieveNotificationList(java.lang.String,java.lang.String,int,com.android.internal.telephony.euicc.IRetrieveNotificationListCallback)>
	<com.android.internal.telephony.euicc.IEuiccCardController$Stub$Proxy: void setDefaultSmdpAddress(java.lang.String,java.lang.String,java.lang.String,com.android.internal.telephony.euicc.ISetDefaultSmdpAddressCallback)>
	<com.android.internal.telephony.euicc.IEuiccCardController$Stub$Proxy: void setNickname(java.lang.String,java.lang.String,java.lang.String,java.lang.String,com.android.internal.telephony.euicc.ISetNicknameCallback)>
	<com.android.internal.telephony.euicc.IEuiccCardController$Stub$Proxy: void switchToProfile(java.lang.String,java.lang.String,java.lang.String,boolean,com.android.internal.telephony.euicc.ISwitchToProfileCallback)>

Name: external_vibrator_service
StubClassName: null
isAvaliable: false
Methods : 0 

Name: file_integrity
StubClassName: android.security.IFileIntegrityService
isAvaliable: true
Methods : 4 
	<android.security.IFileIntegrityService$Stub$Proxy: android.os.IBinder asBinder()>
	<android.security.IFileIntegrityService$Stub$Proxy: java.lang.String getInterfaceDescriptor()>
	<android.security.IFileIntegrityService$Stub$Proxy: boolean isApkVeritySupported()>
	<android.security.IFileIntegrityService$Stub$Proxy: boolean isAppSourceCertificateTrusted([B,java.lang.String)>

Name: fingerprint
StubClassName: android.hardware.fingerprint.IFingerprintService
isAvaliable: true
Methods : 25 
	<android.hardware.fingerprint.IFingerprintService$Stub$Proxy: void addClientActiveCallback(android.hardware.fingerprint.IFingerprintClientActiveCallback)>
	<android.hardware.fingerprint.IFingerprintService$Stub$Proxy: void addLockoutResetCallback(android.hardware.biometrics.IBiometricServiceLockoutResetCallback)>
	<android.hardware.fingerprint.IFingerprintService$Stub$Proxy: android.os.IBinder asBinder()>
	<android.hardware.fingerprint.IFingerprintService$Stub$Proxy: void authenticate(android.os.IBinder,long,int,android.hardware.fingerprint.IFingerprintServiceReceiver,int,java.lang.String)>
	<android.hardware.fingerprint.IFingerprintService$Stub$Proxy: void cancelAuthentication(android.os.IBinder,java.lang.String)>
	<android.hardware.fingerprint.IFingerprintService$Stub$Proxy: void cancelAuthenticationFromService(android.os.IBinder,java.lang.String,int,int,int,boolean)>
	<android.hardware.fingerprint.IFingerprintService$Stub$Proxy: void cancelEnrollment(android.os.IBinder)>
	<android.hardware.fingerprint.IFingerprintService$Stub$Proxy: void enroll(android.os.IBinder,[B,int,android.hardware.fingerprint.IFingerprintServiceReceiver,int,java.lang.String)>
	<android.hardware.fingerprint.IFingerprintService$Stub$Proxy: void enumerate(android.os.IBinder,int,android.hardware.fingerprint.IFingerprintServiceReceiver)>
	<android.hardware.fingerprint.IFingerprintService$Stub$Proxy: long getAuthenticatorId(int)>
	<android.hardware.fingerprint.IFingerprintService$Stub$Proxy: java.util.List getEnrolledFingerprints(int,java.lang.String)>
	<android.hardware.fingerprint.IFingerprintService$Stub$Proxy: java.lang.String getInterfaceDescriptor()>
	<android.hardware.fingerprint.IFingerprintService$Stub$Proxy: boolean hasEnrolledFingerprints(int,java.lang.String)>
	<android.hardware.fingerprint.IFingerprintService$Stub$Proxy: void initConfiguredStrength(int)>
	<android.hardware.fingerprint.IFingerprintService$Stub$Proxy: boolean isClientActive()>
	<android.hardware.fingerprint.IFingerprintService$Stub$Proxy: boolean isHardwareDetected(java.lang.String)>
	<android.hardware.fingerprint.IFingerprintService$Stub$Proxy: int postEnroll(android.os.IBinder)>
	<android.hardware.fingerprint.IFingerprintService$Stub$Proxy: long preEnroll(android.os.IBinder)>
	<android.hardware.fingerprint.IFingerprintService$Stub$Proxy: void prepareForAuthentication(android.os.IBinder,long,int,android.hardware.biometrics.IBiometricServiceReceiverInternal,java.lang.String,int,int,int,int)>
	<android.hardware.fingerprint.IFingerprintService$Stub$Proxy: void remove(android.os.IBinder,int,int,int,android.hardware.fingerprint.IFingerprintServiceReceiver)>
	<android.hardware.fingerprint.IFingerprintService$Stub$Proxy: void removeClientActiveCallback(android.hardware.fingerprint.IFingerprintClientActiveCallback)>
	<android.hardware.fingerprint.IFingerprintService$Stub$Proxy: void rename(int,int,java.lang.String)>
	<android.hardware.fingerprint.IFingerprintService$Stub$Proxy: void resetTimeout([B)>
	<android.hardware.fingerprint.IFingerprintService$Stub$Proxy: void setActiveUser(int)>
	<android.hardware.fingerprint.IFingerprintService$Stub$Proxy: void startPreparedClient(int)>

Name: gfxinfo
StubClassName: null
isAvaliable: false
Methods : 0 

Name: gpu
StubClassName: null
isAvaliable: true
Methods : 0 

Name: graphicsstats
StubClassName: android.view.IGraphicsStats
isAvaliable: true
Methods : 3 
	<android.view.IGraphicsStats$Stub$Proxy: android.os.IBinder asBinder()>
	<android.view.IGraphicsStats$Stub$Proxy: java.lang.String getInterfaceDescriptor()>
	<android.view.IGraphicsStats$Stub$Proxy: android.os.ParcelFileDescriptor requestBufferForProcess(java.lang.String,android.view.IGraphicsStatsCallback)>

Name: hardware_properties
StubClassName: android.os.IHardwarePropertiesManager
isAvaliable: true
Methods : 5 
	<android.os.IHardwarePropertiesManager$Stub$Proxy: android.os.IBinder asBinder()>
	<android.os.IHardwarePropertiesManager$Stub$Proxy: [Landroid.os.CpuUsageInfo; getCpuUsages(java.lang.String)>
	<android.os.IHardwarePropertiesManager$Stub$Proxy: [F getDeviceTemperatures(java.lang.String,int,int)>
	<android.os.IHardwarePropertiesManager$Stub$Proxy: [F getFanSpeeds(java.lang.String)>
	<android.os.IHardwarePropertiesManager$Stub$Proxy: java.lang.String getInterfaceDescriptor()>

Name: imms
StubClassName: com.android.internal.telephony.IMms
isAvaliable: true
Methods : 15 
	<com.android.internal.telephony.IMms$Stub$Proxy: android.net.Uri addMultimediaMessageDraft(java.lang.String,android.net.Uri)>
	<com.android.internal.telephony.IMms$Stub$Proxy: android.net.Uri addTextMessageDraft(java.lang.String,java.lang.String,java.lang.String)>
	<com.android.internal.telephony.IMms$Stub$Proxy: boolean archiveStoredConversation(java.lang.String,long,boolean)>
	<com.android.internal.telephony.IMms$Stub$Proxy: android.os.IBinder asBinder()>
	<com.android.internal.telephony.IMms$Stub$Proxy: boolean deleteStoredConversation(java.lang.String,long)>
	<com.android.internal.telephony.IMms$Stub$Proxy: boolean deleteStoredMessage(java.lang.String,android.net.Uri)>
	<com.android.internal.telephony.IMms$Stub$Proxy: void downloadMessage(int,java.lang.String,java.lang.String,android.net.Uri,android.os.Bundle,android.app.PendingIntent,long)>
	<com.android.internal.telephony.IMms$Stub$Proxy: boolean getAutoPersisting()>
	<com.android.internal.telephony.IMms$Stub$Proxy: java.lang.String getInterfaceDescriptor()>
	<com.android.internal.telephony.IMms$Stub$Proxy: android.net.Uri importMultimediaMessage(java.lang.String,android.net.Uri,java.lang.String,long,boolean,boolean)>
	<com.android.internal.telephony.IMms$Stub$Proxy: android.net.Uri importTextMessage(java.lang.String,java.lang.String,int,java.lang.String,long,boolean,boolean)>
	<com.android.internal.telephony.IMms$Stub$Proxy: void sendMessage(int,java.lang.String,android.net.Uri,java.lang.String,android.os.Bundle,android.app.PendingIntent,long)>
	<com.android.internal.telephony.IMms$Stub$Proxy: void sendStoredMessage(int,java.lang.String,android.net.Uri,android.os.Bundle,android.app.PendingIntent)>
	<com.android.internal.telephony.IMms$Stub$Proxy: void setAutoPersisting(java.lang.String,boolean)>
	<com.android.internal.telephony.IMms$Stub$Proxy: boolean updateStoredMessageStatus(java.lang.String,android.net.Uri,android.content.ContentValues)>

Name: incident
StubClassName: null
isAvaliable: false
Methods : 0 

Name: incidentcompanion
StubClassName: null
isAvaliable: false
Methods : 0 

Name: input
StubClassName: android.hardware.input.IInputManager
isAvaliable: true
Methods : 33 
	<android.hardware.input.IInputManager$Stub$Proxy: void addKeyboardLayoutForInputDevice(android.hardware.input.InputDeviceIdentifier,java.lang.String)>
	<android.hardware.input.IInputManager$Stub$Proxy: void addPortAssociation(java.lang.String,int)>
	<android.hardware.input.IInputManager$Stub$Proxy: android.os.IBinder asBinder()>
	<android.hardware.input.IInputManager$Stub$Proxy: void cancelVibrate(int,android.os.IBinder)>
	<android.hardware.input.IInputManager$Stub$Proxy: void disableInputDevice(int)>
	<android.hardware.input.IInputManager$Stub$Proxy: void enableInputDevice(int)>
	<android.hardware.input.IInputManager$Stub$Proxy: java.lang.String getCurrentKeyboardLayoutForInputDevice(android.hardware.input.InputDeviceIdentifier)>
	<android.hardware.input.IInputManager$Stub$Proxy: [Ljava.lang.String; getEnabledKeyboardLayoutsForInputDevice(android.hardware.input.InputDeviceIdentifier)>
	<android.hardware.input.IInputManager$Stub$Proxy: android.view.InputDevice getInputDevice(int)>
	<android.hardware.input.IInputManager$Stub$Proxy: [I getInputDeviceIds()>
	<android.hardware.input.IInputManager$Stub$Proxy: java.lang.String getInterfaceDescriptor()>
	<android.hardware.input.IInputManager$Stub$Proxy: android.hardware.input.KeyboardLayout getKeyboardLayout(java.lang.String)>
	<android.hardware.input.IInputManager$Stub$Proxy: [Landroid.hardware.input.KeyboardLayout; getKeyboardLayouts()>
	<android.hardware.input.IInputManager$Stub$Proxy: [Landroid.hardware.input.KeyboardLayout; getKeyboardLayoutsForInputDevice(android.hardware.input.InputDeviceIdentifier)>
	<android.hardware.input.IInputManager$Stub$Proxy: android.hardware.input.TouchCalibration getTouchCalibrationForInputDevice(java.lang.String,int)>
	<android.hardware.input.IInputManager$Stub$Proxy: boolean hasKeys(int,int,[I,[Z)>
	<android.hardware.input.IInputManager$Stub$Proxy: boolean injectInputEvent(android.view.InputEvent,int)>
	<android.hardware.input.IInputManager$Stub$Proxy: int isInTabletMode()>
	<android.hardware.input.IInputManager$Stub$Proxy: boolean isInputDeviceEnabled(int)>
	<android.hardware.input.IInputManager$Stub$Proxy: int isMicMuted()>
	<android.hardware.input.IInputManager$Stub$Proxy: android.view.InputMonitor monitorGestureInput(java.lang.String,int)>
	<android.hardware.input.IInputManager$Stub$Proxy: void registerInputDevicesChangedListener(android.hardware.input.IInputDevicesChangedListener)>
	<android.hardware.input.IInputManager$Stub$Proxy: void registerTabletModeChangedListener(android.hardware.input.ITabletModeChangedListener)>
	<android.hardware.input.IInputManager$Stub$Proxy: void removeKeyboardLayoutForInputDevice(android.hardware.input.InputDeviceIdentifier,java.lang.String)>
	<android.hardware.input.IInputManager$Stub$Proxy: void removePortAssociation(java.lang.String)>
	<android.hardware.input.IInputManager$Stub$Proxy: void requestPointerCapture(android.os.IBinder,boolean)>
	<android.hardware.input.IInputManager$Stub$Proxy: void setCurrentKeyboardLayoutForInputDevice(android.hardware.input.InputDeviceIdentifier,java.lang.String)>
	<android.hardware.input.IInputManager$Stub$Proxy: void setCustomPointerIcon(android.view.PointerIcon)>
	<android.hardware.input.IInputManager$Stub$Proxy: void setPointerIconType(int)>
	<android.hardware.input.IInputManager$Stub$Proxy: void setTouchCalibrationForInputDevice(java.lang.String,int,android.hardware.input.TouchCalibration)>
	<android.hardware.input.IInputManager$Stub$Proxy: void tryPointerSpeed(int)>
	<android.hardware.input.IInputManager$Stub$Proxy: android.view.VerifiedInputEvent verifyInputEvent(android.view.InputEvent)>
	<android.hardware.input.IInputManager$Stub$Proxy: void vibrate(int,[J,int,android.os.IBinder)>

Name: input_method
StubClassName: com.android.internal.view.IInputMethodManager
isAvaliable: true
Methods : 21 
	<com.android.internal.view.IInputMethodManager$Stub$Proxy: void addClient(com.android.internal.view.IInputMethodClient,com.android.internal.view.IInputContext,int)>
	<com.android.internal.view.IInputMethodManager$Stub$Proxy: android.os.IBinder asBinder()>
	<com.android.internal.view.IInputMethodManager$Stub$Proxy: android.view.inputmethod.InputMethodSubtype getCurrentInputMethodSubtype()>
	<com.android.internal.view.IInputMethodManager$Stub$Proxy: java.util.List getEnabledInputMethodList(int)>
	<com.android.internal.view.IInputMethodManager$Stub$Proxy: java.util.List getEnabledInputMethodSubtypeList(java.lang.String,boolean)>
	<com.android.internal.view.IInputMethodManager$Stub$Proxy: java.util.List getInputMethodList(int)>
	<com.android.internal.view.IInputMethodManager$Stub$Proxy: int getInputMethodWindowVisibleHeight()>
	<com.android.internal.view.IInputMethodManager$Stub$Proxy: java.lang.String getInterfaceDescriptor()>
	<com.android.internal.view.IInputMethodManager$Stub$Proxy: android.view.inputmethod.InputMethodSubtype getLastInputMethodSubtype()>
	<com.android.internal.view.IInputMethodManager$Stub$Proxy: boolean hideSoftInput(com.android.internal.view.IInputMethodClient,android.os.IBinder,int,android.os.ResultReceiver)>
	<com.android.internal.view.IInputMethodManager$Stub$Proxy: boolean isInputMethodPickerShownForTest()>
	<com.android.internal.view.IInputMethodManager$Stub$Proxy: void removeImeSurface()>
	<com.android.internal.view.IInputMethodManager$Stub$Proxy: void removeImeSurfaceFromWindow(android.os.IBinder)>
	<com.android.internal.view.IInputMethodManager$Stub$Proxy: void reportActivityView(com.android.internal.view.IInputMethodClient,int,[F)>
	<com.android.internal.view.IInputMethodManager$Stub$Proxy: void reportPerceptible(android.os.IBinder,boolean)>
	<com.android.internal.view.IInputMethodManager$Stub$Proxy: void setAdditionalInputMethodSubtypes(java.lang.String,[Landroid.view.inputmethod.InputMethodSubtype;)>
	<com.android.internal.view.IInputMethodManager$Stub$Proxy: void showInputMethodAndSubtypeEnablerFromClient(com.android.internal.view.IInputMethodClient,java.lang.String)>
	<com.android.internal.view.IInputMethodManager$Stub$Proxy: void showInputMethodPickerFromClient(com.android.internal.view.IInputMethodClient,int)>
	<com.android.internal.view.IInputMethodManager$Stub$Proxy: void showInputMethodPickerFromSystem(com.android.internal.view.IInputMethodClient,int,int)>
	<com.android.internal.view.IInputMethodManager$Stub$Proxy: boolean showSoftInput(com.android.internal.view.IInputMethodClient,android.os.IBinder,int,android.os.ResultReceiver)>
	<com.android.internal.view.IInputMethodManager$Stub$Proxy: com.android.internal.view.InputBindResult startInputOrWindowGainedFocus(int,com.android.internal.view.IInputMethodClient,android.os.IBinder,int,int,int,android.view.inputmethod.EditorInfo,com.android.internal.view.IInputContext,int,int)>

Name: inputflinger
StubClassName: null
isAvaliable: false
Methods : 0 

Name: installd
StubClassName: null
isAvaliable: false
Methods : 0 

Name: ions
StubClassName: com.android.internal.telephony.IOns
isAvaliable: true
Methods : 7 
	<com.android.internal.telephony.IOns$Stub$Proxy: android.os.IBinder asBinder()>
	<com.android.internal.telephony.IOns$Stub$Proxy: java.lang.String getInterfaceDescriptor()>
	<com.android.internal.telephony.IOns$Stub$Proxy: int getPreferredDataSubscriptionId(java.lang.String,java.lang.String)>
	<com.android.internal.telephony.IOns$Stub$Proxy: boolean isEnabled(java.lang.String)>
	<com.android.internal.telephony.IOns$Stub$Proxy: boolean setEnable(boolean,java.lang.String)>
	<com.android.internal.telephony.IOns$Stub$Proxy: void setPreferredDataSubscriptionId(int,boolean,com.android.internal.telephony.ISetOpportunisticDataCallback,java.lang.String)>
	<com.android.internal.telephony.IOns$Stub$Proxy: void updateAvailableNetworks(java.util.List,com.android.internal.telephony.IUpdateAvailableNetworksCallback,java.lang.String)>

Name: iorapd
StubClassName: null
isAvaliable: false
Methods : 0 

Name: iphonesubinfo
StubClassName: com.android.internal.telephony.IPhoneSubInfo
isAvaliable: true
Methods : 35 
	<com.android.internal.telephony.IPhoneSubInfo$Stub$Proxy: android.os.IBinder asBinder()>
	<com.android.internal.telephony.IPhoneSubInfo$Stub$Proxy: android.telephony.ImsiEncryptionInfo getCarrierInfoForImsiEncryption(int,int,java.lang.String)>
	<com.android.internal.telephony.IPhoneSubInfo$Stub$Proxy: java.lang.String getDeviceId(java.lang.String)>
	<com.android.internal.telephony.IPhoneSubInfo$Stub$Proxy: java.lang.String getDeviceIdForPhone(int,java.lang.String,java.lang.String)>
	<com.android.internal.telephony.IPhoneSubInfo$Stub$Proxy: java.lang.String getDeviceIdWithFeature(java.lang.String,java.lang.String)>
	<com.android.internal.telephony.IPhoneSubInfo$Stub$Proxy: java.lang.String getDeviceSvn(java.lang.String,java.lang.String)>
	<com.android.internal.telephony.IPhoneSubInfo$Stub$Proxy: java.lang.String getDeviceSvnUsingSubId(int,java.lang.String,java.lang.String)>
	<com.android.internal.telephony.IPhoneSubInfo$Stub$Proxy: java.lang.String getGroupIdLevel1ForSubscriber(int,java.lang.String,java.lang.String)>
	<com.android.internal.telephony.IPhoneSubInfo$Stub$Proxy: java.lang.String getIccSerialNumber(java.lang.String)>
	<com.android.internal.telephony.IPhoneSubInfo$Stub$Proxy: java.lang.String getIccSerialNumberForSubscriber(int,java.lang.String,java.lang.String)>
	<com.android.internal.telephony.IPhoneSubInfo$Stub$Proxy: java.lang.String getIccSerialNumberWithFeature(java.lang.String,java.lang.String)>
	<com.android.internal.telephony.IPhoneSubInfo$Stub$Proxy: java.lang.String getIccSimChallengeResponse(int,int,int,java.lang.String)>
	<com.android.internal.telephony.IPhoneSubInfo$Stub$Proxy: java.lang.String getImeiForSubscriber(int,java.lang.String,java.lang.String)>
	<com.android.internal.telephony.IPhoneSubInfo$Stub$Proxy: java.lang.String getInterfaceDescriptor()>
	<com.android.internal.telephony.IPhoneSubInfo$Stub$Proxy: java.lang.String getIsimDomain(int)>
	<com.android.internal.telephony.IPhoneSubInfo$Stub$Proxy: java.lang.String getIsimImpi(int)>
	<com.android.internal.telephony.IPhoneSubInfo$Stub$Proxy: [Ljava.lang.String; getIsimImpu(int)>
	<com.android.internal.telephony.IPhoneSubInfo$Stub$Proxy: java.lang.String getIsimIst(int)>
	<com.android.internal.telephony.IPhoneSubInfo$Stub$Proxy: [Ljava.lang.String; getIsimPcscf(int)>
	<com.android.internal.telephony.IPhoneSubInfo$Stub$Proxy: java.lang.String getLine1AlphaTag(java.lang.String,java.lang.String)>
	<com.android.internal.telephony.IPhoneSubInfo$Stub$Proxy: java.lang.String getLine1AlphaTagForSubscriber(int,java.lang.String,java.lang.String)>
	<com.android.internal.telephony.IPhoneSubInfo$Stub$Proxy: java.lang.String getLine1Number(java.lang.String,java.lang.String)>
	<com.android.internal.telephony.IPhoneSubInfo$Stub$Proxy: java.lang.String getLine1NumberForSubscriber(int,java.lang.String,java.lang.String)>
	<com.android.internal.telephony.IPhoneSubInfo$Stub$Proxy: java.lang.String getMsisdn(java.lang.String,java.lang.String)>
	<com.android.internal.telephony.IPhoneSubInfo$Stub$Proxy: java.lang.String getMsisdnForSubscriber(int,java.lang.String,java.lang.String)>
	<com.android.internal.telephony.IPhoneSubInfo$Stub$Proxy: java.lang.String getNaiForSubscriber(int,java.lang.String,java.lang.String)>
	<com.android.internal.telephony.IPhoneSubInfo$Stub$Proxy: java.lang.String getSubscriberId(java.lang.String)>
	<com.android.internal.telephony.IPhoneSubInfo$Stub$Proxy: java.lang.String getSubscriberIdForSubscriber(int,java.lang.String,java.lang.String)>
	<com.android.internal.telephony.IPhoneSubInfo$Stub$Proxy: java.lang.String getSubscriberIdWithFeature(java.lang.String,java.lang.String)>
	<com.android.internal.telephony.IPhoneSubInfo$Stub$Proxy: java.lang.String getVoiceMailAlphaTag(java.lang.String,java.lang.String)>
	<com.android.internal.telephony.IPhoneSubInfo$Stub$Proxy: java.lang.String getVoiceMailAlphaTagForSubscriber(int,java.lang.String,java.lang.String)>
	<com.android.internal.telephony.IPhoneSubInfo$Stub$Proxy: java.lang.String getVoiceMailNumber(java.lang.String,java.lang.String)>
	<com.android.internal.telephony.IPhoneSubInfo$Stub$Proxy: java.lang.String getVoiceMailNumberForSubscriber(int,java.lang.String,java.lang.String)>
	<com.android.internal.telephony.IPhoneSubInfo$Stub$Proxy: void resetCarrierKeysForImsiEncryption(int,java.lang.String)>
	<com.android.internal.telephony.IPhoneSubInfo$Stub$Proxy: void setCarrierInfoForImsiEncryption(int,java.lang.String,android.telephony.ImsiEncryptionInfo)>

Name: ipsec
StubClassName: android.net.IIpSecService
isAvaliable: true
Methods : 15 
	<android.net.IIpSecService$Stub$Proxy: void addAddressToTunnelInterface(int,android.net.LinkAddress,java.lang.String)>
	<android.net.IIpSecService$Stub$Proxy: android.net.IpSecSpiResponse allocateSecurityParameterIndex(java.lang.String,int,android.os.IBinder)>
	<android.net.IIpSecService$Stub$Proxy: void applyTransportModeTransform(android.os.ParcelFileDescriptor,int,int)>
	<android.net.IIpSecService$Stub$Proxy: void applyTunnelModeTransform(int,int,int,java.lang.String)>
	<android.net.IIpSecService$Stub$Proxy: android.os.IBinder asBinder()>
	<android.net.IIpSecService$Stub$Proxy: void closeUdpEncapsulationSocket(int)>
	<android.net.IIpSecService$Stub$Proxy: android.net.IpSecTransformResponse createTransform(android.net.IpSecConfig,android.os.IBinder,java.lang.String)>
	<android.net.IIpSecService$Stub$Proxy: android.net.IpSecTunnelInterfaceResponse createTunnelInterface(java.lang.String,java.lang.String,android.net.Network,android.os.IBinder,java.lang.String)>
	<android.net.IIpSecService$Stub$Proxy: void deleteTransform(int)>
	<android.net.IIpSecService$Stub$Proxy: void deleteTunnelInterface(int,java.lang.String)>
	<android.net.IIpSecService$Stub$Proxy: java.lang.String getInterfaceDescriptor()>
	<android.net.IIpSecService$Stub$Proxy: android.net.IpSecUdpEncapResponse openUdpEncapsulationSocket(int,android.os.IBinder)>
	<android.net.IIpSecService$Stub$Proxy: void releaseSecurityParameterIndex(int)>
	<android.net.IIpSecService$Stub$Proxy: void removeAddressFromTunnelInterface(int,android.net.LinkAddress,java.lang.String)>
	<android.net.IIpSecService$Stub$Proxy: void removeTransportModeTransforms(android.os.ParcelFileDescriptor)>

Name: isms
StubClassName: com.android.internal.telephony.ISms
isAvaliable: true
Methods : 34 
	<com.android.internal.telephony.ISms$Stub$Proxy: android.os.IBinder asBinder()>
	<com.android.internal.telephony.ISms$Stub$Proxy: int checkSmsShortCodeDestination(int,java.lang.String,java.lang.String,java.lang.String,java.lang.String)>
	<com.android.internal.telephony.ISms$Stub$Proxy: boolean copyMessageToIccEfForSubscriber(int,java.lang.String,int,[B,[B)>
	<com.android.internal.telephony.ISms$Stub$Proxy: java.lang.String createAppSpecificSmsToken(int,java.lang.String,android.app.PendingIntent)>
	<com.android.internal.telephony.ISms$Stub$Proxy: java.lang.String createAppSpecificSmsTokenWithPackageInfo(int,java.lang.String,java.lang.String,android.app.PendingIntent)>
	<com.android.internal.telephony.ISms$Stub$Proxy: boolean disableCellBroadcastForSubscriber(int,int,int)>
	<com.android.internal.telephony.ISms$Stub$Proxy: boolean disableCellBroadcastRangeForSubscriber(int,int,int,int)>
	<com.android.internal.telephony.ISms$Stub$Proxy: boolean enableCellBroadcastForSubscriber(int,int,int)>
	<com.android.internal.telephony.ISms$Stub$Proxy: boolean enableCellBroadcastRangeForSubscriber(int,int,int,int)>
	<com.android.internal.telephony.ISms$Stub$Proxy: java.util.List getAllMessagesFromIccEfForSubscriber(int,java.lang.String)>
	<com.android.internal.telephony.ISms$Stub$Proxy: android.os.Bundle getCarrierConfigValuesForSubscriber(int)>
	<com.android.internal.telephony.ISms$Stub$Proxy: java.lang.String getImsSmsFormatForSubscriber(int)>
	<com.android.internal.telephony.ISms$Stub$Proxy: java.lang.String getInterfaceDescriptor()>
	<com.android.internal.telephony.ISms$Stub$Proxy: int getPreferredSmsSubscription()>
	<com.android.internal.telephony.ISms$Stub$Proxy: int getPremiumSmsPermission(java.lang.String)>
	<com.android.internal.telephony.ISms$Stub$Proxy: int getPremiumSmsPermissionForSubscriber(int,java.lang.String)>
	<com.android.internal.telephony.ISms$Stub$Proxy: int getSmsCapacityOnIccForSubscriber(int)>
	<com.android.internal.telephony.ISms$Stub$Proxy: java.lang.String getSmscAddressFromIccEfForSubscriber(int,java.lang.String)>
	<com.android.internal.telephony.ISms$Stub$Proxy: void injectSmsPduForSubscriber(int,[B,java.lang.String,android.app.PendingIntent)>
	<com.android.internal.telephony.ISms$Stub$Proxy: boolean isImsSmsSupportedForSubscriber(int)>
	<com.android.internal.telephony.ISms$Stub$Proxy: boolean isSMSPromptEnabled()>
	<com.android.internal.telephony.ISms$Stub$Proxy: boolean isSmsSimPickActivityNeeded(int)>
	<com.android.internal.telephony.ISms$Stub$Proxy: boolean resetAllCellBroadcastRanges(int)>
	<com.android.internal.telephony.ISms$Stub$Proxy: void sendDataForSubscriber(int,java.lang.String,java.lang.String,java.lang.String,java.lang.String,int,[B,android.app.PendingIntent,android.app.PendingIntent)>
	<com.android.internal.telephony.ISms$Stub$Proxy: void sendMultipartTextForSubscriber(int,java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.util.List,java.util.List,java.util.List,boolean,long)>
	<com.android.internal.telephony.ISms$Stub$Proxy: void sendMultipartTextForSubscriberWithOptions(int,java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.util.List,java.util.List,java.util.List,boolean,int,boolean,int)>
	<com.android.internal.telephony.ISms$Stub$Proxy: void sendStoredMultipartText(int,java.lang.String,java.lang.String,android.net.Uri,java.lang.String,java.util.List,java.util.List)>
	<com.android.internal.telephony.ISms$Stub$Proxy: void sendStoredText(int,java.lang.String,java.lang.String,android.net.Uri,java.lang.String,android.app.PendingIntent,android.app.PendingIntent)>
	<com.android.internal.telephony.ISms$Stub$Proxy: void sendTextForSubscriber(int,java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String,android.app.PendingIntent,android.app.PendingIntent,boolean,long)>
	<com.android.internal.telephony.ISms$Stub$Proxy: void sendTextForSubscriberWithOptions(int,java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String,android.app.PendingIntent,android.app.PendingIntent,boolean,int,boolean,int)>
	<com.android.internal.telephony.ISms$Stub$Proxy: void setPremiumSmsPermission(java.lang.String,int)>
	<com.android.internal.telephony.ISms$Stub$Proxy: void setPremiumSmsPermissionForSubscriber(int,java.lang.String,int)>
	<com.android.internal.telephony.ISms$Stub$Proxy: boolean setSmscAddressOnIccEfForSubscriber(java.lang.String,int,java.lang.String)>
	<com.android.internal.telephony.ISms$Stub$Proxy: boolean updateMessageOnIccEfForSubscriber(int,java.lang.String,int,int,[B)>

Name: isub
StubClassName: com.android.internal.telephony.ISub
isAvaliable: true
Methods : 50 
	<com.android.internal.telephony.ISub$Stub$Proxy: int addSubInfo(java.lang.String,java.lang.String,int,int)>
	<com.android.internal.telephony.ISub$Stub$Proxy: int addSubInfoRecord(java.lang.String,int)>
	<com.android.internal.telephony.ISub$Stub$Proxy: void addSubscriptionsIntoGroup([I,android.os.ParcelUuid,java.lang.String)>
	<com.android.internal.telephony.ISub$Stub$Proxy: android.os.IBinder asBinder()>
	<com.android.internal.telephony.ISub$Stub$Proxy: boolean canDisablePhysicalSubscription()>
	<com.android.internal.telephony.ISub$Stub$Proxy: int clearSubInfo()>
	<com.android.internal.telephony.ISub$Stub$Proxy: android.os.ParcelUuid createSubscriptionGroup([I,java.lang.String)>
	<com.android.internal.telephony.ISub$Stub$Proxy: java.util.List getAccessibleSubscriptionInfoList(java.lang.String)>
	<com.android.internal.telephony.ISub$Stub$Proxy: int getActiveDataSubscriptionId()>
	<com.android.internal.telephony.ISub$Stub$Proxy: [I getActiveSubIdList(boolean)>
	<com.android.internal.telephony.ISub$Stub$Proxy: int getActiveSubInfoCount(java.lang.String,java.lang.String)>
	<com.android.internal.telephony.ISub$Stub$Proxy: int getActiveSubInfoCountMax()>
	<com.android.internal.telephony.ISub$Stub$Proxy: android.telephony.SubscriptionInfo getActiveSubscriptionInfo(int,java.lang.String,java.lang.String)>
	<com.android.internal.telephony.ISub$Stub$Proxy: android.telephony.SubscriptionInfo getActiveSubscriptionInfoForIccId(java.lang.String,java.lang.String,java.lang.String)>
	<com.android.internal.telephony.ISub$Stub$Proxy: android.telephony.SubscriptionInfo getActiveSubscriptionInfoForSimSlotIndex(int,java.lang.String,java.lang.String)>
	<com.android.internal.telephony.ISub$Stub$Proxy: java.util.List getActiveSubscriptionInfoList(java.lang.String,java.lang.String)>
	<com.android.internal.telephony.ISub$Stub$Proxy: int getAllSubInfoCount(java.lang.String,java.lang.String)>
	<com.android.internal.telephony.ISub$Stub$Proxy: java.util.List getAllSubInfoList(java.lang.String,java.lang.String)>
	<com.android.internal.telephony.ISub$Stub$Proxy: java.util.List getAvailableSubscriptionInfoList(java.lang.String,java.lang.String)>
	<com.android.internal.telephony.ISub$Stub$Proxy: int getDefaultDataSubId()>
	<com.android.internal.telephony.ISub$Stub$Proxy: int getDefaultSmsSubId()>
	<com.android.internal.telephony.ISub$Stub$Proxy: int getDefaultSubId()>
	<com.android.internal.telephony.ISub$Stub$Proxy: int getDefaultVoiceSubId()>
	<com.android.internal.telephony.ISub$Stub$Proxy: int getEnabledSubscriptionId(int)>
	<com.android.internal.telephony.ISub$Stub$Proxy: java.lang.String getInterfaceDescriptor()>
	<com.android.internal.telephony.ISub$Stub$Proxy: java.util.List getOpportunisticSubscriptions(java.lang.String,java.lang.String)>
	<com.android.internal.telephony.ISub$Stub$Proxy: int getPhoneId(int)>
	<com.android.internal.telephony.ISub$Stub$Proxy: int getPreferredDataSubscriptionId()>
	<com.android.internal.telephony.ISub$Stub$Proxy: int getSimStateForSlotIndex(int)>
	<com.android.internal.telephony.ISub$Stub$Proxy: int getSlotIndex(int)>
	<com.android.internal.telephony.ISub$Stub$Proxy: [I getSubId(int)>
	<com.android.internal.telephony.ISub$Stub$Proxy: java.lang.String getSubscriptionProperty(int,java.lang.String,java.lang.String,java.lang.String)>
	<com.android.internal.telephony.ISub$Stub$Proxy: java.util.List getSubscriptionsInGroup(android.os.ParcelUuid,java.lang.String,java.lang.String)>
	<com.android.internal.telephony.ISub$Stub$Proxy: boolean isActiveSubId(int,java.lang.String,java.lang.String)>
	<com.android.internal.telephony.ISub$Stub$Proxy: boolean isSubscriptionEnabled(int)>
	<com.android.internal.telephony.ISub$Stub$Proxy: int removeSubInfo(java.lang.String,int)>
	<com.android.internal.telephony.ISub$Stub$Proxy: void removeSubscriptionsFromGroup([I,android.os.ParcelUuid,java.lang.String)>
	<com.android.internal.telephony.ISub$Stub$Proxy: void requestEmbeddedSubscriptionInfoListRefresh(int)>
	<com.android.internal.telephony.ISub$Stub$Proxy: int setDataRoaming(int,int)>
	<com.android.internal.telephony.ISub$Stub$Proxy: void setDefaultDataSubId(int)>
	<com.android.internal.telephony.ISub$Stub$Proxy: void setDefaultSmsSubId(int)>
	<com.android.internal.telephony.ISub$Stub$Proxy: void setDefaultVoiceSubId(int)>
	<com.android.internal.telephony.ISub$Stub$Proxy: int setDisplayNameUsingSrc(java.lang.String,int,int)>
	<com.android.internal.telephony.ISub$Stub$Proxy: int setDisplayNumber(java.lang.String,int)>
	<com.android.internal.telephony.ISub$Stub$Proxy: int setIconTint(int,int)>
	<com.android.internal.telephony.ISub$Stub$Proxy: int setOpportunistic(boolean,int,java.lang.String)>
	<com.android.internal.telephony.ISub$Stub$Proxy: void setPreferredDataSubscriptionId(int,boolean,com.android.internal.telephony.ISetOpportunisticDataCallback)>
	<com.android.internal.telephony.ISub$Stub$Proxy: boolean setSubscriptionEnabled(boolean,int)>
	<com.android.internal.telephony.ISub$Stub$Proxy: int setSubscriptionProperty(int,java.lang.String,java.lang.String)>
	<com.android.internal.telephony.ISub$Stub$Proxy: int setUiccApplicationsEnabled(boolean,int)>

Name: jobscheduler
StubClassName: android.app.job.IJobScheduler
isAvaliable: true
Methods : 11 
	<android.app.job.IJobScheduler$Stub$Proxy: android.os.IBinder asBinder()>
	<android.app.job.IJobScheduler$Stub$Proxy: void cancel(int)>
	<android.app.job.IJobScheduler$Stub$Proxy: void cancelAll()>
	<android.app.job.IJobScheduler$Stub$Proxy: int enqueue(android.app.job.JobInfo,android.app.job.JobWorkItem)>
	<android.app.job.IJobScheduler$Stub$Proxy: android.content.pm.ParceledListSlice getAllJobSnapshots()>
	<android.app.job.IJobScheduler$Stub$Proxy: android.content.pm.ParceledListSlice getAllPendingJobs()>
	<android.app.job.IJobScheduler$Stub$Proxy: java.lang.String getInterfaceDescriptor()>
	<android.app.job.IJobScheduler$Stub$Proxy: android.app.job.JobInfo getPendingJob(int)>
	<android.app.job.IJobScheduler$Stub$Proxy: java.util.List getStartedJobs()>
	<android.app.job.IJobScheduler$Stub$Proxy: int schedule(android.app.job.JobInfo)>
	<android.app.job.IJobScheduler$Stub$Proxy: int scheduleAsPackage(android.app.job.JobInfo,java.lang.String,int,java.lang.String)>

Name: launcherapps
StubClassName: android.content.pm.ILauncherApps
isAvaliable: true
Methods : 30 
	<android.content.pm.ILauncherApps$Stub$Proxy: void addOnAppsChangedListener(java.lang.String,android.content.pm.IOnAppsChangedListener)>
	<android.content.pm.ILauncherApps$Stub$Proxy: android.os.IBinder asBinder()>
	<android.content.pm.ILauncherApps$Stub$Proxy: void cacheShortcuts(java.lang.String,java.lang.String,java.util.List,android.os.UserHandle,int)>
	<android.content.pm.ILauncherApps$Stub$Proxy: android.content.pm.ParceledListSlice getAllSessions(java.lang.String)>
	<android.content.pm.ILauncherApps$Stub$Proxy: android.content.pm.LauncherApps$AppUsageLimit getAppUsageLimit(java.lang.String,java.lang.String,android.os.UserHandle)>
	<android.content.pm.ILauncherApps$Stub$Proxy: android.content.pm.ApplicationInfo getApplicationInfo(java.lang.String,java.lang.String,int,android.os.UserHandle)>
	<android.content.pm.ILauncherApps$Stub$Proxy: java.lang.String getInterfaceDescriptor()>
	<android.content.pm.ILauncherApps$Stub$Proxy: android.content.pm.ParceledListSlice getLauncherActivities(java.lang.String,java.lang.String,android.os.UserHandle)>
	<android.content.pm.ILauncherApps$Stub$Proxy: android.content.pm.ParceledListSlice getShortcutConfigActivities(java.lang.String,java.lang.String,android.os.UserHandle)>
	<android.content.pm.ILauncherApps$Stub$Proxy: android.content.IntentSender getShortcutConfigActivityIntent(java.lang.String,android.content.ComponentName,android.os.UserHandle)>
	<android.content.pm.ILauncherApps$Stub$Proxy: android.os.ParcelFileDescriptor getShortcutIconFd(java.lang.String,java.lang.String,java.lang.String,int)>
	<android.content.pm.ILauncherApps$Stub$Proxy: int getShortcutIconResId(java.lang.String,java.lang.String,java.lang.String,int)>
	<android.content.pm.ILauncherApps$Stub$Proxy: java.lang.String getShortcutIconUri(java.lang.String,java.lang.String,java.lang.String,int)>
	<android.content.pm.ILauncherApps$Stub$Proxy: android.content.pm.ParceledListSlice getShortcuts(java.lang.String,android.content.pm.ShortcutQueryWrapper,android.os.UserHandle)>
	<android.content.pm.ILauncherApps$Stub$Proxy: android.os.Bundle getSuspendedPackageLauncherExtras(java.lang.String,android.os.UserHandle)>
	<android.content.pm.ILauncherApps$Stub$Proxy: boolean hasShortcutHostPermission(java.lang.String)>
	<android.content.pm.ILauncherApps$Stub$Proxy: boolean isActivityEnabled(java.lang.String,android.content.ComponentName,android.os.UserHandle)>
	<android.content.pm.ILauncherApps$Stub$Proxy: boolean isPackageEnabled(java.lang.String,java.lang.String,android.os.UserHandle)>
	<android.content.pm.ILauncherApps$Stub$Proxy: void pinShortcuts(java.lang.String,java.lang.String,java.util.List,android.os.UserHandle)>
	<android.content.pm.ILauncherApps$Stub$Proxy: void registerPackageInstallerCallback(java.lang.String,android.content.pm.IPackageInstallerCallback)>
	<android.content.pm.ILauncherApps$Stub$Proxy: void registerShortcutChangeCallback(java.lang.String,android.content.pm.ShortcutQueryWrapper,android.content.pm.IShortcutChangeCallback)>
	<android.content.pm.ILauncherApps$Stub$Proxy: void removeOnAppsChangedListener(android.content.pm.IOnAppsChangedListener)>
	<android.content.pm.ILauncherApps$Stub$Proxy: android.content.pm.ActivityInfo resolveActivity(java.lang.String,android.content.ComponentName,android.os.UserHandle)>
	<android.content.pm.ILauncherApps$Stub$Proxy: boolean shouldHideFromSuggestions(java.lang.String,android.os.UserHandle)>
	<android.content.pm.ILauncherApps$Stub$Proxy: void showAppDetailsAsUser(android.app.IApplicationThread,java.lang.String,java.lang.String,android.content.ComponentName,android.graphics.Rect,android.os.Bundle,android.os.UserHandle)>
	<android.content.pm.ILauncherApps$Stub$Proxy: void startActivityAsUser(android.app.IApplicationThread,java.lang.String,java.lang.String,android.content.ComponentName,android.graphics.Rect,android.os.Bundle,android.os.UserHandle)>
	<android.content.pm.ILauncherApps$Stub$Proxy: void startSessionDetailsActivityAsUser(android.app.IApplicationThread,java.lang.String,java.lang.String,android.content.pm.PackageInstaller$SessionInfo,android.graphics.Rect,android.os.Bundle,android.os.UserHandle)>
	<android.content.pm.ILauncherApps$Stub$Proxy: boolean startShortcut(java.lang.String,java.lang.String,java.lang.String,java.lang.String,android.graphics.Rect,android.os.Bundle,int)>
	<android.content.pm.ILauncherApps$Stub$Proxy: void uncacheShortcuts(java.lang.String,java.lang.String,java.util.List,android.os.UserHandle,int)>
	<android.content.pm.ILauncherApps$Stub$Proxy: void unregisterShortcutChangeCallback(java.lang.String,android.content.pm.IShortcutChangeCallback)>

Name: lights
StubClassName: android.hardware.lights.ILightsManager
isAvaliable: true
Methods : 7 
	<android.hardware.lights.ILightsManager$Stub$Proxy: android.os.IBinder asBinder()>
	<android.hardware.lights.ILightsManager$Stub$Proxy: void closeSession(android.os.IBinder)>
	<android.hardware.lights.ILightsManager$Stub$Proxy: java.lang.String getInterfaceDescriptor()>
	<android.hardware.lights.ILightsManager$Stub$Proxy: android.hardware.lights.LightState getLightState(int)>
	<android.hardware.lights.ILightsManager$Stub$Proxy: java.util.List getLights()>
	<android.hardware.lights.ILightsManager$Stub$Proxy: void openSession(android.os.IBinder)>
	<android.hardware.lights.ILightsManager$Stub$Proxy: void setLightStates(android.os.IBinder,[I,[Landroid.hardware.lights.LightState;)>

Name: location
StubClassName: android.location.ILocationManager
isAvaliable: true
Methods : 53 
	<android.location.ILocationManager$Stub$Proxy: boolean addGnssAntennaInfoListener(android.location.IGnssAntennaInfoListener,java.lang.String,java.lang.String)>
	<android.location.ILocationManager$Stub$Proxy: boolean addGnssBatchingCallback(android.location.IBatchedLocationCallback,java.lang.String,java.lang.String)>
	<android.location.ILocationManager$Stub$Proxy: boolean addGnssMeasurementsListener(android.location.GnssRequest,android.location.IGnssMeasurementsListener,java.lang.String,java.lang.String)>
	<android.location.ILocationManager$Stub$Proxy: boolean addGnssNavigationMessageListener(android.location.IGnssNavigationMessageListener,java.lang.String,java.lang.String)>
	<android.location.ILocationManager$Stub$Proxy: void addTestProvider(java.lang.String,com.android.internal.location.ProviderProperties,java.lang.String,java.lang.String)>
	<android.location.ILocationManager$Stub$Proxy: android.os.IBinder asBinder()>
	<android.location.ILocationManager$Stub$Proxy: void flushGnssBatch(java.lang.String)>
	<android.location.ILocationManager$Stub$Proxy: boolean geocoderIsPresent()>
	<android.location.ILocationManager$Stub$Proxy: java.util.List getAllProviders()>
	<android.location.ILocationManager$Stub$Proxy: [Ljava.lang.String; getBackgroundThrottlingWhitelist()>
	<android.location.ILocationManager$Stub$Proxy: java.lang.String getBestProvider(android.location.Criteria,boolean)>
	<android.location.ILocationManager$Stub$Proxy: boolean getCurrentLocation(android.location.LocationRequest,android.os.ICancellationSignal,android.location.ILocationListener,java.lang.String,java.lang.String,java.lang.String)>
	<android.location.ILocationManager$Stub$Proxy: java.lang.String getExtraLocationControllerPackage()>
	<android.location.ILocationManager$Stub$Proxy: java.lang.String getFromLocation(double,double,int,android.location.GeocoderParams,java.util.List)>
	<android.location.ILocationManager$Stub$Proxy: java.lang.String getFromLocationName(java.lang.String,double,double,double,double,int,android.location.GeocoderParams,java.util.List)>
	<android.location.ILocationManager$Stub$Proxy: int getGnssBatchSize(java.lang.String)>
	<android.location.ILocationManager$Stub$Proxy: long getGnssCapabilities()>
	<android.location.ILocationManager$Stub$Proxy: java.lang.String getGnssHardwareModelName()>
	<android.location.ILocationManager$Stub$Proxy: android.location.LocationTime getGnssTimeMillis()>
	<android.location.ILocationManager$Stub$Proxy: int getGnssYearOfHardware()>
	<android.location.ILocationManager$Stub$Proxy: [Ljava.lang.String; getIgnoreSettingsWhitelist()>
	<android.location.ILocationManager$Stub$Proxy: java.lang.String getInterfaceDescriptor()>
	<android.location.ILocationManager$Stub$Proxy: android.location.Location getLastLocation(android.location.LocationRequest,java.lang.String,java.lang.String)>
	<android.location.ILocationManager$Stub$Proxy: java.util.List getProviderPackages(java.lang.String)>
	<android.location.ILocationManager$Stub$Proxy: com.android.internal.location.ProviderProperties getProviderProperties(java.lang.String)>
	<android.location.ILocationManager$Stub$Proxy: java.util.List getProviders(android.location.Criteria,boolean)>
	<android.location.ILocationManager$Stub$Proxy: java.util.List getTestProviderCurrentRequests(java.lang.String)>
	<android.location.ILocationManager$Stub$Proxy: void injectGnssMeasurementCorrections(android.location.GnssMeasurementCorrections,java.lang.String)>
	<android.location.ILocationManager$Stub$Proxy: void injectLocation(android.location.Location)>
	<android.location.ILocationManager$Stub$Proxy: boolean isExtraLocationControllerPackageEnabled()>
	<android.location.ILocationManager$Stub$Proxy: boolean isLocationEnabledForUser(int)>
	<android.location.ILocationManager$Stub$Proxy: boolean isProviderEnabledForUser(java.lang.String,int)>
	<android.location.ILocationManager$Stub$Proxy: boolean isProviderPackage(java.lang.String)>
	<android.location.ILocationManager$Stub$Proxy: void locationCallbackFinished(android.location.ILocationListener)>
	<android.location.ILocationManager$Stub$Proxy: boolean registerGnssStatusCallback(android.location.IGnssStatusListener,java.lang.String,java.lang.String)>
	<android.location.ILocationManager$Stub$Proxy: void removeGeofence(android.location.Geofence,android.app.PendingIntent,java.lang.String)>
	<android.location.ILocationManager$Stub$Proxy: void removeGnssAntennaInfoListener(android.location.IGnssAntennaInfoListener)>
	<android.location.ILocationManager$Stub$Proxy: void removeGnssBatchingCallback()>
	<android.location.ILocationManager$Stub$Proxy: void removeGnssMeasurementsListener(android.location.IGnssMeasurementsListener)>
	<android.location.ILocationManager$Stub$Proxy: void removeGnssNavigationMessageListener(android.location.IGnssNavigationMessageListener)>
	<android.location.ILocationManager$Stub$Proxy: void removeTestProvider(java.lang.String,java.lang.String,java.lang.String)>
	<android.location.ILocationManager$Stub$Proxy: void removeUpdates(android.location.ILocationListener,android.app.PendingIntent)>
	<android.location.ILocationManager$Stub$Proxy: void requestGeofence(android.location.LocationRequest,android.location.Geofence,android.app.PendingIntent,java.lang.String,java.lang.String)>
	<android.location.ILocationManager$Stub$Proxy: void requestLocationUpdates(android.location.LocationRequest,android.location.ILocationListener,android.app.PendingIntent,java.lang.String,java.lang.String,java.lang.String)>
	<android.location.ILocationManager$Stub$Proxy: boolean sendExtraCommand(java.lang.String,java.lang.String,android.os.Bundle)>
	<android.location.ILocationManager$Stub$Proxy: void setExtraLocationControllerPackage(java.lang.String)>
	<android.location.ILocationManager$Stub$Proxy: void setExtraLocationControllerPackageEnabled(boolean)>
	<android.location.ILocationManager$Stub$Proxy: void setLocationEnabledForUser(boolean,int)>
	<android.location.ILocationManager$Stub$Proxy: void setTestProviderEnabled(java.lang.String,boolean,java.lang.String,java.lang.String)>
	<android.location.ILocationManager$Stub$Proxy: void setTestProviderLocation(java.lang.String,android.location.Location,java.lang.String,java.lang.String)>
	<android.location.ILocationManager$Stub$Proxy: boolean startGnssBatch(long,boolean,java.lang.String,java.lang.String)>
	<android.location.ILocationManager$Stub$Proxy: boolean stopGnssBatch()>
	<android.location.ILocationManager$Stub$Proxy: void unregisterGnssStatusCallback(android.location.IGnssStatusListener)>

Name: lock_settings
StubClassName: null
isAvaliable: false
Methods : 0 

Name: looper_stats
StubClassName: null
isAvaliable: false
Methods : 0 

Name: manager
StubClassName: null
isAvaliable: false
Methods : 0 

Name: media.aaudio
StubClassName: null
isAvaliable: true
Methods : 0 

Name: media.audio_flinger
StubClassName: null
isAvaliable: true
Methods : 0 

Name: media.audio_policy
StubClassName: null
isAvaliable: true
Methods : 0 

Name: media.camera
StubClassName: android.hardware.ICameraService
isAvaliable: true
Methods : 20 
	<android.hardware.ICameraService$Stub$Proxy: [Landroid.hardware.CameraStatus; addListener(android.hardware.ICameraServiceListener)>
	<android.hardware.ICameraService$Stub$Proxy: android.os.IBinder asBinder()>
	<android.hardware.ICameraService$Stub$Proxy: android.hardware.ICamera connect(android.hardware.ICameraClient,int,java.lang.String,int,int)>
	<android.hardware.ICameraService$Stub$Proxy: android.hardware.camera2.ICameraDeviceUser connectDevice(android.hardware.camera2.ICameraDeviceCallbacks,java.lang.String,java.lang.String,java.lang.String,int)>
	<android.hardware.ICameraService$Stub$Proxy: android.hardware.ICamera connectLegacy(android.hardware.ICameraClient,int,int,java.lang.String,int)>
	<android.hardware.ICameraService$Stub$Proxy: android.hardware.camera2.impl.CameraMetadataNative getCameraCharacteristics(java.lang.String)>
	<android.hardware.ICameraService$Stub$Proxy: android.hardware.CameraInfo getCameraInfo(int)>
	<android.hardware.ICameraService$Stub$Proxy: android.hardware.camera2.params.VendorTagDescriptorCache getCameraVendorTagCache()>
	<android.hardware.ICameraService$Stub$Proxy: android.hardware.camera2.params.VendorTagDescriptor getCameraVendorTagDescriptor()>
	<android.hardware.ICameraService$Stub$Proxy: [Landroid.hardware.camera2.utils.ConcurrentCameraIdCombination; getConcurrentCameraIds()>
	<android.hardware.ICameraService$Stub$Proxy: java.lang.String getInterfaceDescriptor()>
	<android.hardware.ICameraService$Stub$Proxy: java.lang.String getLegacyParameters(int)>
	<android.hardware.ICameraService$Stub$Proxy: int getNumberOfCameras(int)>
	<android.hardware.ICameraService$Stub$Proxy: boolean isConcurrentSessionConfigurationSupported([Landroid.hardware.camera2.utils.CameraIdAndSessionConfiguration;)>
	<android.hardware.ICameraService$Stub$Proxy: boolean isHiddenPhysicalCamera(java.lang.String)>
	<android.hardware.ICameraService$Stub$Proxy: void notifyDeviceStateChange(long)>
	<android.hardware.ICameraService$Stub$Proxy: void notifySystemEvent(int,[I)>
	<android.hardware.ICameraService$Stub$Proxy: void removeListener(android.hardware.ICameraServiceListener)>
	<android.hardware.ICameraService$Stub$Proxy: void setTorchMode(java.lang.String,boolean,android.os.IBinder)>
	<android.hardware.ICameraService$Stub$Proxy: boolean supportsCameraApi(java.lang.String,int)>

Name: media.camera.proxy
StubClassName: null
isAvaliable: false
Methods : 0 

Name: media.extractor
StubClassName: null
isAvaliable: true
Methods : 0 

Name: media.metrics
StubClassName: null
isAvaliable: true
Methods : 0 

Name: media.player
StubClassName: null
isAvaliable: true
Methods : 0 

Name: media.resource_manager
StubClassName: android.media.IResourceManagerService
isAvaliable: true
Methods : 9 
	<android.media.IResourceManagerService$Stub$Proxy: void addResource(int,int,long,android.media.IResourceManagerClient,[Landroid.media.MediaResourceParcel;)>
	<android.media.IResourceManagerService$Stub$Proxy: android.os.IBinder asBinder()>
	<android.media.IResourceManagerService$Stub$Proxy: void config([Landroid.media.MediaResourcePolicyParcel;)>
	<android.media.IResourceManagerService$Stub$Proxy: java.lang.String getInterfaceDescriptor()>
	<android.media.IResourceManagerService$Stub$Proxy: void markClientForPendingRemoval(int,long)>
	<android.media.IResourceManagerService$Stub$Proxy: void overridePid(int,int)>
	<android.media.IResourceManagerService$Stub$Proxy: boolean reclaimResource(int,[Landroid.media.MediaResourceParcel;)>
	<android.media.IResourceManagerService$Stub$Proxy: void removeClient(int,long)>
	<android.media.IResourceManagerService$Stub$Proxy: void removeResource(int,long,[Landroid.media.MediaResourceParcel;)>

Name: media_projection
StubClassName: android.media.projection.IMediaProjectionManager
isAvaliable: true
Methods : 9 
	<android.media.projection.IMediaProjectionManager$Stub$Proxy: void addCallback(android.media.projection.IMediaProjectionWatcherCallback)>
	<android.media.projection.IMediaProjectionManager$Stub$Proxy: android.os.IBinder asBinder()>
	<android.media.projection.IMediaProjectionManager$Stub$Proxy: android.media.projection.IMediaProjection createProjection(int,java.lang.String,int,boolean)>
	<android.media.projection.IMediaProjectionManager$Stub$Proxy: android.media.projection.MediaProjectionInfo getActiveProjectionInfo()>
	<android.media.projection.IMediaProjectionManager$Stub$Proxy: java.lang.String getInterfaceDescriptor()>
	<android.media.projection.IMediaProjectionManager$Stub$Proxy: boolean hasProjectionPermission(int,java.lang.String)>
	<android.media.projection.IMediaProjectionManager$Stub$Proxy: boolean isValidMediaProjection(android.media.projection.IMediaProjection)>
	<android.media.projection.IMediaProjectionManager$Stub$Proxy: void removeCallback(android.media.projection.IMediaProjectionWatcherCallback)>
	<android.media.projection.IMediaProjectionManager$Stub$Proxy: void stopActiveProjection()>

Name: media_resource_monitor
StubClassName: android.media.IMediaResourceMonitor
isAvaliable: true
Methods : 3 
	<android.media.IMediaResourceMonitor$Stub$Proxy: android.os.IBinder asBinder()>
	<android.media.IMediaResourceMonitor$Stub$Proxy: java.lang.String getInterfaceDescriptor()>
	<android.media.IMediaResourceMonitor$Stub$Proxy: void notifyResourceGranted(int,int)>

Name: media_router
StubClassName: android.media.IMediaRouterService
isAvaliable: true
Methods : 33 
	<android.media.IMediaRouterService$Stub$Proxy: android.os.IBinder asBinder()>
	<android.media.IMediaRouterService$Stub$Proxy: void deselectRouteWithManager(android.media.IMediaRouter2Manager,int,java.lang.String,android.media.MediaRoute2Info)>
	<android.media.IMediaRouterService$Stub$Proxy: void deselectRouteWithRouter2(android.media.IMediaRouter2,java.lang.String,android.media.MediaRoute2Info)>
	<android.media.IMediaRouterService$Stub$Proxy: java.util.List getActiveSessions(android.media.IMediaRouter2Manager)>
	<android.media.IMediaRouterService$Stub$Proxy: java.lang.String getInterfaceDescriptor()>
	<android.media.IMediaRouterService$Stub$Proxy: android.media.MediaRouterClientState getState(android.media.IMediaRouterClient)>
	<android.media.IMediaRouterService$Stub$Proxy: java.util.List getSystemRoutes()>
	<android.media.IMediaRouterService$Stub$Proxy: android.media.RoutingSessionInfo getSystemSessionInfo()>
	<android.media.IMediaRouterService$Stub$Proxy: boolean isPlaybackActive(android.media.IMediaRouterClient)>
	<android.media.IMediaRouterService$Stub$Proxy: void registerClientAsUser(android.media.IMediaRouterClient,java.lang.String,int)>
	<android.media.IMediaRouterService$Stub$Proxy: void registerClientGroupId(android.media.IMediaRouterClient,java.lang.String)>
	<android.media.IMediaRouterService$Stub$Proxy: void registerManager(android.media.IMediaRouter2Manager,java.lang.String)>
	<android.media.IMediaRouterService$Stub$Proxy: void registerRouter2(android.media.IMediaRouter2,java.lang.String)>
	<android.media.IMediaRouterService$Stub$Proxy: void releaseSessionWithManager(android.media.IMediaRouter2Manager,int,java.lang.String)>
	<android.media.IMediaRouterService$Stub$Proxy: void releaseSessionWithRouter2(android.media.IMediaRouter2,java.lang.String)>
	<android.media.IMediaRouterService$Stub$Proxy: void requestCreateSessionWithManager(android.media.IMediaRouter2Manager,int,android.media.RoutingSessionInfo,android.media.MediaRoute2Info)>
	<android.media.IMediaRouterService$Stub$Proxy: void requestCreateSessionWithRouter2(android.media.IMediaRouter2,int,long,android.media.RoutingSessionInfo,android.media.MediaRoute2Info,android.os.Bundle)>
	<android.media.IMediaRouterService$Stub$Proxy: void requestSetVolume(android.media.IMediaRouterClient,java.lang.String,int)>
	<android.media.IMediaRouterService$Stub$Proxy: void requestUpdateVolume(android.media.IMediaRouterClient,java.lang.String,int)>
	<android.media.IMediaRouterService$Stub$Proxy: void selectRouteWithManager(android.media.IMediaRouter2Manager,int,java.lang.String,android.media.MediaRoute2Info)>
	<android.media.IMediaRouterService$Stub$Proxy: void selectRouteWithRouter2(android.media.IMediaRouter2,java.lang.String,android.media.MediaRoute2Info)>
	<android.media.IMediaRouterService$Stub$Proxy: void setDiscoveryRequest(android.media.IMediaRouterClient,int,boolean)>
	<android.media.IMediaRouterService$Stub$Proxy: void setDiscoveryRequestWithRouter2(android.media.IMediaRouter2,android.media.RouteDiscoveryPreference)>
	<android.media.IMediaRouterService$Stub$Proxy: void setRouteVolumeWithManager(android.media.IMediaRouter2Manager,int,android.media.MediaRoute2Info,int)>
	<android.media.IMediaRouterService$Stub$Proxy: void setRouteVolumeWithRouter2(android.media.IMediaRouter2,android.media.MediaRoute2Info,int)>
	<android.media.IMediaRouterService$Stub$Proxy: void setSelectedRoute(android.media.IMediaRouterClient,java.lang.String,boolean)>
	<android.media.IMediaRouterService$Stub$Proxy: void setSessionVolumeWithManager(android.media.IMediaRouter2Manager,int,java.lang.String,int)>
	<android.media.IMediaRouterService$Stub$Proxy: void setSessionVolumeWithRouter2(android.media.IMediaRouter2,java.lang.String,int)>
	<android.media.IMediaRouterService$Stub$Proxy: void transferToRouteWithManager(android.media.IMediaRouter2Manager,int,java.lang.String,android.media.MediaRoute2Info)>
	<android.media.IMediaRouterService$Stub$Proxy: void transferToRouteWithRouter2(android.media.IMediaRouter2,java.lang.String,android.media.MediaRoute2Info)>
	<android.media.IMediaRouterService$Stub$Proxy: void unregisterClient(android.media.IMediaRouterClient)>
	<android.media.IMediaRouterService$Stub$Proxy: void unregisterManager(android.media.IMediaRouter2Manager)>
	<android.media.IMediaRouterService$Stub$Proxy: void unregisterRouter2(android.media.IMediaRouter2)>

Name: media_session
StubClassName: android.media.session.ISessionManager
isAvaliable: true
Methods : 29 
	<android.media.session.ISessionManager$Stub$Proxy: void addOnMediaKeyEventDispatchedListener(android.media.session.IOnMediaKeyEventDispatchedListener)>
	<android.media.session.ISessionManager$Stub$Proxy: void addOnMediaKeyEventSessionChangedListener(android.media.session.IOnMediaKeyEventSessionChangedListener)>
	<android.media.session.ISessionManager$Stub$Proxy: void addSession2TokensListener(android.media.session.ISession2TokensListener,int)>
	<android.media.session.ISessionManager$Stub$Proxy: void addSessionsListener(android.media.session.IActiveSessionsListener,android.content.ComponentName,int)>
	<android.media.session.ISessionManager$Stub$Proxy: android.os.IBinder asBinder()>
	<android.media.session.ISessionManager$Stub$Proxy: android.media.session.ISession createSession(java.lang.String,android.media.session.ISessionCallback,java.lang.String,android.os.Bundle,int)>
	<android.media.session.ISessionManager$Stub$Proxy: void dispatchAdjustVolume(java.lang.String,java.lang.String,int,int,int)>
	<android.media.session.ISessionManager$Stub$Proxy: void dispatchMediaKeyEvent(java.lang.String,boolean,android.view.KeyEvent,boolean)>
	<android.media.session.ISessionManager$Stub$Proxy: boolean dispatchMediaKeyEventToSessionAsSystemService(java.lang.String,android.media.session.MediaSession$Token,android.view.KeyEvent)>
	<android.media.session.ISessionManager$Stub$Proxy: void dispatchVolumeKeyEvent(java.lang.String,java.lang.String,boolean,android.view.KeyEvent,int,boolean)>
	<android.media.session.ISessionManager$Stub$Proxy: void dispatchVolumeKeyEventToSessionAsSystemService(java.lang.String,java.lang.String,android.media.session.MediaSession$Token,android.view.KeyEvent)>
	<android.media.session.ISessionManager$Stub$Proxy: java.lang.String getInterfaceDescriptor()>
	<android.media.session.ISessionManager$Stub$Proxy: android.content.pm.ParceledListSlice getSession2Tokens(int)>
	<android.media.session.ISessionManager$Stub$Proxy: int getSessionPolicies(android.media.session.MediaSession$Token)>
	<android.media.session.ISessionManager$Stub$Proxy: java.util.List getSessions(android.content.ComponentName,int)>
	<android.media.session.ISessionManager$Stub$Proxy: boolean isGlobalPriorityActive()>
	<android.media.session.ISessionManager$Stub$Proxy: boolean isTrusted(java.lang.String,int,int)>
	<android.media.session.ISessionManager$Stub$Proxy: void notifySession2Created(android.media.Session2Token)>
	<android.media.session.ISessionManager$Stub$Proxy: void registerRemoteVolumeController(android.media.IRemoteVolumeController)>
	<android.media.session.ISessionManager$Stub$Proxy: void removeOnMediaKeyEventDispatchedListener(android.media.session.IOnMediaKeyEventDispatchedListener)>
	<android.media.session.ISessionManager$Stub$Proxy: void removeOnMediaKeyEventSessionChangedListener(android.media.session.IOnMediaKeyEventSessionChangedListener)>
	<android.media.session.ISessionManager$Stub$Proxy: void removeSession2TokensListener(android.media.session.ISession2TokensListener)>
	<android.media.session.ISessionManager$Stub$Proxy: void removeSessionsListener(android.media.session.IActiveSessionsListener)>
	<android.media.session.ISessionManager$Stub$Proxy: void setCustomMediaKeyDispatcherForTesting(java.lang.String)>
	<android.media.session.ISessionManager$Stub$Proxy: void setCustomSessionPolicyProviderForTesting(java.lang.String)>
	<android.media.session.ISessionManager$Stub$Proxy: void setOnMediaKeyListener(android.media.session.IOnMediaKeyListener)>
	<android.media.session.ISessionManager$Stub$Proxy: void setOnVolumeKeyLongPressListener(android.media.session.IOnVolumeKeyLongPressListener)>
	<android.media.session.ISessionManager$Stub$Proxy: void setSessionPolicies(android.media.session.MediaSession$Token,int)>
	<android.media.session.ISessionManager$Stub$Proxy: void unregisterRemoteVolumeController(android.media.IRemoteVolumeController)>

Name: meminfo
StubClassName: null
isAvaliable: false
Methods : 0 

Name: midi
StubClassName: android.media.midi.IMidiManager
isAvaliable: true
Methods : 13 
	<android.media.midi.IMidiManager$Stub$Proxy: android.os.IBinder asBinder()>
	<android.media.midi.IMidiManager$Stub$Proxy: void closeDevice(android.os.IBinder,android.os.IBinder)>
	<android.media.midi.IMidiManager$Stub$Proxy: android.media.midi.MidiDeviceStatus getDeviceStatus(android.media.midi.MidiDeviceInfo)>
	<android.media.midi.IMidiManager$Stub$Proxy: [Landroid.media.midi.MidiDeviceInfo; getDevices()>
	<android.media.midi.IMidiManager$Stub$Proxy: java.lang.String getInterfaceDescriptor()>
	<android.media.midi.IMidiManager$Stub$Proxy: android.media.midi.MidiDeviceInfo getServiceDeviceInfo(java.lang.String,java.lang.String)>
	<android.media.midi.IMidiManager$Stub$Proxy: void openBluetoothDevice(android.os.IBinder,android.bluetooth.BluetoothDevice,android.media.midi.IMidiDeviceOpenCallback)>
	<android.media.midi.IMidiManager$Stub$Proxy: void openDevice(android.os.IBinder,android.media.midi.MidiDeviceInfo,android.media.midi.IMidiDeviceOpenCallback)>
	<android.media.midi.IMidiManager$Stub$Proxy: android.media.midi.MidiDeviceInfo registerDeviceServer(android.media.midi.IMidiDeviceServer,int,int,[Ljava.lang.String;,[Ljava.lang.String;,android.os.Bundle,int)>
	<android.media.midi.IMidiManager$Stub$Proxy: void registerListener(android.os.IBinder,android.media.midi.IMidiDeviceListener)>
	<android.media.midi.IMidiManager$Stub$Proxy: void setDeviceStatus(android.media.midi.IMidiDeviceServer,android.media.midi.MidiDeviceStatus)>
	<android.media.midi.IMidiManager$Stub$Proxy: void unregisterDeviceServer(android.media.midi.IMidiDeviceServer)>
	<android.media.midi.IMidiManager$Stub$Proxy: void unregisterListener(android.os.IBinder,android.media.midi.IMidiDeviceListener)>

Name: mount
StubClassName: android.os.storage.IStorageManager
isAvaliable: true
Methods : 66 
	<android.os.storage.IStorageManager$Stub$Proxy: void abortChanges(java.lang.String,boolean)>
	<android.os.storage.IStorageManager$Stub$Proxy: void abortIdleMaintenance()>
	<android.os.storage.IStorageManager$Stub$Proxy: void addUserKeyAuth(int,int,[B,[B)>
	<android.os.storage.IStorageManager$Stub$Proxy: void allocateBytes(java.lang.String,long,int,java.lang.String)>
	<android.os.storage.IStorageManager$Stub$Proxy: android.os.IBinder asBinder()>
	<android.os.storage.IStorageManager$Stub$Proxy: void benchmark(java.lang.String,android.os.IVoldTaskListener)>
	<android.os.storage.IStorageManager$Stub$Proxy: int changeEncryptionPassword(int,java.lang.String)>
	<android.os.storage.IStorageManager$Stub$Proxy: void clearPassword()>
	<android.os.storage.IStorageManager$Stub$Proxy: void clearUserKeyAuth(int,int,[B,[B)>
	<android.os.storage.IStorageManager$Stub$Proxy: void commitChanges()>
	<android.os.storage.IStorageManager$Stub$Proxy: void createUserKey(int,int,boolean)>
	<android.os.storage.IStorageManager$Stub$Proxy: int decryptStorage(java.lang.String)>
	<android.os.storage.IStorageManager$Stub$Proxy: void destroyUserKey(int)>
	<android.os.storage.IStorageManager$Stub$Proxy: void destroyUserStorage(java.lang.String,int,int)>
	<android.os.storage.IStorageManager$Stub$Proxy: int encryptStorage(int,java.lang.String)>
	<android.os.storage.IStorageManager$Stub$Proxy: void fixateNewestUserKeyAuth(int)>
	<android.os.storage.IStorageManager$Stub$Proxy: void fixupAppDir(java.lang.String)>
	<android.os.storage.IStorageManager$Stub$Proxy: void forgetAllVolumes()>
	<android.os.storage.IStorageManager$Stub$Proxy: void forgetVolume(java.lang.String)>
	<android.os.storage.IStorageManager$Stub$Proxy: void format(java.lang.String)>
	<android.os.storage.IStorageManager$Stub$Proxy: void fstrim(int,android.os.IVoldTaskListener)>
	<android.os.storage.IStorageManager$Stub$Proxy: long getAllocatableBytes(java.lang.String,int,java.lang.String)>
	<android.os.storage.IStorageManager$Stub$Proxy: long getCacheQuotaBytes(java.lang.String,int)>
	<android.os.storage.IStorageManager$Stub$Proxy: long getCacheSizeBytes(java.lang.String,int)>
	<android.os.storage.IStorageManager$Stub$Proxy: [Landroid.os.storage.DiskInfo; getDisks()>
	<android.os.storage.IStorageManager$Stub$Proxy: int getEncryptionState()>
	<android.os.storage.IStorageManager$Stub$Proxy: java.lang.String getField(java.lang.String)>
	<android.os.storage.IStorageManager$Stub$Proxy: java.lang.String getInterfaceDescriptor()>
	<android.os.storage.IStorageManager$Stub$Proxy: java.lang.String getMountedObbPath(java.lang.String)>
	<android.os.storage.IStorageManager$Stub$Proxy: java.lang.String getPassword()>
	<android.os.storage.IStorageManager$Stub$Proxy: int getPasswordType()>
	<android.os.storage.IStorageManager$Stub$Proxy: java.lang.String getPrimaryStorageUuid()>
	<android.os.storage.IStorageManager$Stub$Proxy: [Landroid.os.storage.StorageVolume; getVolumeList(int,java.lang.String,int)>
	<android.os.storage.IStorageManager$Stub$Proxy: [Landroid.os.storage.VolumeRecord; getVolumeRecords(int)>
	<android.os.storage.IStorageManager$Stub$Proxy: [Landroid.os.storage.VolumeInfo; getVolumes(int)>
	<android.os.storage.IStorageManager$Stub$Proxy: boolean isConvertibleToFBE()>
	<android.os.storage.IStorageManager$Stub$Proxy: boolean isObbMounted(java.lang.String)>
	<android.os.storage.IStorageManager$Stub$Proxy: boolean isUserKeyUnlocked(int)>
	<android.os.storage.IStorageManager$Stub$Proxy: long lastMaintenance()>
	<android.os.storage.IStorageManager$Stub$Proxy: void lockUserKey(int)>
	<android.os.storage.IStorageManager$Stub$Proxy: void mkdirs(java.lang.String,java.lang.String)>
	<android.os.storage.IStorageManager$Stub$Proxy: void mount(java.lang.String)>
	<android.os.storage.IStorageManager$Stub$Proxy: void mountObb(java.lang.String,java.lang.String,java.lang.String,android.os.storage.IObbActionListener,int,android.content.res.ObbInfo)>
	<android.os.storage.IStorageManager$Stub$Proxy: com.android.internal.os.AppFuseMount mountProxyFileDescriptorBridge()>
	<android.os.storage.IStorageManager$Stub$Proxy: boolean needsCheckpoint()>
	<android.os.storage.IStorageManager$Stub$Proxy: android.os.ParcelFileDescriptor openProxyFileDescriptor(int,int,int)>
	<android.os.storage.IStorageManager$Stub$Proxy: void partitionMixed(java.lang.String,int)>
	<android.os.storage.IStorageManager$Stub$Proxy: void partitionPrivate(java.lang.String)>
	<android.os.storage.IStorageManager$Stub$Proxy: void partitionPublic(java.lang.String)>
	<android.os.storage.IStorageManager$Stub$Proxy: void prepareUserStorage(java.lang.String,int,int,int)>
	<android.os.storage.IStorageManager$Stub$Proxy: void registerListener(android.os.storage.IStorageEventListener)>
	<android.os.storage.IStorageManager$Stub$Proxy: void runIdleMaintenance()>
	<android.os.storage.IStorageManager$Stub$Proxy: void runMaintenance()>
	<android.os.storage.IStorageManager$Stub$Proxy: void setDebugFlags(int,int)>
	<android.os.storage.IStorageManager$Stub$Proxy: void setField(java.lang.String,java.lang.String)>
	<android.os.storage.IStorageManager$Stub$Proxy: void setPrimaryStorageUuid(java.lang.String,android.content.pm.IPackageMoveObserver)>
	<android.os.storage.IStorageManager$Stub$Proxy: void setVolumeNickname(java.lang.String,java.lang.String)>
	<android.os.storage.IStorageManager$Stub$Proxy: void setVolumeUserFlags(java.lang.String,int,int)>
	<android.os.storage.IStorageManager$Stub$Proxy: void shutdown(android.os.storage.IStorageShutdownObserver)>
	<android.os.storage.IStorageManager$Stub$Proxy: void startCheckpoint(int)>
	<android.os.storage.IStorageManager$Stub$Proxy: boolean supportsCheckpoint()>
	<android.os.storage.IStorageManager$Stub$Proxy: void unlockUserKey(int,int,[B,[B)>
	<android.os.storage.IStorageManager$Stub$Proxy: void unmount(java.lang.String)>
	<android.os.storage.IStorageManager$Stub$Proxy: void unmountObb(java.lang.String,boolean,android.os.storage.IObbActionListener,int)>
	<android.os.storage.IStorageManager$Stub$Proxy: void unregisterListener(android.os.storage.IStorageEventListener)>
	<android.os.storage.IStorageManager$Stub$Proxy: int verifyEncryptionPassword(java.lang.String)>

Name: netd
StubClassName: null
isAvaliable: false
Methods : 0 

Name: netd_listener
StubClassName: null
isAvaliable: false
Methods : 0 

Name: netpolicy
StubClassName: android.net.INetworkPolicyManager
isAvaliable: true
Methods : 24 
	<android.net.INetworkPolicyManager$Stub$Proxy: void addUidPolicy(int,int)>
	<android.net.INetworkPolicyManager$Stub$Proxy: android.os.IBinder asBinder()>
	<android.net.INetworkPolicyManager$Stub$Proxy: void factoryReset(java.lang.String)>
	<android.net.INetworkPolicyManager$Stub$Proxy: java.lang.String getInterfaceDescriptor()>
	<android.net.INetworkPolicyManager$Stub$Proxy: [Landroid.net.NetworkPolicy; getNetworkPolicies(java.lang.String)>
	<android.net.INetworkPolicyManager$Stub$Proxy: android.net.NetworkQuotaInfo getNetworkQuotaInfo(android.net.NetworkState)>
	<android.net.INetworkPolicyManager$Stub$Proxy: boolean getRestrictBackground()>
	<android.net.INetworkPolicyManager$Stub$Proxy: int getRestrictBackgroundByCaller()>
	<android.net.INetworkPolicyManager$Stub$Proxy: [Landroid.telephony.SubscriptionPlan; getSubscriptionPlans(int,java.lang.String)>
	<android.net.INetworkPolicyManager$Stub$Proxy: java.lang.String getSubscriptionPlansOwner(int)>
	<android.net.INetworkPolicyManager$Stub$Proxy: int getUidPolicy(int)>
	<android.net.INetworkPolicyManager$Stub$Proxy: [I getUidsWithPolicy(int)>
	<android.net.INetworkPolicyManager$Stub$Proxy: boolean isUidNetworkingBlocked(int,boolean)>
	<android.net.INetworkPolicyManager$Stub$Proxy: void registerListener(android.net.INetworkPolicyListener)>
	<android.net.INetworkPolicyManager$Stub$Proxy: void removeUidPolicy(int,int)>
	<android.net.INetworkPolicyManager$Stub$Proxy: void setDeviceIdleMode(boolean)>
	<android.net.INetworkPolicyManager$Stub$Proxy: void setNetworkPolicies([Landroid.net.NetworkPolicy;)>
	<android.net.INetworkPolicyManager$Stub$Proxy: void setRestrictBackground(boolean)>
	<android.net.INetworkPolicyManager$Stub$Proxy: void setSubscriptionOverride(int,int,int,long,java.lang.String)>
	<android.net.INetworkPolicyManager$Stub$Proxy: void setSubscriptionPlans(int,[Landroid.telephony.SubscriptionPlan;,java.lang.String)>
	<android.net.INetworkPolicyManager$Stub$Proxy: void setUidPolicy(int,int)>
	<android.net.INetworkPolicyManager$Stub$Proxy: void setWifiMeteredOverride(java.lang.String,int)>
	<android.net.INetworkPolicyManager$Stub$Proxy: void snoozeLimit(android.net.NetworkTemplate)>
	<android.net.INetworkPolicyManager$Stub$Proxy: void unregisterListener(android.net.INetworkPolicyListener)>

Name: netstats
StubClassName: android.net.INetworkStatsService
isAvaliable: true
Methods : 16 
	<android.net.INetworkStatsService$Stub$Proxy: android.os.IBinder asBinder()>
	<android.net.INetworkStatsService$Stub$Proxy: void forceUpdate()>
	<android.net.INetworkStatsService$Stub$Proxy: void forceUpdateIfaces([Landroid.net.Network;,[Landroid.net.NetworkState;,java.lang.String,[Lcom.android.internal.net.VpnInfo;)>
	<android.net.INetworkStatsService$Stub$Proxy: android.net.NetworkStats getDataLayerSnapshotForUid(int)>
	<android.net.INetworkStatsService$Stub$Proxy: android.net.NetworkStats getDetailedUidStats([Ljava.lang.String;)>
	<android.net.INetworkStatsService$Stub$Proxy: long getIfaceStats(java.lang.String,int)>
	<android.net.INetworkStatsService$Stub$Proxy: java.lang.String getInterfaceDescriptor()>
	<android.net.INetworkStatsService$Stub$Proxy: [Ljava.lang.String; getMobileIfaces()>
	<android.net.INetworkStatsService$Stub$Proxy: long getTotalStats(int)>
	<android.net.INetworkStatsService$Stub$Proxy: long getUidStats(int,int)>
	<android.net.INetworkStatsService$Stub$Proxy: void incrementOperationCount(int,int,int)>
	<android.net.INetworkStatsService$Stub$Proxy: android.net.INetworkStatsSession openSession()>
	<android.net.INetworkStatsService$Stub$Proxy: android.net.INetworkStatsSession openSessionForUsageStats(int,java.lang.String)>
	<android.net.INetworkStatsService$Stub$Proxy: android.net.netstats.provider.INetworkStatsProviderCallback registerNetworkStatsProvider(java.lang.String,android.net.netstats.provider.INetworkStatsProvider)>
	<android.net.INetworkStatsService$Stub$Proxy: android.net.DataUsageRequest registerUsageCallback(java.lang.String,android.net.DataUsageRequest,android.os.Messenger,android.os.IBinder)>
	<android.net.INetworkStatsService$Stub$Proxy: void unregisterUsageRequest(android.net.DataUsageRequest)>

Name: network_management
StubClassName: android.os.INetworkManagementService
isAvaliable: true
Methods : 73 
	<android.os.INetworkManagementService$Stub$Proxy: void addIdleTimer(java.lang.String,int,int)>
	<android.os.INetworkManagementService$Stub$Proxy: void addInterfaceToLocalNetwork(java.lang.String,java.util.List)>
	<android.os.INetworkManagementService$Stub$Proxy: void addInterfaceToNetwork(java.lang.String,int)>
	<android.os.INetworkManagementService$Stub$Proxy: void addLegacyRouteForNetId(int,android.net.RouteInfo,int)>
	<android.os.INetworkManagementService$Stub$Proxy: void addRoute(int,android.net.RouteInfo)>
	<android.os.INetworkManagementService$Stub$Proxy: void addVpnUidRanges(int,[Landroid.net.UidRange;)>
	<android.os.INetworkManagementService$Stub$Proxy: void allowProtect(int)>
	<android.os.INetworkManagementService$Stub$Proxy: android.os.IBinder asBinder()>
	<android.os.INetworkManagementService$Stub$Proxy: void clearDefaultNetId()>
	<android.os.INetworkManagementService$Stub$Proxy: void clearInterfaceAddresses(java.lang.String)>
	<android.os.INetworkManagementService$Stub$Proxy: void denyProtect(int)>
	<android.os.INetworkManagementService$Stub$Proxy: void disableIpv6(java.lang.String)>
	<android.os.INetworkManagementService$Stub$Proxy: void disableNat(java.lang.String,java.lang.String)>
	<android.os.INetworkManagementService$Stub$Proxy: void enableIpv6(java.lang.String)>
	<android.os.INetworkManagementService$Stub$Proxy: void enableNat(java.lang.String,java.lang.String)>
	<android.os.INetworkManagementService$Stub$Proxy: [Ljava.lang.String; getDnsForwarders()>
	<android.os.INetworkManagementService$Stub$Proxy: android.net.InterfaceConfiguration getInterfaceConfig(java.lang.String)>
	<android.os.INetworkManagementService$Stub$Proxy: java.lang.String getInterfaceDescriptor()>
	<android.os.INetworkManagementService$Stub$Proxy: boolean getIpForwardingEnabled()>
	<android.os.INetworkManagementService$Stub$Proxy: android.net.NetworkStats getNetworkStatsTethering(int)>
	<android.os.INetworkManagementService$Stub$Proxy: boolean isBandwidthControlEnabled()>
	<android.os.INetworkManagementService$Stub$Proxy: boolean isFirewallEnabled()>
	<android.os.INetworkManagementService$Stub$Proxy: boolean isNetworkActive()>
	<android.os.INetworkManagementService$Stub$Proxy: boolean isNetworkRestricted(int)>
	<android.os.INetworkManagementService$Stub$Proxy: boolean isTetheringStarted()>
	<android.os.INetworkManagementService$Stub$Proxy: [Ljava.lang.String; listInterfaces()>
	<android.os.INetworkManagementService$Stub$Proxy: [Ljava.lang.String; listTetheredInterfaces()>
	<android.os.INetworkManagementService$Stub$Proxy: void registerNetworkActivityListener(android.os.INetworkActivityListener)>
	<android.os.INetworkManagementService$Stub$Proxy: void registerObserver(android.net.INetworkManagementEventObserver)>
	<android.os.INetworkManagementService$Stub$Proxy: void registerTetheringStatsProvider(android.net.ITetheringStatsProvider,java.lang.String)>
	<android.os.INetworkManagementService$Stub$Proxy: void removeIdleTimer(java.lang.String)>
	<android.os.INetworkManagementService$Stub$Proxy: void removeInterfaceAlert(java.lang.String)>
	<android.os.INetworkManagementService$Stub$Proxy: void removeInterfaceFromLocalNetwork(java.lang.String)>
	<android.os.INetworkManagementService$Stub$Proxy: void removeInterfaceFromNetwork(java.lang.String,int)>
	<android.os.INetworkManagementService$Stub$Proxy: void removeInterfaceQuota(java.lang.String)>
	<android.os.INetworkManagementService$Stub$Proxy: void removeRoute(int,android.net.RouteInfo)>
	<android.os.INetworkManagementService$Stub$Proxy: int removeRoutesFromLocalNetwork(java.util.List)>
	<android.os.INetworkManagementService$Stub$Proxy: void removeVpnUidRanges(int,[Landroid.net.UidRange;)>
	<android.os.INetworkManagementService$Stub$Proxy: void setAllowOnlyVpnForUids(boolean,[Landroid.net.UidRange;)>
	<android.os.INetworkManagementService$Stub$Proxy: boolean setDataSaverModeEnabled(boolean)>
	<android.os.INetworkManagementService$Stub$Proxy: void setDefaultNetId(int)>
	<android.os.INetworkManagementService$Stub$Proxy: void setDnsForwarders(android.net.Network,[Ljava.lang.String;)>
	<android.os.INetworkManagementService$Stub$Proxy: void setFirewallChainEnabled(int,boolean)>
	<android.os.INetworkManagementService$Stub$Proxy: void setFirewallEnabled(boolean)>
	<android.os.INetworkManagementService$Stub$Proxy: void setFirewallInterfaceRule(java.lang.String,boolean)>
	<android.os.INetworkManagementService$Stub$Proxy: void setFirewallUidRule(int,int,int)>
	<android.os.INetworkManagementService$Stub$Proxy: void setFirewallUidRules(int,[I,[I)>
	<android.os.INetworkManagementService$Stub$Proxy: void setGlobalAlert(long)>
	<android.os.INetworkManagementService$Stub$Proxy: void setIPv6AddrGenMode(java.lang.String,int)>
	<android.os.INetworkManagementService$Stub$Proxy: void setInterfaceAlert(java.lang.String,long)>
	<android.os.INetworkManagementService$Stub$Proxy: void setInterfaceConfig(java.lang.String,android.net.InterfaceConfiguration)>
	<android.os.INetworkManagementService$Stub$Proxy: void setInterfaceDown(java.lang.String)>
	<android.os.INetworkManagementService$Stub$Proxy: void setInterfaceIpv6PrivacyExtensions(java.lang.String,boolean)>
	<android.os.INetworkManagementService$Stub$Proxy: void setInterfaceQuota(java.lang.String,long)>
	<android.os.INetworkManagementService$Stub$Proxy: void setInterfaceUp(java.lang.String)>
	<android.os.INetworkManagementService$Stub$Proxy: void setIpForwardingEnabled(boolean)>
	<android.os.INetworkManagementService$Stub$Proxy: void setMtu(java.lang.String,int)>
	<android.os.INetworkManagementService$Stub$Proxy: void setNetworkPermission(int,int)>
	<android.os.INetworkManagementService$Stub$Proxy: void setUidCleartextNetworkPolicy(int,int)>
	<android.os.INetworkManagementService$Stub$Proxy: void setUidMeteredNetworkBlacklist(int,boolean)>
	<android.os.INetworkManagementService$Stub$Proxy: void setUidMeteredNetworkWhitelist(int,boolean)>
	<android.os.INetworkManagementService$Stub$Proxy: void shutdown()>
	<android.os.INetworkManagementService$Stub$Proxy: void startInterfaceForwarding(java.lang.String,java.lang.String)>
	<android.os.INetworkManagementService$Stub$Proxy: void startTethering([Ljava.lang.String;)>
	<android.os.INetworkManagementService$Stub$Proxy: void startTetheringWithConfiguration(boolean,[Ljava.lang.String;)>
	<android.os.INetworkManagementService$Stub$Proxy: void stopInterfaceForwarding(java.lang.String,java.lang.String)>
	<android.os.INetworkManagementService$Stub$Proxy: void stopTethering()>
	<android.os.INetworkManagementService$Stub$Proxy: void tetherInterface(java.lang.String)>
	<android.os.INetworkManagementService$Stub$Proxy: void tetherLimitReached(android.net.ITetheringStatsProvider)>
	<android.os.INetworkManagementService$Stub$Proxy: void unregisterNetworkActivityListener(android.os.INetworkActivityListener)>
	<android.os.INetworkManagementService$Stub$Proxy: void unregisterObserver(android.net.INetworkManagementEventObserver)>
	<android.os.INetworkManagementService$Stub$Proxy: void unregisterTetheringStatsProvider(android.net.ITetheringStatsProvider)>
	<android.os.INetworkManagementService$Stub$Proxy: void untetherInterface(java.lang.String)>

Name: network_score
StubClassName: null
isAvaliable: false
Methods : 0 

Name: network_stack
StubClassName: null
isAvaliable: false
Methods : 0 

Name: network_time_update_service
StubClassName: null
isAvaliable: false
Methods : 0 

Name: network_watchlist
StubClassName: null
isAvaliable: false
Methods : 0 

Name: nfc
StubClassName: android.nfc.INfcAdapter
isAvaliable: true
Methods : 29 
	<android.nfc.INfcAdapter$Stub$Proxy: void addNfcUnlockHandler(android.nfc.INfcUnlockHandler,[I)>
	<android.nfc.INfcAdapter$Stub$Proxy: android.os.IBinder asBinder()>
	<android.nfc.INfcAdapter$Stub$Proxy: boolean deviceSupportsNfcSecure()>
	<android.nfc.INfcAdapter$Stub$Proxy: boolean disable(boolean)>
	<android.nfc.INfcAdapter$Stub$Proxy: boolean disableNdefPush()>
	<android.nfc.INfcAdapter$Stub$Proxy: void dispatch(android.nfc.Tag)>
	<android.nfc.INfcAdapter$Stub$Proxy: boolean enable()>
	<android.nfc.INfcAdapter$Stub$Proxy: boolean enableNdefPush()>
	<android.nfc.INfcAdapter$Stub$Proxy: java.lang.String getInterfaceDescriptor()>
	<android.nfc.INfcAdapter$Stub$Proxy: android.nfc.INfcAdapterExtras getNfcAdapterExtrasInterface(java.lang.String)>
	<android.nfc.INfcAdapter$Stub$Proxy: android.nfc.INfcCardEmulation getNfcCardEmulationInterface()>
	<android.nfc.INfcAdapter$Stub$Proxy: android.nfc.INfcDta getNfcDtaInterface(java.lang.String)>
	<android.nfc.INfcAdapter$Stub$Proxy: android.nfc.INfcFCardEmulation getNfcFCardEmulationInterface()>
	<android.nfc.INfcAdapter$Stub$Proxy: android.nfc.INfcTag getNfcTagInterface()>
	<android.nfc.INfcAdapter$Stub$Proxy: int getState()>
	<android.nfc.INfcAdapter$Stub$Proxy: boolean ignore(int,int,android.nfc.ITagRemovedCallback)>
	<android.nfc.INfcAdapter$Stub$Proxy: void invokeBeam()>
	<android.nfc.INfcAdapter$Stub$Proxy: void invokeBeamInternal(android.nfc.BeamShareData)>
	<android.nfc.INfcAdapter$Stub$Proxy: boolean isNdefPushEnabled()>
	<android.nfc.INfcAdapter$Stub$Proxy: boolean isNfcSecureEnabled()>
	<android.nfc.INfcAdapter$Stub$Proxy: void pausePolling(int)>
	<android.nfc.INfcAdapter$Stub$Proxy: void removeNfcUnlockHandler(android.nfc.INfcUnlockHandler)>
	<android.nfc.INfcAdapter$Stub$Proxy: void resumePolling()>
	<android.nfc.INfcAdapter$Stub$Proxy: void setAppCallback(android.nfc.IAppCallback)>
	<android.nfc.INfcAdapter$Stub$Proxy: void setForegroundDispatch(android.app.PendingIntent,[Landroid.content.IntentFilter;,android.nfc.TechListParcel)>
	<android.nfc.INfcAdapter$Stub$Proxy: boolean setNfcSecure(boolean)>
	<android.nfc.INfcAdapter$Stub$Proxy: void setP2pModes(int,int)>
	<android.nfc.INfcAdapter$Stub$Proxy: void setReaderMode(android.os.IBinder,android.nfc.IAppCallback,int,android.os.Bundle)>
	<android.nfc.INfcAdapter$Stub$Proxy: void verifyNfcPermission()>

Name: notification
StubClassName: android.app.INotificationManager
isAvaliable: true
Methods : 137 
	<android.app.INotificationManager$Stub$Proxy: java.lang.String addAutomaticZenRule(android.app.AutomaticZenRule)>
	<android.app.INotificationManager$Stub$Proxy: void allowAssistantAdjustment(java.lang.String)>
	<android.app.INotificationManager$Stub$Proxy: void applyAdjustmentFromAssistant(android.service.notification.INotificationListener,android.service.notification.Adjustment)>
	<android.app.INotificationManager$Stub$Proxy: void applyAdjustmentsFromAssistant(android.service.notification.INotificationListener,java.util.List)>
	<android.app.INotificationManager$Stub$Proxy: void applyEnqueuedAdjustmentFromAssistant(android.service.notification.INotificationListener,android.service.notification.Adjustment)>
	<android.app.INotificationManager$Stub$Proxy: void applyRestore([B,int)>
	<android.app.INotificationManager$Stub$Proxy: boolean areBubblesAllowed(java.lang.String)>
	<android.app.INotificationManager$Stub$Proxy: boolean areChannelsBypassingDnd()>
	<android.app.INotificationManager$Stub$Proxy: boolean areNotificationsEnabled(java.lang.String)>
	<android.app.INotificationManager$Stub$Proxy: boolean areNotificationsEnabledForPackage(java.lang.String,int)>
	<android.app.INotificationManager$Stub$Proxy: android.os.IBinder asBinder()>
	<android.app.INotificationManager$Stub$Proxy: boolean canNotifyAsPackage(java.lang.String,java.lang.String,int)>
	<android.app.INotificationManager$Stub$Proxy: boolean canShowBadge(java.lang.String,int)>
	<android.app.INotificationManager$Stub$Proxy: void cancelAllNotifications(java.lang.String,int)>
	<android.app.INotificationManager$Stub$Proxy: void cancelNotificationFromListener(android.service.notification.INotificationListener,java.lang.String,java.lang.String,int)>
	<android.app.INotificationManager$Stub$Proxy: void cancelNotificationWithTag(java.lang.String,java.lang.String,java.lang.String,int,int)>
	<android.app.INotificationManager$Stub$Proxy: void cancelNotificationsFromListener(android.service.notification.INotificationListener,[Ljava.lang.String;)>
	<android.app.INotificationManager$Stub$Proxy: void cancelToast(java.lang.String,android.os.IBinder)>
	<android.app.INotificationManager$Stub$Proxy: void clearData(java.lang.String,int,boolean)>
	<android.app.INotificationManager$Stub$Proxy: void clearRequestedListenerHints(android.service.notification.INotificationListener)>
	<android.app.INotificationManager$Stub$Proxy: void createConversationNotificationChannelForPackage(java.lang.String,int,java.lang.String,android.app.NotificationChannel,java.lang.String)>
	<android.app.INotificationManager$Stub$Proxy: void createNotificationChannelGroups(java.lang.String,android.content.pm.ParceledListSlice)>
	<android.app.INotificationManager$Stub$Proxy: void createNotificationChannels(java.lang.String,android.content.pm.ParceledListSlice)>
	<android.app.INotificationManager$Stub$Proxy: void createNotificationChannelsForPackage(java.lang.String,int,android.content.pm.ParceledListSlice)>
	<android.app.INotificationManager$Stub$Proxy: void deleteConversationNotificationChannels(java.lang.String,int,java.lang.String)>
	<android.app.INotificationManager$Stub$Proxy: void deleteNotificationChannel(java.lang.String,java.lang.String)>
	<android.app.INotificationManager$Stub$Proxy: void deleteNotificationChannelGroup(java.lang.String,java.lang.String)>
	<android.app.INotificationManager$Stub$Proxy: void deleteNotificationHistoryItem(java.lang.String,int,long)>
	<android.app.INotificationManager$Stub$Proxy: void disallowAssistantAdjustment(java.lang.String)>
	<android.app.INotificationManager$Stub$Proxy: void enqueueNotificationWithTag(java.lang.String,java.lang.String,java.lang.String,int,android.app.Notification,int)>
	<android.app.INotificationManager$Stub$Proxy: void enqueueTextToast(java.lang.String,android.os.IBinder,java.lang.CharSequence,int,int,android.app.ITransientNotificationCallback)>
	<android.app.INotificationManager$Stub$Proxy: void enqueueToast(java.lang.String,android.os.IBinder,android.app.ITransientNotification,int,int)>
	<android.app.INotificationManager$Stub$Proxy: void finishToken(java.lang.String,android.os.IBinder)>
	<android.app.INotificationManager$Stub$Proxy: [Landroid.service.notification.StatusBarNotification; getActiveNotifications(java.lang.String)>
	<android.app.INotificationManager$Stub$Proxy: android.content.pm.ParceledListSlice getActiveNotificationsFromListener(android.service.notification.INotificationListener,[Ljava.lang.String;,int)>
	<android.app.INotificationManager$Stub$Proxy: [Landroid.service.notification.StatusBarNotification; getActiveNotificationsWithAttribution(java.lang.String,java.lang.String)>
	<android.app.INotificationManager$Stub$Proxy: java.util.List getAllowedAssistantAdjustments(java.lang.String)>
	<android.app.INotificationManager$Stub$Proxy: android.content.ComponentName getAllowedNotificationAssistant()>
	<android.app.INotificationManager$Stub$Proxy: android.content.ComponentName getAllowedNotificationAssistantForUser(int)>
	<android.app.INotificationManager$Stub$Proxy: android.content.pm.ParceledListSlice getAppActiveNotifications(java.lang.String,int)>
	<android.app.INotificationManager$Stub$Proxy: int getAppsBypassingDndCount(int)>
	<android.app.INotificationManager$Stub$Proxy: android.app.AutomaticZenRule getAutomaticZenRule(java.lang.String)>
	<android.app.INotificationManager$Stub$Proxy: [B getBackupPayload(int)>
	<android.app.INotificationManager$Stub$Proxy: int getBlockedAppCount(int)>
	<android.app.INotificationManager$Stub$Proxy: int getBlockedChannelCount(java.lang.String,int)>
	<android.app.INotificationManager$Stub$Proxy: int getBubblePreferenceForPackage(java.lang.String,int)>
	<android.app.INotificationManager$Stub$Proxy: android.app.NotificationManager$Policy getConsolidatedNotificationPolicy()>
	<android.app.INotificationManager$Stub$Proxy: android.app.NotificationChannel getConversationNotificationChannel(java.lang.String,int,java.lang.String,java.lang.String,boolean,java.lang.String)>
	<android.app.INotificationManager$Stub$Proxy: android.content.pm.ParceledListSlice getConversations(boolean)>
	<android.app.INotificationManager$Stub$Proxy: android.content.pm.ParceledListSlice getConversationsForPackage(java.lang.String,int)>
	<android.app.INotificationManager$Stub$Proxy: int getDeletedChannelCount(java.lang.String,int)>
	<android.app.INotificationManager$Stub$Proxy: android.content.ComponentName getEffectsSuppressor()>
	<android.app.INotificationManager$Stub$Proxy: java.util.List getEnabledNotificationListenerPackages()>
	<android.app.INotificationManager$Stub$Proxy: java.util.List getEnabledNotificationListeners(int)>
	<android.app.INotificationManager$Stub$Proxy: int getHintsFromListener(android.service.notification.INotificationListener)>
	<android.app.INotificationManager$Stub$Proxy: [Landroid.service.notification.StatusBarNotification; getHistoricalNotifications(java.lang.String,int,boolean)>
	<android.app.INotificationManager$Stub$Proxy: [Landroid.service.notification.StatusBarNotification; getHistoricalNotificationsWithAttribution(java.lang.String,java.lang.String,int,boolean)>
	<android.app.INotificationManager$Stub$Proxy: java.lang.String getInterfaceDescriptor()>
	<android.app.INotificationManager$Stub$Proxy: int getInterruptionFilterFromListener(android.service.notification.INotificationListener)>
	<android.app.INotificationManager$Stub$Proxy: android.app.NotificationChannel getNotificationChannel(java.lang.String,int,java.lang.String,java.lang.String)>
	<android.app.INotificationManager$Stub$Proxy: android.app.NotificationChannel getNotificationChannelForPackage(java.lang.String,int,java.lang.String,java.lang.String,boolean)>
	<android.app.INotificationManager$Stub$Proxy: android.app.NotificationChannelGroup getNotificationChannelGroup(java.lang.String,java.lang.String)>
	<android.app.INotificationManager$Stub$Proxy: android.app.NotificationChannelGroup getNotificationChannelGroupForPackage(java.lang.String,java.lang.String,int)>
	<android.app.INotificationManager$Stub$Proxy: android.content.pm.ParceledListSlice getNotificationChannelGroups(java.lang.String)>
	<android.app.INotificationManager$Stub$Proxy: android.content.pm.ParceledListSlice getNotificationChannelGroupsForPackage(java.lang.String,int,boolean)>
	<android.app.INotificationManager$Stub$Proxy: android.content.pm.ParceledListSlice getNotificationChannelGroupsFromPrivilegedListener(android.service.notification.INotificationListener,java.lang.String,android.os.UserHandle)>
	<android.app.INotificationManager$Stub$Proxy: android.content.pm.ParceledListSlice getNotificationChannels(java.lang.String,java.lang.String,int)>
	<android.app.INotificationManager$Stub$Proxy: android.content.pm.ParceledListSlice getNotificationChannelsBypassingDnd(java.lang.String,int)>
	<android.app.INotificationManager$Stub$Proxy: android.content.pm.ParceledListSlice getNotificationChannelsForPackage(java.lang.String,int,boolean)>
	<android.app.INotificationManager$Stub$Proxy: android.content.pm.ParceledListSlice getNotificationChannelsFromPrivilegedListener(android.service.notification.INotificationListener,java.lang.String,android.os.UserHandle)>
	<android.app.INotificationManager$Stub$Proxy: java.lang.String getNotificationDelegate(java.lang.String)>
	<android.app.INotificationManager$Stub$Proxy: android.app.NotificationHistory getNotificationHistory(java.lang.String,java.lang.String)>
	<android.app.INotificationManager$Stub$Proxy: android.app.NotificationManager$Policy getNotificationPolicy(java.lang.String)>
	<android.app.INotificationManager$Stub$Proxy: int getNumNotificationChannelsForPackage(java.lang.String,int,boolean)>
	<android.app.INotificationManager$Stub$Proxy: int getPackageImportance(java.lang.String)>
	<android.app.INotificationManager$Stub$Proxy: android.app.NotificationChannelGroup getPopulatedNotificationChannelGroupForPackage(java.lang.String,int,java.lang.String,boolean)>
	<android.app.INotificationManager$Stub$Proxy: boolean getPrivateNotificationsAllowed()>
	<android.app.INotificationManager$Stub$Proxy: int getRuleInstanceCount(android.content.ComponentName)>
	<android.app.INotificationManager$Stub$Proxy: android.content.pm.ParceledListSlice getSnoozedNotificationsFromListener(android.service.notification.INotificationListener,int)>
	<android.app.INotificationManager$Stub$Proxy: int getZenMode()>
	<android.app.INotificationManager$Stub$Proxy: android.service.notification.ZenModeConfig getZenModeConfig()>
	<android.app.INotificationManager$Stub$Proxy: java.util.List getZenRules()>
	<android.app.INotificationManager$Stub$Proxy: boolean hasSentValidMsg(java.lang.String,int)>
	<android.app.INotificationManager$Stub$Proxy: boolean hasUserDemotedInvalidMsgApp(java.lang.String,int)>
	<android.app.INotificationManager$Stub$Proxy: boolean isInInvalidMsgState(java.lang.String,int)>
	<android.app.INotificationManager$Stub$Proxy: boolean isNotificationAssistantAccessGranted(android.content.ComponentName)>
	<android.app.INotificationManager$Stub$Proxy: boolean isNotificationListenerAccessGranted(android.content.ComponentName)>
	<android.app.INotificationManager$Stub$Proxy: boolean isNotificationListenerAccessGrantedForUser(android.content.ComponentName,int)>
	<android.app.INotificationManager$Stub$Proxy: boolean isNotificationPolicyAccessGranted(java.lang.String)>
	<android.app.INotificationManager$Stub$Proxy: boolean isNotificationPolicyAccessGrantedForPackage(java.lang.String)>
	<android.app.INotificationManager$Stub$Proxy: boolean isPackagePaused(java.lang.String)>
	<android.app.INotificationManager$Stub$Proxy: boolean isSystemConditionProviderEnabled(java.lang.String)>
	<android.app.INotificationManager$Stub$Proxy: boolean matchesCallFilter(android.os.Bundle)>
	<android.app.INotificationManager$Stub$Proxy: void notifyConditions(java.lang.String,android.service.notification.IConditionProvider,[Landroid.service.notification.Condition;)>
	<android.app.INotificationManager$Stub$Proxy: boolean onlyHasDefaultChannel(java.lang.String,int)>
	<android.app.INotificationManager$Stub$Proxy: long pullStats(long,int,boolean,java.util.List)>
	<android.app.INotificationManager$Stub$Proxy: void registerListener(android.service.notification.INotificationListener,android.content.ComponentName,int)>
	<android.app.INotificationManager$Stub$Proxy: boolean removeAutomaticZenRule(java.lang.String)>
	<android.app.INotificationManager$Stub$Proxy: boolean removeAutomaticZenRules(java.lang.String)>
	<android.app.INotificationManager$Stub$Proxy: void requestBindListener(android.content.ComponentName)>
	<android.app.INotificationManager$Stub$Proxy: void requestBindProvider(android.content.ComponentName)>
	<android.app.INotificationManager$Stub$Proxy: void requestHintsFromListener(android.service.notification.INotificationListener,int)>
	<android.app.INotificationManager$Stub$Proxy: void requestInterruptionFilterFromListener(android.service.notification.INotificationListener,int)>
	<android.app.INotificationManager$Stub$Proxy: void requestUnbindListener(android.service.notification.INotificationListener)>
	<android.app.INotificationManager$Stub$Proxy: void requestUnbindProvider(android.service.notification.IConditionProvider)>
	<android.app.INotificationManager$Stub$Proxy: void setAutomaticZenRuleState(java.lang.String,android.service.notification.Condition)>
	<android.app.INotificationManager$Stub$Proxy: void setBubblesAllowed(java.lang.String,int,int)>
	<android.app.INotificationManager$Stub$Proxy: void setHideSilentStatusIcons(boolean)>
	<android.app.INotificationManager$Stub$Proxy: void setInterruptionFilter(java.lang.String,int)>
	<android.app.INotificationManager$Stub$Proxy: void setInvalidMsgAppDemoted(java.lang.String,int,boolean)>
	<android.app.INotificationManager$Stub$Proxy: void setNotificationAssistantAccessGranted(android.content.ComponentName,boolean)>
	<android.app.INotificationManager$Stub$Proxy: void setNotificationAssistantAccessGrantedForUser(android.content.ComponentName,int,boolean)>
	<android.app.INotificationManager$Stub$Proxy: void setNotificationDelegate(java.lang.String,java.lang.String)>
	<android.app.INotificationManager$Stub$Proxy: void setNotificationListenerAccessGranted(android.content.ComponentName,boolean)>
	<android.app.INotificationManager$Stub$Proxy: void setNotificationListenerAccessGrantedForUser(android.content.ComponentName,int,boolean)>
	<android.app.INotificationManager$Stub$Proxy: void setNotificationPolicy(java.lang.String,android.app.NotificationManager$Policy)>
	<android.app.INotificationManager$Stub$Proxy: void setNotificationPolicyAccessGranted(java.lang.String,boolean)>
	<android.app.INotificationManager$Stub$Proxy: void setNotificationPolicyAccessGrantedForUser(java.lang.String,int,boolean)>
	<android.app.INotificationManager$Stub$Proxy: void setNotificationsEnabledForPackage(java.lang.String,int,boolean)>
	<android.app.INotificationManager$Stub$Proxy: void setNotificationsEnabledWithImportanceLockForPackage(java.lang.String,int,boolean)>
	<android.app.INotificationManager$Stub$Proxy: void setNotificationsShownFromListener(android.service.notification.INotificationListener,[Ljava.lang.String;)>
	<android.app.INotificationManager$Stub$Proxy: void setOnNotificationPostedTrimFromListener(android.service.notification.INotificationListener,int)>
	<android.app.INotificationManager$Stub$Proxy: void setPrivateNotificationsAllowed(boolean)>
	<android.app.INotificationManager$Stub$Proxy: void setShowBadge(java.lang.String,int,boolean)>
	<android.app.INotificationManager$Stub$Proxy: void setZenMode(int,android.net.Uri,java.lang.String)>
	<android.app.INotificationManager$Stub$Proxy: boolean shouldHideSilentStatusIcons(java.lang.String)>
	<android.app.INotificationManager$Stub$Proxy: void silenceNotificationSound()>
	<android.app.INotificationManager$Stub$Proxy: void snoozeNotificationUntilContextFromListener(android.service.notification.INotificationListener,java.lang.String,java.lang.String)>
	<android.app.INotificationManager$Stub$Proxy: void snoozeNotificationUntilFromListener(android.service.notification.INotificationListener,java.lang.String,long)>
	<android.app.INotificationManager$Stub$Proxy: void unregisterListener(android.service.notification.INotificationListener,int)>
	<android.app.INotificationManager$Stub$Proxy: void unsnoozeNotificationFromAssistant(android.service.notification.INotificationListener,java.lang.String)>
	<android.app.INotificationManager$Stub$Proxy: void unsnoozeNotificationFromSystemListener(android.service.notification.INotificationListener,java.lang.String)>
	<android.app.INotificationManager$Stub$Proxy: boolean updateAutomaticZenRule(java.lang.String,android.app.AutomaticZenRule)>
	<android.app.INotificationManager$Stub$Proxy: void updateNotificationChannelForPackage(java.lang.String,int,android.app.NotificationChannel)>
	<android.app.INotificationManager$Stub$Proxy: void updateNotificationChannelFromPrivilegedListener(android.service.notification.INotificationListener,java.lang.String,android.os.UserHandle,android.app.NotificationChannel)>
	<android.app.INotificationManager$Stub$Proxy: void updateNotificationChannelGroupForPackage(java.lang.String,int,android.app.NotificationChannelGroup)>
	<android.app.INotificationManager$Stub$Proxy: void updateNotificationChannelGroupFromPrivilegedListener(android.service.notification.INotificationListener,java.lang.String,android.os.UserHandle,android.app.NotificationChannelGroup)>

Name: oem_lock
StubClassName: null
isAvaliable: false
Methods : 0 

Name: otadexopt
StubClassName: null
isAvaliable: false
Methods : 0 

Name: overlay
StubClassName: null
isAvaliable: false
Methods : 0 

Name: package
StubClassName: android.content.pm.IPackageManager
isAvaliable: true
Methods : 197 
	<android.content.pm.IPackageManager$Stub$Proxy: void lambda$notifyDexLoad$0(android.os.Parcel,java.lang.String,java.lang.String)>
	<android.content.pm.IPackageManager$Stub$Proxy: boolean activitySupportsIntent(android.content.ComponentName,android.content.Intent,java.lang.String)>
	<android.content.pm.IPackageManager$Stub$Proxy: void addCrossProfileIntentFilter(android.content.IntentFilter,java.lang.String,int,int,int)>
	<android.content.pm.IPackageManager$Stub$Proxy: boolean addPermission(android.content.pm.PermissionInfo)>
	<android.content.pm.IPackageManager$Stub$Proxy: boolean addPermissionAsync(android.content.pm.PermissionInfo)>
	<android.content.pm.IPackageManager$Stub$Proxy: void addPersistentPreferredActivity(android.content.IntentFilter,android.content.ComponentName,int)>
	<android.content.pm.IPackageManager$Stub$Proxy: void addPreferredActivity(android.content.IntentFilter,int,[Landroid.content.ComponentName;,android.content.ComponentName,int)>
	<android.content.pm.IPackageManager$Stub$Proxy: android.os.IBinder asBinder()>
	<android.content.pm.IPackageManager$Stub$Proxy: boolean canForwardTo(android.content.Intent,java.lang.String,int,int)>
	<android.content.pm.IPackageManager$Stub$Proxy: boolean canRequestPackageInstalls(java.lang.String,int)>
	<android.content.pm.IPackageManager$Stub$Proxy: [Ljava.lang.String; canonicalToCurrentPackageNames([Ljava.lang.String;)>
	<android.content.pm.IPackageManager$Stub$Proxy: void checkPackageStartable(java.lang.String,int)>
	<android.content.pm.IPackageManager$Stub$Proxy: int checkPermission(java.lang.String,java.lang.String,int)>
	<android.content.pm.IPackageManager$Stub$Proxy: int checkSignatures(java.lang.String,java.lang.String)>
	<android.content.pm.IPackageManager$Stub$Proxy: int checkUidPermission(java.lang.String,int)>
	<android.content.pm.IPackageManager$Stub$Proxy: int checkUidSignatures(int,int)>
	<android.content.pm.IPackageManager$Stub$Proxy: void clearApplicationProfileData(java.lang.String)>
	<android.content.pm.IPackageManager$Stub$Proxy: void clearApplicationUserData(java.lang.String,android.content.pm.IPackageDataObserver,int)>
	<android.content.pm.IPackageManager$Stub$Proxy: void clearCrossProfileIntentFilters(int,java.lang.String)>
	<android.content.pm.IPackageManager$Stub$Proxy: void clearPackagePersistentPreferredActivities(java.lang.String,int)>
	<android.content.pm.IPackageManager$Stub$Proxy: void clearPackagePreferredActivities(java.lang.String)>
	<android.content.pm.IPackageManager$Stub$Proxy: boolean compileLayouts(java.lang.String)>
	<android.content.pm.IPackageManager$Stub$Proxy: [Ljava.lang.String; currentToCanonicalPackageNames([Ljava.lang.String;)>
	<android.content.pm.IPackageManager$Stub$Proxy: void deleteApplicationCacheFiles(java.lang.String,android.content.pm.IPackageDataObserver)>
	<android.content.pm.IPackageManager$Stub$Proxy: void deleteApplicationCacheFilesAsUser(java.lang.String,int,android.content.pm.IPackageDataObserver)>
	<android.content.pm.IPackageManager$Stub$Proxy: void deleteExistingPackageAsUser(android.content.pm.VersionedPackage,android.content.pm.IPackageDeleteObserver2,int)>
	<android.content.pm.IPackageManager$Stub$Proxy: void deletePackageAsUser(java.lang.String,int,android.content.pm.IPackageDeleteObserver,int,int)>
	<android.content.pm.IPackageManager$Stub$Proxy: void deletePackageVersioned(android.content.pm.VersionedPackage,android.content.pm.IPackageDeleteObserver2,int,int)>
	<android.content.pm.IPackageManager$Stub$Proxy: void deletePreloadsFileCache()>
	<android.content.pm.IPackageManager$Stub$Proxy: void dumpProfiles(java.lang.String)>
	<android.content.pm.IPackageManager$Stub$Proxy: void enterSafeMode()>
	<android.content.pm.IPackageManager$Stub$Proxy: void extendVerificationTimeout(int,int,long)>
	<android.content.pm.IPackageManager$Stub$Proxy: android.content.pm.ResolveInfo findPersistentPreferredActivity(android.content.Intent,int)>
	<android.content.pm.IPackageManager$Stub$Proxy: void finishPackageInstall(int,boolean)>
	<android.content.pm.IPackageManager$Stub$Proxy: void flushPackageRestrictionsAsUser(int)>
	<android.content.pm.IPackageManager$Stub$Proxy: void forceDexOpt(java.lang.String)>
	<android.content.pm.IPackageManager$Stub$Proxy: void freeStorage(java.lang.String,long,int,android.content.IntentSender)>
	<android.content.pm.IPackageManager$Stub$Proxy: void freeStorageAndNotify(java.lang.String,long,int,android.content.pm.IPackageDataObserver)>
	<android.content.pm.IPackageManager$Stub$Proxy: android.content.pm.ActivityInfo getActivityInfo(android.content.ComponentName,int,int)>
	<android.content.pm.IPackageManager$Stub$Proxy: android.content.pm.ParceledListSlice getAllIntentFilters(java.lang.String)>
	<android.content.pm.IPackageManager$Stub$Proxy: java.util.List getAllPackages()>
	<android.content.pm.IPackageManager$Stub$Proxy: [Ljava.lang.String; getAppOpPermissionPackages(java.lang.String)>
	<android.content.pm.IPackageManager$Stub$Proxy: java.lang.String getAppPredictionServicePackageName()>
	<android.content.pm.IPackageManager$Stub$Proxy: int getApplicationEnabledSetting(java.lang.String,int)>
	<android.content.pm.IPackageManager$Stub$Proxy: boolean getApplicationHiddenSettingAsUser(java.lang.String,int)>
	<android.content.pm.IPackageManager$Stub$Proxy: android.content.pm.ApplicationInfo getApplicationInfo(java.lang.String,int,int)>
	<android.content.pm.IPackageManager$Stub$Proxy: android.content.pm.dex.IArtManager getArtManager()>
	<android.content.pm.IPackageManager$Stub$Proxy: java.lang.String getAttentionServicePackageName()>
	<android.content.pm.IPackageManager$Stub$Proxy: boolean getBlockUninstallForUser(java.lang.String,int)>
	<android.content.pm.IPackageManager$Stub$Proxy: android.content.pm.ChangedPackages getChangedPackages(int,int)>
	<android.content.pm.IPackageManager$Stub$Proxy: int getComponentEnabledSetting(android.content.ComponentName,int)>
	<android.content.pm.IPackageManager$Stub$Proxy: java.lang.String getContentCaptureServicePackageName()>
	<android.content.pm.IPackageManager$Stub$Proxy: android.content.pm.ParceledListSlice getDeclaredSharedLibraries(java.lang.String,int,int)>
	<android.content.pm.IPackageManager$Stub$Proxy: [B getDefaultAppsBackup(int)>
	<android.content.pm.IPackageManager$Stub$Proxy: java.lang.String getDefaultTextClassifierPackageName()>
	<android.content.pm.IPackageManager$Stub$Proxy: int getFlagsForUid(int)>
	<android.content.pm.IPackageManager$Stub$Proxy: java.lang.CharSequence getHarmfulAppWarning(java.lang.String,int)>
	<android.content.pm.IPackageManager$Stub$Proxy: android.content.ComponentName getHomeActivities(java.util.List)>
	<android.content.pm.IPackageManager$Stub$Proxy: java.lang.String getIncidentReportApproverPackageName()>
	<android.content.pm.IPackageManager$Stub$Proxy: int getInstallLocation()>
	<android.content.pm.IPackageManager$Stub$Proxy: int getInstallReason(java.lang.String,int)>
	<android.content.pm.IPackageManager$Stub$Proxy: android.content.pm.InstallSourceInfo getInstallSourceInfo(java.lang.String)>
	<android.content.pm.IPackageManager$Stub$Proxy: android.content.pm.ParceledListSlice getInstalledApplications(int,int)>
	<android.content.pm.IPackageManager$Stub$Proxy: java.util.List getInstalledModules(int)>
	<android.content.pm.IPackageManager$Stub$Proxy: android.content.pm.ParceledListSlice getInstalledPackages(int,int)>
	<android.content.pm.IPackageManager$Stub$Proxy: java.lang.String getInstallerPackageName(java.lang.String)>
	<android.content.pm.IPackageManager$Stub$Proxy: java.lang.String getInstantAppAndroidId(java.lang.String,int)>
	<android.content.pm.IPackageManager$Stub$Proxy: [B getInstantAppCookie(java.lang.String,int)>
	<android.content.pm.IPackageManager$Stub$Proxy: android.graphics.Bitmap getInstantAppIcon(java.lang.String,int)>
	<android.content.pm.IPackageManager$Stub$Proxy: android.content.ComponentName getInstantAppInstallerComponent()>
	<android.content.pm.IPackageManager$Stub$Proxy: android.content.ComponentName getInstantAppResolverComponent()>
	<android.content.pm.IPackageManager$Stub$Proxy: android.content.ComponentName getInstantAppResolverSettingsComponent()>
	<android.content.pm.IPackageManager$Stub$Proxy: android.content.pm.ParceledListSlice getInstantApps(int)>
	<android.content.pm.IPackageManager$Stub$Proxy: android.content.pm.InstrumentationInfo getInstrumentationInfo(android.content.ComponentName,int)>
	<android.content.pm.IPackageManager$Stub$Proxy: [B getIntentFilterVerificationBackup(int)>
	<android.content.pm.IPackageManager$Stub$Proxy: android.content.pm.ParceledListSlice getIntentFilterVerifications(java.lang.String)>
	<android.content.pm.IPackageManager$Stub$Proxy: int getIntentVerificationStatus(java.lang.String,int)>
	<android.content.pm.IPackageManager$Stub$Proxy: java.lang.String getInterfaceDescriptor()>
	<android.content.pm.IPackageManager$Stub$Proxy: android.content.pm.KeySet getKeySetByAlias(java.lang.String,java.lang.String)>
	<android.content.pm.IPackageManager$Stub$Proxy: android.content.pm.ResolveInfo getLastChosenActivity(android.content.Intent,java.lang.String,int)>
	<android.content.pm.IPackageManager$Stub$Proxy: java.util.List getMimeGroup(java.lang.String,java.lang.String)>
	<android.content.pm.IPackageManager$Stub$Proxy: android.content.pm.ModuleInfo getModuleInfo(java.lang.String,int)>
	<android.content.pm.IPackageManager$Stub$Proxy: int getMoveStatus(int)>
	<android.content.pm.IPackageManager$Stub$Proxy: java.lang.String getNameForUid(int)>
	<android.content.pm.IPackageManager$Stub$Proxy: [Ljava.lang.String; getNamesForUids([I)>
	<android.content.pm.IPackageManager$Stub$Proxy: [I getPackageGids(java.lang.String,int,int)>
	<android.content.pm.IPackageManager$Stub$Proxy: android.content.pm.PackageInfo getPackageInfo(java.lang.String,int,int)>
	<android.content.pm.IPackageManager$Stub$Proxy: android.content.pm.PackageInfo getPackageInfoVersioned(android.content.pm.VersionedPackage,int,int)>
	<android.content.pm.IPackageManager$Stub$Proxy: android.content.pm.IPackageInstaller getPackageInstaller()>
	<android.content.pm.IPackageManager$Stub$Proxy: void getPackageSizeInfo(java.lang.String,int,android.content.pm.IPackageStatsObserver)>
	<android.content.pm.IPackageManager$Stub$Proxy: int getPackageUid(java.lang.String,int,int)>
	<android.content.pm.IPackageManager$Stub$Proxy: [Ljava.lang.String; getPackagesForUid(int)>
	<android.content.pm.IPackageManager$Stub$Proxy: android.content.pm.ParceledListSlice getPackagesHoldingPermissions([Ljava.lang.String;,int,int)>
	<android.content.pm.IPackageManager$Stub$Proxy: java.lang.String getPermissionControllerPackageName()>
	<android.content.pm.IPackageManager$Stub$Proxy: android.content.pm.PermissionGroupInfo getPermissionGroupInfo(java.lang.String,int)>
	<android.content.pm.IPackageManager$Stub$Proxy: android.content.pm.ParceledListSlice getPersistentApplications(int)>
	<android.content.pm.IPackageManager$Stub$Proxy: int getPreferredActivities(java.util.List,java.util.List,java.lang.String)>
	<android.content.pm.IPackageManager$Stub$Proxy: [B getPreferredActivityBackup(int)>
	<android.content.pm.IPackageManager$Stub$Proxy: int getPrivateFlagsForUid(int)>
	<android.content.pm.IPackageManager$Stub$Proxy: android.content.pm.ProviderInfo getProviderInfo(android.content.ComponentName,int,int)>
	<android.content.pm.IPackageManager$Stub$Proxy: android.content.pm.ActivityInfo getReceiverInfo(android.content.ComponentName,int,int)>
	<android.content.pm.IPackageManager$Stub$Proxy: int getRuntimePermissionsVersion(int)>
	<android.content.pm.IPackageManager$Stub$Proxy: android.content.pm.ServiceInfo getServiceInfo(android.content.ComponentName,int,int)>
	<android.content.pm.IPackageManager$Stub$Proxy: java.lang.String getServicesSystemSharedLibraryPackageName()>
	<android.content.pm.IPackageManager$Stub$Proxy: java.lang.String getSetupWizardPackageName()>
	<android.content.pm.IPackageManager$Stub$Proxy: android.content.pm.ParceledListSlice getSharedLibraries(java.lang.String,int,int)>
	<android.content.pm.IPackageManager$Stub$Proxy: java.lang.String getSharedSystemSharedLibraryPackageName()>
	<android.content.pm.IPackageManager$Stub$Proxy: android.content.pm.KeySet getSigningKeySet(java.lang.String)>
	<android.content.pm.IPackageManager$Stub$Proxy: android.os.Bundle getSuspendedPackageAppExtras(java.lang.String,int)>
	<android.content.pm.IPackageManager$Stub$Proxy: android.content.pm.ParceledListSlice getSystemAvailableFeatures()>
	<android.content.pm.IPackageManager$Stub$Proxy: java.lang.String getSystemCaptionsServicePackageName()>
	<android.content.pm.IPackageManager$Stub$Proxy: [Ljava.lang.String; getSystemSharedLibraryNames()>
	<android.content.pm.IPackageManager$Stub$Proxy: java.lang.String getSystemTextClassifierPackageName()>
	<android.content.pm.IPackageManager$Stub$Proxy: int getUidForSharedUser(java.lang.String)>
	<android.content.pm.IPackageManager$Stub$Proxy: [Ljava.lang.String; getUnsuspendablePackagesForUser([Ljava.lang.String;,int)>
	<android.content.pm.IPackageManager$Stub$Proxy: android.content.pm.VerifierDeviceIdentity getVerifierDeviceIdentity()>
	<android.content.pm.IPackageManager$Stub$Proxy: java.lang.String getWellbeingPackageName()>
	<android.content.pm.IPackageManager$Stub$Proxy: void grantRuntimePermission(java.lang.String,java.lang.String,int)>
	<android.content.pm.IPackageManager$Stub$Proxy: boolean hasSigningCertificate(java.lang.String,[B,int)>
	<android.content.pm.IPackageManager$Stub$Proxy: boolean hasSystemFeature(java.lang.String,int)>
	<android.content.pm.IPackageManager$Stub$Proxy: boolean hasSystemUidErrors()>
	<android.content.pm.IPackageManager$Stub$Proxy: boolean hasUidSigningCertificate(int,[B,int)>
	<android.content.pm.IPackageManager$Stub$Proxy: int installExistingPackageAsUser(java.lang.String,int,int,int,java.util.List)>
	<android.content.pm.IPackageManager$Stub$Proxy: boolean isAutoRevokeWhitelisted(java.lang.String)>
	<android.content.pm.IPackageManager$Stub$Proxy: boolean isDeviceUpgrading()>
	<android.content.pm.IPackageManager$Stub$Proxy: boolean isFirstBoot()>
	<android.content.pm.IPackageManager$Stub$Proxy: boolean isInstantApp(java.lang.String,int)>
	<android.content.pm.IPackageManager$Stub$Proxy: boolean isOnlyCoreApps()>
	<android.content.pm.IPackageManager$Stub$Proxy: boolean isPackageAvailable(java.lang.String,int)>
	<android.content.pm.IPackageManager$Stub$Proxy: boolean isPackageDeviceAdminOnAnyUser(java.lang.String)>
	<android.content.pm.IPackageManager$Stub$Proxy: boolean isPackageSignedByKeySet(java.lang.String,android.content.pm.KeySet)>
	<android.content.pm.IPackageManager$Stub$Proxy: boolean isPackageSignedByKeySetExactly(java.lang.String,android.content.pm.KeySet)>
	<android.content.pm.IPackageManager$Stub$Proxy: boolean isPackageStateProtected(java.lang.String,int)>
	<android.content.pm.IPackageManager$Stub$Proxy: boolean isPackageSuspendedForUser(java.lang.String,int)>
	<android.content.pm.IPackageManager$Stub$Proxy: boolean isProtectedBroadcast(java.lang.String)>
	<android.content.pm.IPackageManager$Stub$Proxy: boolean isSafeMode()>
	<android.content.pm.IPackageManager$Stub$Proxy: boolean isStorageLow()>
	<android.content.pm.IPackageManager$Stub$Proxy: boolean isUidPrivileged(int)>
	<android.content.pm.IPackageManager$Stub$Proxy: void logAppProcessStartIfNeeded(java.lang.String,int,java.lang.String,java.lang.String,int)>
	<android.content.pm.IPackageManager$Stub$Proxy: int movePackage(java.lang.String,java.lang.String)>
	<android.content.pm.IPackageManager$Stub$Proxy: int movePrimaryStorage(java.lang.String)>
	<android.content.pm.IPackageManager$Stub$Proxy: void notifyDexLoad(java.lang.String,java.util.Map,java.lang.String)>
	<android.content.pm.IPackageManager$Stub$Proxy: void notifyPackageUse(java.lang.String,int)>
	<android.content.pm.IPackageManager$Stub$Proxy: void notifyPackagesReplacedReceived([Ljava.lang.String;)>
	<android.content.pm.IPackageManager$Stub$Proxy: void overrideLabelAndIcon(android.content.ComponentName,java.lang.String,int,int)>
	<android.content.pm.IPackageManager$Stub$Proxy: boolean performDexOptMode(java.lang.String,boolean,java.lang.String,boolean,boolean,java.lang.String)>
	<android.content.pm.IPackageManager$Stub$Proxy: boolean performDexOptSecondary(java.lang.String,java.lang.String,boolean)>
	<android.content.pm.IPackageManager$Stub$Proxy: void performFstrimIfNeeded()>
	<android.content.pm.IPackageManager$Stub$Proxy: android.content.pm.ParceledListSlice queryContentProviders(java.lang.String,int,int,java.lang.String)>
	<android.content.pm.IPackageManager$Stub$Proxy: android.content.pm.ParceledListSlice queryInstrumentation(java.lang.String,int)>
	<android.content.pm.IPackageManager$Stub$Proxy: android.content.pm.ParceledListSlice queryIntentActivities(android.content.Intent,java.lang.String,int,int)>
	<android.content.pm.IPackageManager$Stub$Proxy: android.content.pm.ParceledListSlice queryIntentActivityOptions(android.content.ComponentName,[Landroid.content.Intent;,[Ljava.lang.String;,android.content.Intent,java.lang.String,int,int)>
	<android.content.pm.IPackageManager$Stub$Proxy: android.content.pm.ParceledListSlice queryIntentContentProviders(android.content.Intent,java.lang.String,int,int)>
	<android.content.pm.IPackageManager$Stub$Proxy: android.content.pm.ParceledListSlice queryIntentReceivers(android.content.Intent,java.lang.String,int,int)>
	<android.content.pm.IPackageManager$Stub$Proxy: android.content.pm.ParceledListSlice queryIntentServices(android.content.Intent,java.lang.String,int,int)>
	<android.content.pm.IPackageManager$Stub$Proxy: void querySyncProviders(java.util.List,java.util.List)>
	<android.content.pm.IPackageManager$Stub$Proxy: void reconcileSecondaryDexFiles(java.lang.String)>
	<android.content.pm.IPackageManager$Stub$Proxy: void registerDexModule(java.lang.String,java.lang.String,boolean,android.content.pm.IDexModuleRegisterCallback)>
	<android.content.pm.IPackageManager$Stub$Proxy: void registerMoveCallback(android.content.pm.IPackageMoveObserver)>
	<android.content.pm.IPackageManager$Stub$Proxy: void removePermission(java.lang.String)>
	<android.content.pm.IPackageManager$Stub$Proxy: void replacePreferredActivity(android.content.IntentFilter,int,[Landroid.content.ComponentName;,android.content.ComponentName,int)>
	<android.content.pm.IPackageManager$Stub$Proxy: void resetApplicationPreferences(int)>
	<android.content.pm.IPackageManager$Stub$Proxy: android.content.pm.ProviderInfo resolveContentProvider(java.lang.String,int,int)>
	<android.content.pm.IPackageManager$Stub$Proxy: android.content.pm.ResolveInfo resolveIntent(android.content.Intent,java.lang.String,int,int)>
	<android.content.pm.IPackageManager$Stub$Proxy: android.content.pm.ResolveInfo resolveService(android.content.Intent,java.lang.String,int,int)>
	<android.content.pm.IPackageManager$Stub$Proxy: void restoreDefaultApps([B,int)>
	<android.content.pm.IPackageManager$Stub$Proxy: void restoreIntentFilterVerification([B,int)>
	<android.content.pm.IPackageManager$Stub$Proxy: void restoreLabelAndIcon(android.content.ComponentName,int)>
	<android.content.pm.IPackageManager$Stub$Proxy: void restorePreferredActivities([B,int)>
	<android.content.pm.IPackageManager$Stub$Proxy: boolean runBackgroundDexoptJob(java.util.List)>
	<android.content.pm.IPackageManager$Stub$Proxy: void sendDeviceCustomizationReadyBroadcast()>
	<android.content.pm.IPackageManager$Stub$Proxy: void setApplicationCategoryHint(java.lang.String,int,java.lang.String)>
	<android.content.pm.IPackageManager$Stub$Proxy: void setApplicationEnabledSetting(java.lang.String,int,int,int,java.lang.String)>
	<android.content.pm.IPackageManager$Stub$Proxy: boolean setApplicationHiddenSettingAsUser(java.lang.String,boolean,int)>
	<android.content.pm.IPackageManager$Stub$Proxy: boolean setBlockUninstallForUser(java.lang.String,boolean,int)>
	<android.content.pm.IPackageManager$Stub$Proxy: void setComponentEnabledSetting(android.content.ComponentName,int,int,int)>
	<android.content.pm.IPackageManager$Stub$Proxy: [Ljava.lang.String; setDistractingPackageRestrictionsAsUser([Ljava.lang.String;,int,int)>
	<android.content.pm.IPackageManager$Stub$Proxy: void setHarmfulAppWarning(java.lang.String,java.lang.CharSequence,int)>
	<android.content.pm.IPackageManager$Stub$Proxy: void setHomeActivity(android.content.ComponentName,int)>
	<android.content.pm.IPackageManager$Stub$Proxy: boolean setInstallLocation(int)>
	<android.content.pm.IPackageManager$Stub$Proxy: void setInstallerPackageName(java.lang.String,java.lang.String)>
	<android.content.pm.IPackageManager$Stub$Proxy: boolean setInstantAppCookie(java.lang.String,[B,int)>
	<android.content.pm.IPackageManager$Stub$Proxy: void setLastChosenActivity(android.content.Intent,java.lang.String,int,android.content.IntentFilter,int,android.content.ComponentName)>
	<android.content.pm.IPackageManager$Stub$Proxy: void setMimeGroup(java.lang.String,java.lang.String,java.util.List)>
	<android.content.pm.IPackageManager$Stub$Proxy: void setPackageStoppedState(java.lang.String,boolean,int)>
	<android.content.pm.IPackageManager$Stub$Proxy: [Ljava.lang.String; setPackagesSuspendedAsUser([Ljava.lang.String;,boolean,android.os.PersistableBundle,android.os.PersistableBundle,android.content.pm.SuspendDialogInfo,java.lang.String,int)>
	<android.content.pm.IPackageManager$Stub$Proxy: boolean setRequiredForSystemUser(java.lang.String,boolean)>
	<android.content.pm.IPackageManager$Stub$Proxy: void setRuntimePermissionsVersion(int,int)>
	<android.content.pm.IPackageManager$Stub$Proxy: void setSystemAppHiddenUntilInstalled(java.lang.String,boolean)>
	<android.content.pm.IPackageManager$Stub$Proxy: boolean setSystemAppInstallState(java.lang.String,boolean,int)>
	<android.content.pm.IPackageManager$Stub$Proxy: void setUpdateAvailable(java.lang.String,boolean)>
	<android.content.pm.IPackageManager$Stub$Proxy: void systemReady()>
	<android.content.pm.IPackageManager$Stub$Proxy: void unregisterMoveCallback(android.content.pm.IPackageMoveObserver)>
	<android.content.pm.IPackageManager$Stub$Proxy: boolean updateIntentVerificationStatus(java.lang.String,int,int)>
	<android.content.pm.IPackageManager$Stub$Proxy: void updatePackagesIfNeeded()>
	<android.content.pm.IPackageManager$Stub$Proxy: void verifyIntentFilter(int,int,java.util.List)>
	<android.content.pm.IPackageManager$Stub$Proxy: void verifyPendingInstall(int,int)>

Name: package_native
StubClassName: android.content.pm.IPackageManagerNative
isAvaliable: true
Methods : 12 
	<android.content.pm.IPackageManagerNative$Stub$Proxy: android.os.IBinder asBinder()>
	<android.content.pm.IPackageManagerNative$Stub$Proxy: [Ljava.lang.String; getAllPackages()>
	<android.content.pm.IPackageManagerNative$Stub$Proxy: java.lang.String getInstallerForPackage(java.lang.String)>
	<android.content.pm.IPackageManagerNative$Stub$Proxy: java.lang.String getInterfaceDescriptor()>
	<android.content.pm.IPackageManagerNative$Stub$Proxy: int getLocationFlags(java.lang.String)>
	<android.content.pm.IPackageManagerNative$Stub$Proxy: java.lang.String getModuleMetadataPackageName()>
	<android.content.pm.IPackageManagerNative$Stub$Proxy: [Ljava.lang.String; getNamesForUids([I)>
	<android.content.pm.IPackageManagerNative$Stub$Proxy: int getTargetSdkVersionForPackage(java.lang.String)>
	<android.content.pm.IPackageManagerNative$Stub$Proxy: long getVersionCodeForPackage(java.lang.String)>
	<android.content.pm.IPackageManagerNative$Stub$Proxy: [Z isAudioPlaybackCaptureAllowed([Ljava.lang.String;)>
	<android.content.pm.IPackageManagerNative$Stub$Proxy: void registerPackageChangeObserver(android.content.pm.IPackageChangeObserver)>
	<android.content.pm.IPackageManagerNative$Stub$Proxy: void unregisterPackageChangeObserver(android.content.pm.IPackageChangeObserver)>

Name: permission
StubClassName: android.os.IPermissionController
isAvaliable: true
Methods : 7 
	<android.os.IPermissionController$Stub$Proxy: android.os.IBinder asBinder()>
	<android.os.IPermissionController$Stub$Proxy: boolean checkPermission(java.lang.String,int,int)>
	<android.os.IPermissionController$Stub$Proxy: java.lang.String getInterfaceDescriptor()>
	<android.os.IPermissionController$Stub$Proxy: int getPackageUid(java.lang.String,int)>
	<android.os.IPermissionController$Stub$Proxy: [Ljava.lang.String; getPackagesForUid(int)>
	<android.os.IPermissionController$Stub$Proxy: boolean isRuntimePermission(java.lang.String)>
	<android.os.IPermissionController$Stub$Proxy: int noteOp(java.lang.String,int,java.lang.String)>

Name: permissionmgr
StubClassName: android.permission.IPermissionManager
isAvaliable: true
Methods : 42 
	<android.permission.IPermissionManager$Stub$Proxy: void addOnPermissionsChangeListener(android.permission.IOnPermissionsChangeListener)>
	<android.permission.IPermissionManager$Stub$Proxy: boolean addPermission(android.content.pm.PermissionInfo,boolean)>
	<android.permission.IPermissionManager$Stub$Proxy: boolean addWhitelistedRestrictedPermission(java.lang.String,java.lang.String,int,int)>
	<android.permission.IPermissionManager$Stub$Proxy: android.os.IBinder asBinder()>
	<android.permission.IPermissionManager$Stub$Proxy: int checkDeviceIdentifierAccess(java.lang.String,java.lang.String,java.lang.String,int,int)>
	<android.permission.IPermissionManager$Stub$Proxy: int checkPermission(java.lang.String,java.lang.String,int)>
	<android.permission.IPermissionManager$Stub$Proxy: int checkUidPermission(java.lang.String,int)>
	<android.permission.IPermissionManager$Stub$Proxy: android.content.pm.ParceledListSlice getAllPermissionGroups(int)>
	<android.permission.IPermissionManager$Stub$Proxy: [Ljava.lang.String; getAppOpPermissionPackages(java.lang.String)>
	<android.permission.IPermissionManager$Stub$Proxy: java.util.List getAutoRevokeExemptionGrantedPackages(int)>
	<android.permission.IPermissionManager$Stub$Proxy: java.util.List getAutoRevokeExemptionRequestedPackages(int)>
	<android.permission.IPermissionManager$Stub$Proxy: java.lang.String getDefaultBrowser(int)>
	<android.permission.IPermissionManager$Stub$Proxy: java.lang.String getInterfaceDescriptor()>
	<android.permission.IPermissionManager$Stub$Proxy: int getPermissionFlags(java.lang.String,java.lang.String,int)>
	<android.permission.IPermissionManager$Stub$Proxy: android.content.pm.PermissionGroupInfo getPermissionGroupInfo(java.lang.String,int)>
	<android.permission.IPermissionManager$Stub$Proxy: android.content.pm.PermissionInfo getPermissionInfo(java.lang.String,java.lang.String,int)>
	<android.permission.IPermissionManager$Stub$Proxy: java.util.List getSplitPermissions()>
	<android.permission.IPermissionManager$Stub$Proxy: java.util.List getWhitelistedRestrictedPermissions(java.lang.String,int,int)>
	<android.permission.IPermissionManager$Stub$Proxy: void grantDefaultPermissionsToActiveLuiApp(java.lang.String,int)>
	<android.permission.IPermissionManager$Stub$Proxy: void grantDefaultPermissionsToEnabledCarrierApps([Ljava.lang.String;,int)>
	<android.permission.IPermissionManager$Stub$Proxy: void grantDefaultPermissionsToEnabledImsServices([Ljava.lang.String;,int)>
	<android.permission.IPermissionManager$Stub$Proxy: void grantDefaultPermissionsToEnabledTelephonyDataServices([Ljava.lang.String;,int)>
	<android.permission.IPermissionManager$Stub$Proxy: void grantRuntimePermission(java.lang.String,java.lang.String,int)>
	<android.permission.IPermissionManager$Stub$Proxy: boolean isAutoRevokeWhitelisted(java.lang.String,int)>
	<android.permission.IPermissionManager$Stub$Proxy: boolean isPermissionEnforced(java.lang.String)>
	<android.permission.IPermissionManager$Stub$Proxy: boolean isPermissionRevokedByPolicy(java.lang.String,java.lang.String,int)>
	<android.permission.IPermissionManager$Stub$Proxy: android.content.pm.ParceledListSlice queryPermissionsByGroup(java.lang.String,int)>
	<android.permission.IPermissionManager$Stub$Proxy: void removeOnPermissionsChangeListener(android.permission.IOnPermissionsChangeListener)>
	<android.permission.IPermissionManager$Stub$Proxy: void removePermission(java.lang.String)>
	<android.permission.IPermissionManager$Stub$Proxy: boolean removeWhitelistedRestrictedPermission(java.lang.String,java.lang.String,int,int)>
	<android.permission.IPermissionManager$Stub$Proxy: void resetRuntimePermissions()>
	<android.permission.IPermissionManager$Stub$Proxy: void revokeDefaultPermissionsFromDisabledTelephonyDataServices([Ljava.lang.String;,int)>
	<android.permission.IPermissionManager$Stub$Proxy: void revokeDefaultPermissionsFromLuiApps([Ljava.lang.String;,int)>
	<android.permission.IPermissionManager$Stub$Proxy: void revokeRuntimePermission(java.lang.String,java.lang.String,int,java.lang.String)>
	<android.permission.IPermissionManager$Stub$Proxy: boolean setAutoRevokeWhitelisted(java.lang.String,boolean,int)>
	<android.permission.IPermissionManager$Stub$Proxy: boolean setDefaultBrowser(java.lang.String,int)>
	<android.permission.IPermissionManager$Stub$Proxy: void setPermissionEnforced(java.lang.String,boolean)>
	<android.permission.IPermissionManager$Stub$Proxy: boolean shouldShowRequestPermissionRationale(java.lang.String,java.lang.String,int)>
	<android.permission.IPermissionManager$Stub$Proxy: void startOneTimePermissionSession(java.lang.String,int,long,int,int)>
	<android.permission.IPermissionManager$Stub$Proxy: void stopOneTimePermissionSession(java.lang.String,int)>
	<android.permission.IPermissionManager$Stub$Proxy: void updatePermissionFlags(java.lang.String,java.lang.String,int,int,boolean,int)>
	<android.permission.IPermissionManager$Stub$Proxy: void updatePermissionFlagsForAllApps(int,int,int)>

Name: persistent_data_block
StubClassName: null
isAvaliable: false
Methods : 0 

Name: phone
StubClassName: com.android.internal.telephony.ITelephony
isAvaliable: true
Methods : 289 
	<com.android.internal.telephony.ITelephony$Stub$Proxy: android.os.IBinder asBinder()>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: void cacheMmTelCapabilityProvisioning(int,int,int,boolean)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: void call(java.lang.String,java.lang.String)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: boolean canChangeDtmfToneLength(int,java.lang.String,java.lang.String)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: boolean canConnectTo5GInDsdsMode()>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: void carrierActionReportDefaultNetworkStatus(int,boolean)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: void carrierActionResetAll(int)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: void carrierActionSetMeteredApnsEnabled(int,boolean)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: void carrierActionSetRadioEnabled(int,boolean)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: int changeIccLockPassword(int,java.lang.String,java.lang.String)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: int checkCarrierPrivilegesForPackage(int,java.lang.String)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: int checkCarrierPrivilegesForPackageAnyPhone(java.lang.String)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: void dial(java.lang.String)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: boolean disableDataConnectivity()>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: void disableIms(int)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: void disableLocationUpdates()>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: void disableLocationUpdatesForSubscriber(int)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: void disableVisualVoicemailSmsFilter(java.lang.String,int)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: boolean doesSwitchMultiSimConfigTriggerReboot(int,java.lang.String,java.lang.String)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: boolean enableDataConnectivity()>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: void enableIms(int)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: void enableLocationUpdates()>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: void enableLocationUpdatesForSubscriber(int)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: boolean enableModemForSlot(int,boolean)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: void enableVideoCalling(boolean)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: void enableVisualVoicemailSmsFilter(java.lang.String,int,android.telephony.VisualVoicemailSmsFilterSettings)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: void enqueueSmsPickResult(java.lang.String,java.lang.String,com.android.internal.telephony.IIntegerConsumer)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: void factoryReset(int)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: int getActivePhoneType()>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: int getActivePhoneTypeForSlot(int)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: android.telephony.VisualVoicemailSmsFilterSettings getActiveVisualVoicemailSmsFilterSettings(int)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: java.lang.String getAidForAppType(int,int)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: java.util.List getAllCellInfo(java.lang.String,java.lang.String)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: android.telephony.CarrierRestrictionRules getAllowedCarriers()>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: long getAllowedNetworkTypes(int)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: long getAllowedNetworkTypesForReason(int,int)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: java.lang.String getBoundImsServicePackage(int,boolean,int)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: int getCalculatedPreferredNetworkType(java.lang.String,java.lang.String)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: android.telephony.CallForwardingInfo getCallForwarding(int,int)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: int getCallState()>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: int getCallStateForSlot(int)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: int getCallWaitingStatus(int)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: int getCardIdForDefaultEuicc(int,java.lang.String)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: int getCarrierIdFromMccMnc(int,java.lang.String,boolean)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: int getCarrierIdListVersion(int)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: java.util.List getCarrierPackageNamesForIntentAndPhone(android.content.Intent,int)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: int getCarrierPrivilegeStatus(int)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: int getCarrierPrivilegeStatusForUid(int,int)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: int getCdmaEriIconIndex(java.lang.String,java.lang.String)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: int getCdmaEriIconIndexForSubscriber(int,java.lang.String,java.lang.String)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: int getCdmaEriIconMode(java.lang.String,java.lang.String)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: int getCdmaEriIconModeForSubscriber(int,java.lang.String,java.lang.String)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: java.lang.String getCdmaEriText(java.lang.String,java.lang.String)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: java.lang.String getCdmaEriTextForSubscriber(int,java.lang.String,java.lang.String)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: java.lang.String getCdmaMdn(int)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: java.lang.String getCdmaMin(int)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: java.lang.String getCdmaPrlVersion(int)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: int getCdmaRoamingMode(int)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: android.telephony.CellIdentity getCellLocation(java.lang.String,java.lang.String)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: com.android.internal.telephony.CellNetworkScanResult getCellNetworkScanResults(int,java.lang.String,java.lang.String)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: java.util.List getCertsFromCarrierPrivilegeAccessRules(int)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: java.util.List getClientRequestStats(java.lang.String,java.lang.String,int)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: java.lang.String getCurrentPackageName()>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: int getDataActivationState(int,java.lang.String)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: int getDataActivity()>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: int getDataActivityForSubId(int)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: boolean getDataEnabled(int)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: int getDataNetworkType(java.lang.String,java.lang.String)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: int getDataNetworkTypeForSubscriber(int,java.lang.String,java.lang.String)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: int getDataState()>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: int getDataStateForSubId(int)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: java.lang.String getDeviceId(java.lang.String)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: java.lang.String getDeviceIdWithFeature(java.lang.String,java.lang.String)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: java.lang.String getDeviceSoftwareVersionForSlot(int,java.lang.String,java.lang.String)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: long getEffectiveAllowedNetworkTypes(int)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: boolean getEmergencyCallbackMode(int)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: int getEmergencyNumberDbVersion(int)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: java.util.Map getEmergencyNumberList(java.lang.String,java.lang.String)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: java.util.List getEmergencyNumberListTestMode()>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: java.lang.String getEsn(int)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: [Ljava.lang.String; getForbiddenPlmns(int,int,java.lang.String,java.lang.String)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: java.lang.String getImeiForSlot(int,java.lang.String,java.lang.String)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: android.telephony.ims.aidl.IImsConfig getImsConfig(int,int)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: void getImsMmTelFeatureState(int,com.android.internal.telephony.IIntegerConsumer)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: void getImsMmTelRegistrationState(int,com.android.internal.telephony.IIntegerConsumer)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: void getImsMmTelRegistrationTransportType(int,com.android.internal.telephony.IIntegerConsumer)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: int getImsProvisioningInt(int,int)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: boolean getImsProvisioningStatusForCapability(int,int,int)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: java.lang.String getImsProvisioningString(int,int)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: int getImsRegTechnologyForMmTel(int)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: android.telephony.ims.aidl.IImsRegistration getImsRegistration(int,int)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: java.lang.String getInterfaceDescriptor()>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: java.lang.String getLine1AlphaTagForDisplay(int,java.lang.String,java.lang.String)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: java.lang.String getLine1NumberForDisplay(int,java.lang.String,java.lang.String)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: int getLteOnCdmaMode(java.lang.String,java.lang.String)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: int getLteOnCdmaModeForSubscriber(int,java.lang.String,java.lang.String)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: java.lang.String getManualNetworkSelectionPlmn(int)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: java.lang.String getManufacturerCodeForSlot(int)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: java.lang.String getMeidForSlot(int,java.lang.String,java.lang.String)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: [Ljava.lang.String; getMergedImsisFromGroup(int,java.lang.String)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: [Ljava.lang.String; getMergedSubscriberIds(int,java.lang.String,java.lang.String)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: android.telephony.ims.aidl.IImsMmTelFeature getMmTelFeatureAndListen(int,com.android.ims.internal.IImsServiceFeatureCallback)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: java.lang.String getMmsUAProfUrl(int)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: java.lang.String getMmsUserAgent(int)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: java.util.List getNeighboringCellInfo(java.lang.String,java.lang.String)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: java.lang.String getNetworkCountryIsoForPhone(int)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: int getNetworkSelectionMode(int)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: int getNetworkTypeForSubscriber(int,java.lang.String,java.lang.String)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: int getNumberOfModemsWithSimultaneousDataConnections(int,java.lang.String,java.lang.String)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: java.util.List getPackagesWithCarrierPrivileges(int)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: java.util.List getPackagesWithCarrierPrivilegesForAllPhones()>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: [Ljava.lang.String; getPcscfAddress(java.lang.String,java.lang.String,java.lang.String)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: android.telecom.PhoneAccountHandle getPhoneAccountHandleForSubscriptionId(int)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: int getPreferredNetworkType(int)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: int getRadioAccessFamily(int,java.lang.String)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: int getRadioHalVersion()>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: int getRadioPowerState(int,java.lang.String,java.lang.String)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: android.telephony.ims.aidl.IImsRcsFeature getRcsFeatureAndListen(int,com.android.ims.internal.IImsServiceFeatureCallback)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: boolean getRcsProvisioningStatusForCapability(int,int)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: android.telephony.ServiceState getServiceStateForSubscriber(int,java.lang.String,java.lang.String)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: android.telephony.SignalStrength getSignalStrength(int)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: java.lang.String getSimLocaleForSubscriber(int)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: [I getSlotsMapping()>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: int getSubIdForPhoneAccount(android.telecom.PhoneAccount)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: int getSubIdForPhoneAccountHandle(android.telecom.PhoneAccountHandle,java.lang.String,java.lang.String)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: int getSubscriptionCarrierId(int)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: java.lang.String getSubscriptionCarrierName(int)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: int getSubscriptionSpecificCarrierId(int)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: java.lang.String getSubscriptionSpecificCarrierName(int)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: java.util.List getTelephonyHistograms()>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: java.lang.String getTypeAllocationCodeForSlot(int)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: java.util.List getUiccCardsInfo(java.lang.String)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: [Landroid.telephony.UiccSlotInfo; getUiccSlotsInfo()>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: java.lang.String getVisualVoicemailPackageName(java.lang.String,java.lang.String,int)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: android.os.Bundle getVisualVoicemailSettings(java.lang.String,int)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: android.telephony.VisualVoicemailSmsFilterSettings getVisualVoicemailSmsFilterSettings(java.lang.String,int)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: int getVoWiFiModeSetting(int)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: int getVoWiFiRoamingModeSetting(int)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: int getVoiceActivationState(int,java.lang.String)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: int getVoiceMessageCountForSubscriber(int,java.lang.String,java.lang.String)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: int getVoiceNetworkTypeForSubscriber(int,java.lang.String,java.lang.String)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: android.net.Uri getVoicemailRingtoneUri(android.telecom.PhoneAccountHandle)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: boolean handlePinMmi(java.lang.String)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: boolean handlePinMmiForSubscriber(int,java.lang.String)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: void handleUssdRequest(int,java.lang.String,android.os.ResultReceiver)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: boolean hasIccCard()>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: boolean hasIccCardUsingSlotIndex(int)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: boolean iccCloseLogicalChannel(int,int)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: boolean iccCloseLogicalChannelBySlot(int,int)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: [B iccExchangeSimIO(int,int,int,int,int,int,java.lang.String)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: android.telephony.IccOpenLogicalChannelResponse iccOpenLogicalChannel(int,java.lang.String,java.lang.String,int)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: android.telephony.IccOpenLogicalChannelResponse iccOpenLogicalChannelBySlot(int,java.lang.String,java.lang.String,int)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: java.lang.String iccTransmitApduBasicChannel(int,java.lang.String,int,int,int,int,int,java.lang.String)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: java.lang.String iccTransmitApduBasicChannelBySlot(int,java.lang.String,int,int,int,int,int,java.lang.String)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: java.lang.String iccTransmitApduLogicalChannel(int,int,int,int,int,int,int,java.lang.String)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: java.lang.String iccTransmitApduLogicalChannelBySlot(int,int,int,int,int,int,int,java.lang.String)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: int invokeOemRilRequestRaw([B,[B)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: boolean isAdvancedCallingSettingEnabled(int)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: boolean isApnMetered(int,int)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: boolean isApplicationOnUicc(int,int)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: boolean isAvailable(int,int,int)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: boolean isCapable(int,int,int)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: boolean isConcurrentVoiceAndDataAllowed(int)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: boolean isDataAllowedInVoiceCall(int)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: boolean isDataConnectivityPossible(int)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: boolean isDataEnabled(int)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: boolean isDataEnabledForApn(int,int,java.lang.String)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: boolean isDataRoamingEnabled(int)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: boolean isEmergencyNumber(java.lang.String,boolean)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: boolean isHearingAidCompatibilitySupported()>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: boolean isIccLockEnabled(int)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: boolean isImsRegistered(int)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: boolean isInEmergencySmsMode()>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: boolean isManualNetworkSelectionAllowed(int)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: boolean isMmTelCapabilityProvisionedInCache(int,int,int)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: void isMmTelCapabilitySupported(int,com.android.internal.telephony.IIntegerConsumer,int,int)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: boolean isModemEnabledForSlot(int,java.lang.String,java.lang.String)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: int isMultiSimSupported(java.lang.String,java.lang.String)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: boolean isMvnoMatched(int,int,java.lang.String)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: boolean isRadioOn(java.lang.String)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: boolean isRadioOnForSubscriber(int,java.lang.String)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: boolean isRadioOnForSubscriberWithFeature(int,java.lang.String,java.lang.String)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: boolean isRadioOnWithFeature(java.lang.String,java.lang.String)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: boolean isRttSupported(int)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: boolean isTetheringApnRequiredForSubscriber(int)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: boolean isTtyModeSupported()>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: boolean isTtyOverVolteEnabled(int)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: boolean isUserDataEnabled(int)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: boolean isVideoCallingEnabled(java.lang.String,java.lang.String)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: boolean isVideoTelephonyAvailable(int)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: boolean isVoWiFiRoamingSettingEnabled(int)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: boolean isVoWiFiSettingEnabled(int)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: boolean isVoicemailVibrationEnabled(android.telecom.PhoneAccountHandle)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: boolean isVtSettingEnabled(int)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: boolean isWifiCallingAvailable(int)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: boolean isWorldPhone(int,java.lang.String,java.lang.String)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: boolean needMobileRadioShutdown()>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: boolean needsOtaServiceProvisioning()>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: void notifyOtaEmergencyNumberDbInstalled()>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: void notifyRcsAutoConfigurationReceived(int,[B,boolean)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: java.lang.String nvReadItem(int)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: boolean nvWriteCdmaPrl([B)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: boolean nvWriteItem(int,java.lang.String)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: boolean rebootModem(int)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: void refreshUiccProfile(int)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: void registerImsProvisioningChangedCallback(int,android.telephony.ims.aidl.IImsConfigCallback)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: void registerImsRegistrationCallback(int,android.telephony.ims.aidl.IImsRegistrationCallback)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: void registerMmTelCapabilityCallback(int,android.telephony.ims.aidl.IImsCapabilityCallback)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: void requestCellInfoUpdate(int,android.telephony.ICellInfoCallback,java.lang.String,java.lang.String)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: void requestCellInfoUpdateWithWorkSource(int,android.telephony.ICellInfoCallback,java.lang.String,java.lang.String,android.os.WorkSource)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: void requestModemActivityInfo(android.os.ResultReceiver)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: int requestNetworkScan(int,android.telephony.NetworkScanRequest,android.os.Messenger,android.os.IBinder,java.lang.String,java.lang.String)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: void requestNumberVerification(android.telephony.PhoneNumberRange,long,com.android.internal.telephony.INumberVerificationCallback,java.lang.String)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: void requestUserActivityNotification()>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: void resetIms(int)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: boolean resetModemConfig(int)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: void resetOtaEmergencyNumberDbFilePath()>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: void sendDialerSpecialCode(java.lang.String,java.lang.String)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: java.lang.String sendEnvelopeWithStatus(int,java.lang.String)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: void sendVisualVoicemailSmsForSubscriber(java.lang.String,java.lang.String,int,java.lang.String,int,java.lang.String,android.app.PendingIntent)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: void setAdvancedCallingSettingEnabled(int,boolean)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: int setAllowedCarriers(android.telephony.CarrierRestrictionRules)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: boolean setAllowedNetworkTypes(int,long)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: boolean setAllowedNetworkTypesForReason(int,int,long)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: boolean setAlwaysAllowMmsData(int,boolean)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: void setAlwaysReportSignalStrength(int,boolean)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: boolean setBoundImsServiceOverride(int,boolean,[I,java.lang.String)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: boolean setCallForwarding(int,android.telephony.CallForwardingInfo)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: boolean setCallWaitingStatus(int,boolean)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: void setCarrierTestOverride(int,java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: boolean setCdmaRoamingMode(int,int)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: boolean setCdmaSubscriptionMode(int,int)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: void setCellInfoListRate(int)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: void setCepEnabled(boolean)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: void setDataActivationState(int,int)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: boolean setDataAllowedDuringVoiceCall(int,boolean)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: void setDataRoamingEnabled(int,boolean)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: int setForbiddenPlmns(int,int,java.util.List,java.lang.String,java.lang.String)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: int setIccLockEnabled(int,boolean,java.lang.String)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: int setImsProvisioningInt(int,int,int)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: void setImsProvisioningStatusForCapability(int,int,int,boolean)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: int setImsProvisioningString(int,int,java.lang.String)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: void setImsRegistrationState(boolean)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: boolean setLine1NumberForDisplayForSubscriber(int,java.lang.String,java.lang.String)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: void setMultiSimCarrierRestriction(boolean)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: void setNetworkSelectionModeAutomatic(int)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: boolean setNetworkSelectionModeManual(int,com.android.internal.telephony.OperatorInfo,boolean)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: boolean setOperatorBrandOverride(int,java.lang.String)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: void setPolicyDataEnabled(boolean,int)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: boolean setPreferredNetworkType(int,int)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: boolean setRadio(boolean)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: void setRadioCapability([Landroid.telephony.RadioAccessFamily;)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: boolean setRadioForSubscriber(int,boolean)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: boolean setRadioPower(boolean)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: void setRcsProvisioningStatusForCapability(int,int,boolean)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: boolean setRoamingOverride(int,java.util.List,java.util.List,java.util.List,java.util.List)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: void setRttCapabilitySetting(int,boolean)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: void setSimPowerStateForSlot(int,int)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: void setSystemSelectionChannels(java.util.List,int,com.android.internal.telephony.IBooleanConsumer)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: void setUserDataEnabled(int,boolean)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: void setVoWiFiModeSetting(int,int)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: void setVoWiFiNonPersistent(int,boolean,int)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: void setVoWiFiRoamingModeSetting(int,int)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: void setVoWiFiRoamingSettingEnabled(int,boolean)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: void setVoWiFiSettingEnabled(int,boolean)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: void setVoiceActivationState(int,int)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: boolean setVoiceMailNumber(int,java.lang.String,java.lang.String)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: void setVoicemailRingtoneUri(java.lang.String,android.telecom.PhoneAccountHandle,android.net.Uri)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: void setVoicemailVibrationEnabled(java.lang.String,android.telecom.PhoneAccountHandle,boolean)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: void setVtSettingEnabled(int,boolean)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: void shutdownMobileRadios()>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: void stopNetworkScan(int,int)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: boolean supplyPinForSubscriber(int,java.lang.String)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: [I supplyPinReportResultForSubscriber(int,java.lang.String)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: boolean supplyPukForSubscriber(int,java.lang.String,java.lang.String)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: [I supplyPukReportResultForSubscriber(int,java.lang.String,java.lang.String)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: void switchMultiSimConfig(int)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: boolean switchSlots([I)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: void toggleRadioOnOff()>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: void toggleRadioOnOffForSubscriber(int)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: void unregisterImsFeatureCallback(int,int,com.android.ims.internal.IImsServiceFeatureCallback)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: void unregisterImsProvisioningChangedCallback(int,android.telephony.ims.aidl.IImsConfigCallback)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: void unregisterImsRegistrationCallback(int,android.telephony.ims.aidl.IImsRegistrationCallback)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: void unregisterMmTelCapabilityCallback(int,android.telephony.ims.aidl.IImsCapabilityCallback)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: void updateEmergencyNumberListTestMode(int,android.telephony.emergency.EmergencyNumber)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: void updateOtaEmergencyNumberDbFilePath(android.os.ParcelFileDescriptor)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: void updateServiceLocation()>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: void updateServiceLocationForSubscriber(int)>
	<com.android.internal.telephony.ITelephony$Stub$Proxy: void userActivity()>

Name: pinner
StubClassName: null
isAvaliable: false
Methods : 0 

Name: platform_compat
StubClassName: com.android.internal.compat.IPlatformCompat
isAvaliable: true
Methods : 19 
	<com.android.internal.compat.IPlatformCompat$Stub$Proxy: android.os.IBinder asBinder()>
	<com.android.internal.compat.IPlatformCompat$Stub$Proxy: boolean clearOverride(long,java.lang.String)>
	<com.android.internal.compat.IPlatformCompat$Stub$Proxy: void clearOverrides(java.lang.String)>
	<com.android.internal.compat.IPlatformCompat$Stub$Proxy: void clearOverridesForTest(java.lang.String)>
	<com.android.internal.compat.IPlatformCompat$Stub$Proxy: int disableTargetSdkChanges(java.lang.String,int)>
	<com.android.internal.compat.IPlatformCompat$Stub$Proxy: int enableTargetSdkChanges(java.lang.String,int)>
	<com.android.internal.compat.IPlatformCompat$Stub$Proxy: com.android.internal.compat.CompatibilityChangeConfig getAppConfig(android.content.pm.ApplicationInfo)>
	<com.android.internal.compat.IPlatformCompat$Stub$Proxy: java.lang.String getInterfaceDescriptor()>
	<com.android.internal.compat.IPlatformCompat$Stub$Proxy: com.android.internal.compat.IOverrideValidator getOverrideValidator()>
	<com.android.internal.compat.IPlatformCompat$Stub$Proxy: boolean isChangeEnabled(long,android.content.pm.ApplicationInfo)>
	<com.android.internal.compat.IPlatformCompat$Stub$Proxy: boolean isChangeEnabledByPackageName(long,java.lang.String,int)>
	<com.android.internal.compat.IPlatformCompat$Stub$Proxy: boolean isChangeEnabledByUid(long,int)>
	<com.android.internal.compat.IPlatformCompat$Stub$Proxy: [Lcom.android.internal.compat.CompatibilityChangeInfo; listAllChanges()>
	<com.android.internal.compat.IPlatformCompat$Stub$Proxy: [Lcom.android.internal.compat.CompatibilityChangeInfo; listUIChanges()>
	<com.android.internal.compat.IPlatformCompat$Stub$Proxy: void reportChange(long,android.content.pm.ApplicationInfo)>
	<com.android.internal.compat.IPlatformCompat$Stub$Proxy: void reportChangeByPackageName(long,java.lang.String,int)>
	<com.android.internal.compat.IPlatformCompat$Stub$Proxy: void reportChangeByUid(long,int)>
	<com.android.internal.compat.IPlatformCompat$Stub$Proxy: void setOverrides(com.android.internal.compat.CompatibilityChangeConfig,java.lang.String)>
	<com.android.internal.compat.IPlatformCompat$Stub$Proxy: void setOverridesForTest(com.android.internal.compat.CompatibilityChangeConfig,java.lang.String)>

Name: platform_compat_native
StubClassName: com.android.internal.compat.IPlatformCompatNative
isAvaliable: true
Methods : 6 
	<com.android.internal.compat.IPlatformCompatNative$Stub$Proxy: android.os.IBinder asBinder()>
	<com.android.internal.compat.IPlatformCompatNative$Stub$Proxy: java.lang.String getInterfaceDescriptor()>
	<com.android.internal.compat.IPlatformCompatNative$Stub$Proxy: boolean isChangeEnabledByPackageName(long,java.lang.String,int)>
	<com.android.internal.compat.IPlatformCompatNative$Stub$Proxy: boolean isChangeEnabledByUid(long,int)>
	<com.android.internal.compat.IPlatformCompatNative$Stub$Proxy: void reportChangeByPackageName(long,java.lang.String,int)>
	<com.android.internal.compat.IPlatformCompatNative$Stub$Proxy: void reportChangeByUid(long,int)>

Name: power
StubClassName: android.os.IPowerManager
isAvaliable: true
Methods : 43 
	<android.os.IPowerManager$Stub$Proxy: void acquireWakeLock(android.os.IBinder,int,java.lang.String,java.lang.String,android.os.WorkSource,java.lang.String)>
	<android.os.IPowerManager$Stub$Proxy: void acquireWakeLockWithUid(android.os.IBinder,int,java.lang.String,java.lang.String,int)>
	<android.os.IPowerManager$Stub$Proxy: android.os.IBinder asBinder()>
	<android.os.IPowerManager$Stub$Proxy: void boostScreenBrightness(long)>
	<android.os.IPowerManager$Stub$Proxy: void crash(java.lang.String)>
	<android.os.IPowerManager$Stub$Proxy: boolean forceSuspend()>
	<android.os.IPowerManager$Stub$Proxy: float getBrightnessConstraint(int)>
	<android.os.IPowerManager$Stub$Proxy: java.lang.String getInterfaceDescriptor()>
	<android.os.IPowerManager$Stub$Proxy: int getLastShutdownReason()>
	<android.os.IPowerManager$Stub$Proxy: int getLastSleepReason()>
	<android.os.IPowerManager$Stub$Proxy: int getPowerSaveModeTrigger()>
	<android.os.IPowerManager$Stub$Proxy: android.os.PowerSaveState getPowerSaveState(int)>
	<android.os.IPowerManager$Stub$Proxy: void goToSleep(long,int,int)>
	<android.os.IPowerManager$Stub$Proxy: boolean isAmbientDisplayAvailable()>
	<android.os.IPowerManager$Stub$Proxy: boolean isAmbientDisplaySuppressed()>
	<android.os.IPowerManager$Stub$Proxy: boolean isAmbientDisplaySuppressedForToken(java.lang.String)>
	<android.os.IPowerManager$Stub$Proxy: boolean isDeviceIdleMode()>
	<android.os.IPowerManager$Stub$Proxy: boolean isInteractive()>
	<android.os.IPowerManager$Stub$Proxy: boolean isLightDeviceIdleMode()>
	<android.os.IPowerManager$Stub$Proxy: boolean isPowerSaveMode()>
	<android.os.IPowerManager$Stub$Proxy: boolean isScreenBrightnessBoosted()>
	<android.os.IPowerManager$Stub$Proxy: boolean isWakeLockLevelSupported(int)>
	<android.os.IPowerManager$Stub$Proxy: void nap(long)>
	<android.os.IPowerManager$Stub$Proxy: void powerHint(int,int)>
	<android.os.IPowerManager$Stub$Proxy: void reboot(boolean,java.lang.String,boolean)>
	<android.os.IPowerManager$Stub$Proxy: void rebootSafeMode(boolean,boolean)>
	<android.os.IPowerManager$Stub$Proxy: void releaseWakeLock(android.os.IBinder,int)>
	<android.os.IPowerManager$Stub$Proxy: boolean setAdaptivePowerSaveEnabled(boolean)>
	<android.os.IPowerManager$Stub$Proxy: boolean setAdaptivePowerSavePolicy(android.os.BatterySaverPolicyConfig)>
	<android.os.IPowerManager$Stub$Proxy: void setAttentionLight(boolean,int)>
	<android.os.IPowerManager$Stub$Proxy: void setDozeAfterScreenOff(boolean)>
	<android.os.IPowerManager$Stub$Proxy: boolean setDynamicPowerSaveHint(boolean,int)>
	<android.os.IPowerManager$Stub$Proxy: void setPowerBoost(int,int)>
	<android.os.IPowerManager$Stub$Proxy: void setPowerMode(int,boolean)>
	<android.os.IPowerManager$Stub$Proxy: boolean setPowerModeChecked(int,boolean)>
	<android.os.IPowerManager$Stub$Proxy: boolean setPowerSaveModeEnabled(boolean)>
	<android.os.IPowerManager$Stub$Proxy: void setStayOnSetting(int)>
	<android.os.IPowerManager$Stub$Proxy: void shutdown(boolean,java.lang.String,boolean)>
	<android.os.IPowerManager$Stub$Proxy: void suppressAmbientDisplay(java.lang.String,boolean)>
	<android.os.IPowerManager$Stub$Proxy: void updateWakeLockUids(android.os.IBinder,[I)>
	<android.os.IPowerManager$Stub$Proxy: void updateWakeLockWorkSource(android.os.IBinder,android.os.WorkSource,java.lang.String)>
	<android.os.IPowerManager$Stub$Proxy: void userActivity(long,int,int)>
	<android.os.IPowerManager$Stub$Proxy: void wakeUp(long,int,java.lang.String,java.lang.String)>

Name: print
StubClassName: android.print.IPrintManager
isAvaliable: true
Methods : 26 
	<android.print.IPrintManager$Stub$Proxy: void addPrintJobStateChangeListener(android.print.IPrintJobStateChangeListener,int,int)>
	<android.print.IPrintManager$Stub$Proxy: void addPrintServiceRecommendationsChangeListener(android.printservice.recommendation.IRecommendationsChangeListener,int)>
	<android.print.IPrintManager$Stub$Proxy: void addPrintServicesChangeListener(android.print.IPrintServicesChangeListener,int)>
	<android.print.IPrintManager$Stub$Proxy: android.os.IBinder asBinder()>
	<android.print.IPrintManager$Stub$Proxy: void cancelPrintJob(android.print.PrintJobId,int,int)>
	<android.print.IPrintManager$Stub$Proxy: void createPrinterDiscoverySession(android.print.IPrinterDiscoveryObserver,int)>
	<android.print.IPrintManager$Stub$Proxy: void destroyPrinterDiscoverySession(android.print.IPrinterDiscoveryObserver,int)>
	<android.print.IPrintManager$Stub$Proxy: boolean getBindInstantServiceAllowed(int)>
	<android.print.IPrintManager$Stub$Proxy: android.graphics.drawable.Icon getCustomPrinterIcon(android.print.PrinterId,int)>
	<android.print.IPrintManager$Stub$Proxy: java.lang.String getInterfaceDescriptor()>
	<android.print.IPrintManager$Stub$Proxy: android.print.PrintJobInfo getPrintJobInfo(android.print.PrintJobId,int,int)>
	<android.print.IPrintManager$Stub$Proxy: java.util.List getPrintJobInfos(int,int)>
	<android.print.IPrintManager$Stub$Proxy: java.util.List getPrintServiceRecommendations(int)>
	<android.print.IPrintManager$Stub$Proxy: java.util.List getPrintServices(int,int)>
	<android.print.IPrintManager$Stub$Proxy: android.os.Bundle print(java.lang.String,android.print.IPrintDocumentAdapter,android.print.PrintAttributes,java.lang.String,int,int)>
	<android.print.IPrintManager$Stub$Proxy: void removePrintJobStateChangeListener(android.print.IPrintJobStateChangeListener,int)>
	<android.print.IPrintManager$Stub$Proxy: void removePrintServiceRecommendationsChangeListener(android.printservice.recommendation.IRecommendationsChangeListener,int)>
	<android.print.IPrintManager$Stub$Proxy: void removePrintServicesChangeListener(android.print.IPrintServicesChangeListener,int)>
	<android.print.IPrintManager$Stub$Proxy: void restartPrintJob(android.print.PrintJobId,int,int)>
	<android.print.IPrintManager$Stub$Proxy: void setBindInstantServiceAllowed(int,boolean)>
	<android.print.IPrintManager$Stub$Proxy: void setPrintServiceEnabled(android.content.ComponentName,boolean,int)>
	<android.print.IPrintManager$Stub$Proxy: void startPrinterDiscovery(android.print.IPrinterDiscoveryObserver,java.util.List,int)>
	<android.print.IPrintManager$Stub$Proxy: void startPrinterStateTracking(android.print.PrinterId,int)>
	<android.print.IPrintManager$Stub$Proxy: void stopPrinterDiscovery(android.print.IPrinterDiscoveryObserver,int)>
	<android.print.IPrintManager$Stub$Proxy: void stopPrinterStateTracking(android.print.PrinterId,int)>
	<android.print.IPrintManager$Stub$Proxy: void validatePrinters(java.util.List,int)>

Name: processinfo
StubClassName: null
isAvaliable: false
Methods : 0 

Name: procstats
StubClassName: com.android.internal.app.procstats.IProcessStats
isAvaliable: true
Methods : 8 
	<com.android.internal.app.procstats.IProcessStats$Stub$Proxy: android.os.IBinder asBinder()>
	<com.android.internal.app.procstats.IProcessStats$Stub$Proxy: long getCommittedStats(long,int,boolean,java.util.List)>
	<com.android.internal.app.procstats.IProcessStats$Stub$Proxy: long getCommittedStatsMerged(long,int,boolean,java.util.List,com.android.internal.app.procstats.ProcessStats)>
	<com.android.internal.app.procstats.IProcessStats$Stub$Proxy: int getCurrentMemoryState()>
	<com.android.internal.app.procstats.IProcessStats$Stub$Proxy: [B getCurrentStats(java.util.List)>
	<com.android.internal.app.procstats.IProcessStats$Stub$Proxy: java.lang.String getInterfaceDescriptor()>
	<com.android.internal.app.procstats.IProcessStats$Stub$Proxy: long getMinAssociationDumpDuration()>
	<com.android.internal.app.procstats.IProcessStats$Stub$Proxy: android.os.ParcelFileDescriptor getStatsOverTime(long)>

Name: qchook
StubClassName: null
isAvaliable: false
Methods : 0 

Name: qti.ims.ext
StubClassName: org.codeaurora.ims.internal.IQtiImsExt
isAvaliable: true
Methods : 20 
	<org.codeaurora.ims.internal.IQtiImsExt$Stub$Proxy: android.os.IBinder asBinder()>
	<org.codeaurora.ims.internal.IQtiImsExt$Stub$Proxy: void getCallForwardUncondTimer(int,int,int,org.codeaurora.ims.internal.IQtiImsExtListener)>
	<org.codeaurora.ims.internal.IQtiImsExt$Stub$Proxy: void getHandoverConfig(int,org.codeaurora.ims.internal.IQtiImsExtListener)>
	<org.codeaurora.ims.internal.IQtiImsExt$Stub$Proxy: java.lang.String getInterfaceDescriptor()>
	<org.codeaurora.ims.internal.IQtiImsExt$Stub$Proxy: void getPacketCount(int,org.codeaurora.ims.internal.IQtiImsExtListener)>
	<org.codeaurora.ims.internal.IQtiImsExt$Stub$Proxy: void getPacketErrorCount(int,org.codeaurora.ims.internal.IQtiImsExtListener)>
	<org.codeaurora.ims.internal.IQtiImsExt$Stub$Proxy: int getRcsAppConfig(int)>
	<org.codeaurora.ims.internal.IQtiImsExt$Stub$Proxy: int getVvmAppConfig(int)>
	<org.codeaurora.ims.internal.IQtiImsExt$Stub$Proxy: void querySsacStatus(int,org.codeaurora.ims.internal.IQtiImsExtListener)>
	<org.codeaurora.ims.internal.IQtiImsExt$Stub$Proxy: void queryVoltePreference(int,org.codeaurora.ims.internal.IQtiImsExtListener)>
	<org.codeaurora.ims.internal.IQtiImsExt$Stub$Proxy: void queryVopsStatus(int,org.codeaurora.ims.internal.IQtiImsExtListener)>
	<org.codeaurora.ims.internal.IQtiImsExt$Stub$Proxy: void registerForParticipantStatusInfo(int,org.codeaurora.ims.internal.IQtiImsExtListener)>
	<org.codeaurora.ims.internal.IQtiImsExt$Stub$Proxy: void resumePendingCall(int,int)>
	<org.codeaurora.ims.internal.IQtiImsExt$Stub$Proxy: void sendCallTransferRequest(int,int,java.lang.String,org.codeaurora.ims.internal.IQtiImsExtListener)>
	<org.codeaurora.ims.internal.IQtiImsExt$Stub$Proxy: void sendCancelModifyCall(int,org.codeaurora.ims.internal.IQtiImsExtListener)>
	<org.codeaurora.ims.internal.IQtiImsExt$Stub$Proxy: void setCallForwardUncondTimer(int,int,int,int,int,int,int,int,java.lang.String,org.codeaurora.ims.internal.IQtiImsExtListener)>
	<org.codeaurora.ims.internal.IQtiImsExt$Stub$Proxy: void setHandoverConfig(int,int,org.codeaurora.ims.internal.IQtiImsExtListener)>
	<org.codeaurora.ims.internal.IQtiImsExt$Stub$Proxy: int setRcsAppConfig(int,int)>
	<org.codeaurora.ims.internal.IQtiImsExt$Stub$Proxy: int setVvmAppConfig(int,int)>
	<org.codeaurora.ims.internal.IQtiImsExt$Stub$Proxy: void updateVoltePreference(int,int,org.codeaurora.ims.internal.IQtiImsExtListener)>

Name: rcs
StubClassName: com.android.ims.internal.IRcsService
isAvaliable: true
Methods : 3 
	<com.android.ims.internal.IRcsService$Stub$Proxy: android.os.IBinder asBinder()>
	<com.android.ims.internal.IRcsService$Stub$Proxy: com.android.ims.internal.IRcsPresence getRcsPresenceInterface()>
	<com.android.ims.internal.IRcsService$Stub$Proxy: boolean isRcsServiceAvailable()>

Name: recovery
StubClassName: null
isAvaliable: false
Methods : 0 

Name: restrictions
StubClassName: android.content.IRestrictionsManager
isAvaliable: true
Methods : 7 
	<android.content.IRestrictionsManager$Stub$Proxy: android.os.IBinder asBinder()>
	<android.content.IRestrictionsManager$Stub$Proxy: android.content.Intent createLocalApprovalIntent()>
	<android.content.IRestrictionsManager$Stub$Proxy: android.os.Bundle getApplicationRestrictions(java.lang.String)>
	<android.content.IRestrictionsManager$Stub$Proxy: java.lang.String getInterfaceDescriptor()>
	<android.content.IRestrictionsManager$Stub$Proxy: boolean hasRestrictionsProvider()>
	<android.content.IRestrictionsManager$Stub$Proxy: void notifyPermissionResponse(java.lang.String,android.os.PersistableBundle)>
	<android.content.IRestrictionsManager$Stub$Proxy: void requestPermission(java.lang.String,java.lang.String,java.lang.String,android.os.PersistableBundle)>

Name: role
StubClassName: android.app.role.IRoleManager
isAvaliable: true
Methods : 15 
	<android.app.role.IRoleManager$Stub$Proxy: void addOnRoleHoldersChangedListenerAsUser(android.app.role.IOnRoleHoldersChangedListener,int)>
	<android.app.role.IRoleManager$Stub$Proxy: void addRoleHolderAsUser(java.lang.String,java.lang.String,int,int,android.os.RemoteCallback)>
	<android.app.role.IRoleManager$Stub$Proxy: boolean addRoleHolderFromController(java.lang.String,java.lang.String)>
	<android.app.role.IRoleManager$Stub$Proxy: android.os.IBinder asBinder()>
	<android.app.role.IRoleManager$Stub$Proxy: void clearRoleHoldersAsUser(java.lang.String,int,int,android.os.RemoteCallback)>
	<android.app.role.IRoleManager$Stub$Proxy: java.lang.String getDefaultSmsPackage(int)>
	<android.app.role.IRoleManager$Stub$Proxy: java.util.List getHeldRolesFromController(java.lang.String)>
	<android.app.role.IRoleManager$Stub$Proxy: java.lang.String getInterfaceDescriptor()>
	<android.app.role.IRoleManager$Stub$Proxy: java.util.List getRoleHoldersAsUser(java.lang.String,int)>
	<android.app.role.IRoleManager$Stub$Proxy: boolean isRoleAvailable(java.lang.String)>
	<android.app.role.IRoleManager$Stub$Proxy: boolean isRoleHeld(java.lang.String,java.lang.String)>
	<android.app.role.IRoleManager$Stub$Proxy: void removeOnRoleHoldersChangedListenerAsUser(android.app.role.IOnRoleHoldersChangedListener,int)>
	<android.app.role.IRoleManager$Stub$Proxy: void removeRoleHolderAsUser(java.lang.String,java.lang.String,int,int,android.os.RemoteCallback)>
	<android.app.role.IRoleManager$Stub$Proxy: boolean removeRoleHolderFromController(java.lang.String,java.lang.String)>
	<android.app.role.IRoleManager$Stub$Proxy: void setRoleNamesFromController(java.util.List)>

Name: rollback
StubClassName: android.content.rollback.IRollbackManager
isAvaliable: true
Methods : 11 
	<android.content.rollback.IRollbackManager$Stub$Proxy: android.os.IBinder asBinder()>
	<android.content.rollback.IRollbackManager$Stub$Proxy: void blockRollbackManager(long)>
	<android.content.rollback.IRollbackManager$Stub$Proxy: void commitRollback(int,android.content.pm.ParceledListSlice,java.lang.String,android.content.IntentSender)>
	<android.content.rollback.IRollbackManager$Stub$Proxy: void expireRollbackForPackage(java.lang.String)>
	<android.content.rollback.IRollbackManager$Stub$Proxy: android.content.pm.ParceledListSlice getAvailableRollbacks()>
	<android.content.rollback.IRollbackManager$Stub$Proxy: java.lang.String getInterfaceDescriptor()>
	<android.content.rollback.IRollbackManager$Stub$Proxy: android.content.pm.ParceledListSlice getRecentlyCommittedRollbacks()>
	<android.content.rollback.IRollbackManager$Stub$Proxy: void notifyStagedApkSession(int,int)>
	<android.content.rollback.IRollbackManager$Stub$Proxy: int notifyStagedSession(int)>
	<android.content.rollback.IRollbackManager$Stub$Proxy: void reloadPersistedData()>
	<android.content.rollback.IRollbackManager$Stub$Proxy: void snapshotAndRestoreUserData(java.lang.String,[I,int,long,java.lang.String,int)>

Name: runtime
StubClassName: null
isAvaliable: false
Methods : 0 

Name: scheduling_policy
StubClassName: null
isAvaliable: false
Methods : 0 

Name: search
StubClassName: android.app.ISearchManager
isAvaliable: true
Methods : 8 
	<android.app.ISearchManager$Stub$Proxy: android.os.IBinder asBinder()>
	<android.app.ISearchManager$Stub$Proxy: java.util.List getGlobalSearchActivities()>
	<android.app.ISearchManager$Stub$Proxy: android.content.ComponentName getGlobalSearchActivity()>
	<android.app.ISearchManager$Stub$Proxy: java.lang.String getInterfaceDescriptor()>
	<android.app.ISearchManager$Stub$Proxy: android.app.SearchableInfo getSearchableInfo(android.content.ComponentName)>
	<android.app.ISearchManager$Stub$Proxy: java.util.List getSearchablesInGlobalSearch()>
	<android.app.ISearchManager$Stub$Proxy: android.content.ComponentName getWebSearchActivity()>
	<android.app.ISearchManager$Stub$Proxy: void launchAssist(int,android.os.Bundle)>

Name: sec_key_att_app_id_provider
StubClassName: android.security.keymaster.IKeyAttestationApplicationIdProvider
isAvaliable: true
Methods : 3 
	<android.security.keymaster.IKeyAttestationApplicationIdProvider$Stub$Proxy: android.os.IBinder asBinder()>
	<android.security.keymaster.IKeyAttestationApplicationIdProvider$Stub$Proxy: java.lang.String getInterfaceDescriptor()>
	<android.security.keymaster.IKeyAttestationApplicationIdProvider$Stub$Proxy: android.security.keymaster.KeyAttestationApplicationId getKeyAttestationApplicationId(int)>

Name: secure_element
StubClassName: null
isAvaliable: false
Methods : 0 

Name: sensor_privacy
StubClassName: android.hardware.ISensorPrivacyManager
isAvaliable: true
Methods : 6 
	<android.hardware.ISensorPrivacyManager$Stub$Proxy: void addSensorPrivacyListener(android.hardware.ISensorPrivacyListener)>
	<android.hardware.ISensorPrivacyManager$Stub$Proxy: android.os.IBinder asBinder()>
	<android.hardware.ISensorPrivacyManager$Stub$Proxy: java.lang.String getInterfaceDescriptor()>
	<android.hardware.ISensorPrivacyManager$Stub$Proxy: boolean isSensorPrivacyEnabled()>
	<android.hardware.ISensorPrivacyManager$Stub$Proxy: void removeSensorPrivacyListener(android.hardware.ISensorPrivacyListener)>
	<android.hardware.ISensorPrivacyManager$Stub$Proxy: void setSensorPrivacy(boolean)>

Name: sensorservice
StubClassName: null
isAvaliable: true
Methods : 0 

Name: serial
StubClassName: null
isAvaliable: false
Methods : 0 

Name: servicediscovery
StubClassName: android.net.nsd.INsdManager
isAvaliable: true
Methods : 4 
	<android.net.nsd.INsdManager$Stub$Proxy: android.os.IBinder asBinder()>
	<android.net.nsd.INsdManager$Stub$Proxy: java.lang.String getInterfaceDescriptor()>
	<android.net.nsd.INsdManager$Stub$Proxy: android.os.Messenger getMessenger()>
	<android.net.nsd.INsdManager$Stub$Proxy: void setEnabled(boolean)>

Name: settings
StubClassName: null
isAvaliable: true
Methods : 0 

Name: shortcut
StubClassName: android.content.pm.IShortcutService
isAvaliable: true
Methods : 26 
	<android.content.pm.IShortcutService$Stub$Proxy: boolean addDynamicShortcuts(java.lang.String,android.content.pm.ParceledListSlice,int)>
	<android.content.pm.IShortcutService$Stub$Proxy: void applyRestore([B,int)>
	<android.content.pm.IShortcutService$Stub$Proxy: android.os.IBinder asBinder()>
	<android.content.pm.IShortcutService$Stub$Proxy: android.content.Intent createShortcutResultIntent(java.lang.String,android.content.pm.ShortcutInfo,int)>
	<android.content.pm.IShortcutService$Stub$Proxy: void disableShortcuts(java.lang.String,java.util.List,java.lang.CharSequence,int,int)>
	<android.content.pm.IShortcutService$Stub$Proxy: void enableShortcuts(java.lang.String,java.util.List,int)>
	<android.content.pm.IShortcutService$Stub$Proxy: [B getBackupPayload(int)>
	<android.content.pm.IShortcutService$Stub$Proxy: int getIconMaxDimensions(java.lang.String,int)>
	<android.content.pm.IShortcutService$Stub$Proxy: java.lang.String getInterfaceDescriptor()>
	<android.content.pm.IShortcutService$Stub$Proxy: int getMaxShortcutCountPerActivity(java.lang.String,int)>
	<android.content.pm.IShortcutService$Stub$Proxy: long getRateLimitResetTime(java.lang.String,int)>
	<android.content.pm.IShortcutService$Stub$Proxy: int getRemainingCallCount(java.lang.String,int)>
	<android.content.pm.IShortcutService$Stub$Proxy: android.content.pm.ParceledListSlice getShareTargets(java.lang.String,android.content.IntentFilter,int)>
	<android.content.pm.IShortcutService$Stub$Proxy: android.content.pm.ParceledListSlice getShortcuts(java.lang.String,int,int)>
	<android.content.pm.IShortcutService$Stub$Proxy: boolean hasShareTargets(java.lang.String,java.lang.String,int)>
	<android.content.pm.IShortcutService$Stub$Proxy: boolean isRequestPinItemSupported(int,int)>
	<android.content.pm.IShortcutService$Stub$Proxy: void onApplicationActive(java.lang.String,int)>
	<android.content.pm.IShortcutService$Stub$Proxy: void pushDynamicShortcut(java.lang.String,android.content.pm.ShortcutInfo,int)>
	<android.content.pm.IShortcutService$Stub$Proxy: void removeAllDynamicShortcuts(java.lang.String,int)>
	<android.content.pm.IShortcutService$Stub$Proxy: void removeDynamicShortcuts(java.lang.String,java.util.List,int)>
	<android.content.pm.IShortcutService$Stub$Proxy: void removeLongLivedShortcuts(java.lang.String,java.util.List,int)>
	<android.content.pm.IShortcutService$Stub$Proxy: void reportShortcutUsed(java.lang.String,java.lang.String,int)>
	<android.content.pm.IShortcutService$Stub$Proxy: boolean requestPinShortcut(java.lang.String,android.content.pm.ShortcutInfo,android.content.IntentSender,int)>
	<android.content.pm.IShortcutService$Stub$Proxy: void resetThrottling()>
	<android.content.pm.IShortcutService$Stub$Proxy: boolean setDynamicShortcuts(java.lang.String,android.content.pm.ParceledListSlice,int)>
	<android.content.pm.IShortcutService$Stub$Proxy: boolean updateShortcuts(java.lang.String,android.content.pm.ParceledListSlice,int)>

Name: simphonebook
StubClassName: com.android.internal.telephony.IIccPhoneBook
isAvaliable: true
Methods : 10 
	<com.android.internal.telephony.IIccPhoneBook$Stub$Proxy: android.os.IBinder asBinder()>
	<com.android.internal.telephony.IIccPhoneBook$Stub$Proxy: java.util.List getAdnRecordsInEf(int)>
	<com.android.internal.telephony.IIccPhoneBook$Stub$Proxy: java.util.List getAdnRecordsInEfForSubscriber(int,int)>
	<com.android.internal.telephony.IIccPhoneBook$Stub$Proxy: [I getAdnRecordsSize(int)>
	<com.android.internal.telephony.IIccPhoneBook$Stub$Proxy: [I getAdnRecordsSizeForSubscriber(int,int)>
	<com.android.internal.telephony.IIccPhoneBook$Stub$Proxy: java.lang.String getInterfaceDescriptor()>
	<com.android.internal.telephony.IIccPhoneBook$Stub$Proxy: boolean updateAdnRecordsInEfByIndex(int,java.lang.String,java.lang.String,int,java.lang.String)>
	<com.android.internal.telephony.IIccPhoneBook$Stub$Proxy: boolean updateAdnRecordsInEfByIndexForSubscriber(int,int,java.lang.String,java.lang.String,int,java.lang.String)>
	<com.android.internal.telephony.IIccPhoneBook$Stub$Proxy: boolean updateAdnRecordsInEfBySearch(int,java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String)>
	<com.android.internal.telephony.IIccPhoneBook$Stub$Proxy: boolean updateAdnRecordsInEfBySearchForSubscriber(int,int,java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String)>

Name: sip
StubClassName: android.net.sip.ISipService
isAvaliable: true
Methods : 11 
	<android.net.sip.ISipService$Stub$Proxy: android.os.IBinder asBinder()>
	<android.net.sip.ISipService$Stub$Proxy: void close(java.lang.String,java.lang.String)>
	<android.net.sip.ISipService$Stub$Proxy: android.net.sip.ISipSession createSession(android.net.sip.SipProfile,android.net.sip.ISipSessionListener,java.lang.String)>
	<android.net.sip.ISipService$Stub$Proxy: java.lang.String getInterfaceDescriptor()>
	<android.net.sip.ISipService$Stub$Proxy: android.net.sip.ISipSession getPendingSession(java.lang.String,java.lang.String)>
	<android.net.sip.ISipService$Stub$Proxy: java.util.List getProfiles(java.lang.String)>
	<android.net.sip.ISipService$Stub$Proxy: boolean isOpened(java.lang.String,java.lang.String)>
	<android.net.sip.ISipService$Stub$Proxy: boolean isRegistered(java.lang.String,java.lang.String)>
	<android.net.sip.ISipService$Stub$Proxy: void open(android.net.sip.SipProfile,java.lang.String)>
	<android.net.sip.ISipService$Stub$Proxy: void open3(android.net.sip.SipProfile,android.app.PendingIntent,android.net.sip.ISipSessionListener,java.lang.String)>
	<android.net.sip.ISipService$Stub$Proxy: void setRegistrationListener(java.lang.String,android.net.sip.ISipSessionListener,java.lang.String)>

Name: slice
StubClassName: android.app.slice.ISliceManager
isAvaliable: true
Methods : 13 
	<android.app.slice.ISliceManager$Stub$Proxy: void applyRestore([B,int)>
	<android.app.slice.ISliceManager$Stub$Proxy: android.os.IBinder asBinder()>
	<android.app.slice.ISliceManager$Stub$Proxy: int checkSlicePermission(android.net.Uri,java.lang.String,java.lang.String,int,int,[Ljava.lang.String;)>
	<android.app.slice.ISliceManager$Stub$Proxy: [B getBackupPayload(int)>
	<android.app.slice.ISliceManager$Stub$Proxy: java.lang.String getInterfaceDescriptor()>
	<android.app.slice.ISliceManager$Stub$Proxy: [Landroid.net.Uri; getPinnedSlices(java.lang.String)>
	<android.app.slice.ISliceManager$Stub$Proxy: [Landroid.app.slice.SliceSpec; getPinnedSpecs(android.net.Uri,java.lang.String)>
	<android.app.slice.ISliceManager$Stub$Proxy: void grantPermissionFromUser(android.net.Uri,java.lang.String,java.lang.String,boolean)>
	<android.app.slice.ISliceManager$Stub$Proxy: void grantSlicePermission(java.lang.String,java.lang.String,android.net.Uri)>
	<android.app.slice.ISliceManager$Stub$Proxy: boolean hasSliceAccess(java.lang.String)>
	<android.app.slice.ISliceManager$Stub$Proxy: void pinSlice(java.lang.String,android.net.Uri,[Landroid.app.slice.SliceSpec;,android.os.IBinder)>
	<android.app.slice.ISliceManager$Stub$Proxy: void revokeSlicePermission(java.lang.String,java.lang.String,android.net.Uri)>
	<android.app.slice.ISliceManager$Stub$Proxy: void unpinSlice(java.lang.String,android.net.Uri,android.os.IBinder)>

Name: soundtrigger
StubClassName: com.android.internal.app.ISoundTriggerService
isAvaliable: true
Methods : 18 
	<com.android.internal.app.ISoundTriggerService$Stub$Proxy: android.os.IBinder asBinder()>
	<com.android.internal.app.ISoundTriggerService$Stub$Proxy: void deleteSoundModel(android.os.ParcelUuid)>
	<com.android.internal.app.ISoundTriggerService$Stub$Proxy: java.lang.String getInterfaceDescriptor()>
	<com.android.internal.app.ISoundTriggerService$Stub$Proxy: int getModelState(android.os.ParcelUuid)>
	<com.android.internal.app.ISoundTriggerService$Stub$Proxy: android.hardware.soundtrigger.SoundTrigger$ModuleProperties getModuleProperties()>
	<com.android.internal.app.ISoundTriggerService$Stub$Proxy: int getParameter(android.os.ParcelUuid,int)>
	<com.android.internal.app.ISoundTriggerService$Stub$Proxy: android.hardware.soundtrigger.SoundTrigger$GenericSoundModel getSoundModel(android.os.ParcelUuid)>
	<com.android.internal.app.ISoundTriggerService$Stub$Proxy: boolean isRecognitionActive(android.os.ParcelUuid)>
	<com.android.internal.app.ISoundTriggerService$Stub$Proxy: int loadGenericSoundModel(android.hardware.soundtrigger.SoundTrigger$GenericSoundModel)>
	<com.android.internal.app.ISoundTriggerService$Stub$Proxy: int loadKeyphraseSoundModel(android.hardware.soundtrigger.SoundTrigger$KeyphraseSoundModel)>
	<com.android.internal.app.ISoundTriggerService$Stub$Proxy: android.hardware.soundtrigger.SoundTrigger$ModelParamRange queryParameter(android.os.ParcelUuid,int)>
	<com.android.internal.app.ISoundTriggerService$Stub$Proxy: int setParameter(android.os.ParcelUuid,int,int)>
	<com.android.internal.app.ISoundTriggerService$Stub$Proxy: int startRecognition(android.os.ParcelUuid,android.hardware.soundtrigger.IRecognitionStatusCallback,android.hardware.soundtrigger.SoundTrigger$RecognitionConfig)>
	<com.android.internal.app.ISoundTriggerService$Stub$Proxy: int startRecognitionForService(android.os.ParcelUuid,android.os.Bundle,android.content.ComponentName,android.hardware.soundtrigger.SoundTrigger$RecognitionConfig)>
	<com.android.internal.app.ISoundTriggerService$Stub$Proxy: int stopRecognition(android.os.ParcelUuid,android.hardware.soundtrigger.IRecognitionStatusCallback)>
	<com.android.internal.app.ISoundTriggerService$Stub$Proxy: int stopRecognitionForService(android.os.ParcelUuid)>
	<com.android.internal.app.ISoundTriggerService$Stub$Proxy: int unloadSoundModel(android.os.ParcelUuid)>
	<com.android.internal.app.ISoundTriggerService$Stub$Proxy: void updateSoundModel(android.hardware.soundtrigger.SoundTrigger$GenericSoundModel)>

Name: soundtrigger_middleware
StubClassName: null
isAvaliable: false
Methods : 0 

Name: stats
StubClassName: null
isAvaliable: false
Methods : 0 

Name: statscompanion
StubClassName: null
isAvaliable: false
Methods : 0 

Name: statsmanager
StubClassName: null
isAvaliable: false
Methods : 0 

Name: statusbar
StubClassName: com.android.internal.statusbar.IStatusBarService
isAvaliable: true
Methods : 56 
	<com.android.internal.statusbar.IStatusBarService$Stub$Proxy: void addTile(android.content.ComponentName)>
	<com.android.internal.statusbar.IStatusBarService$Stub$Proxy: android.os.IBinder asBinder()>
	<com.android.internal.statusbar.IStatusBarService$Stub$Proxy: void clearInlineReplyUriPermissions(java.lang.String)>
	<com.android.internal.statusbar.IStatusBarService$Stub$Proxy: void clearNotificationEffects()>
	<com.android.internal.statusbar.IStatusBarService$Stub$Proxy: void clickTile(android.content.ComponentName)>
	<com.android.internal.statusbar.IStatusBarService$Stub$Proxy: void collapsePanels()>
	<com.android.internal.statusbar.IStatusBarService$Stub$Proxy: void disable(int,android.os.IBinder,java.lang.String)>
	<com.android.internal.statusbar.IStatusBarService$Stub$Proxy: void disable2(int,android.os.IBinder,java.lang.String)>
	<com.android.internal.statusbar.IStatusBarService$Stub$Proxy: void disable2ForUser(int,android.os.IBinder,java.lang.String,int)>
	<com.android.internal.statusbar.IStatusBarService$Stub$Proxy: void disableForUser(int,android.os.IBinder,java.lang.String,int)>
	<com.android.internal.statusbar.IStatusBarService$Stub$Proxy: void dismissInattentiveSleepWarning(boolean)>
	<com.android.internal.statusbar.IStatusBarService$Stub$Proxy: void expandNotificationsPanel()>
	<com.android.internal.statusbar.IStatusBarService$Stub$Proxy: void expandSettingsPanel(java.lang.String)>
	<com.android.internal.statusbar.IStatusBarService$Stub$Proxy: [I getDisableFlags(android.os.IBinder,int)>
	<com.android.internal.statusbar.IStatusBarService$Stub$Proxy: java.lang.String getInterfaceDescriptor()>
	<com.android.internal.statusbar.IStatusBarService$Stub$Proxy: void grantInlineReplyUriPermission(java.lang.String,android.net.Uri,android.os.UserHandle,java.lang.String)>
	<com.android.internal.statusbar.IStatusBarService$Stub$Proxy: void handleSystemKey(int)>
	<com.android.internal.statusbar.IStatusBarService$Stub$Proxy: void hideAuthenticationDialog()>
	<com.android.internal.statusbar.IStatusBarService$Stub$Proxy: void hideCurrentInputMethodForBubbles()>
	<com.android.internal.statusbar.IStatusBarService$Stub$Proxy: boolean isTracing()>
	<com.android.internal.statusbar.IStatusBarService$Stub$Proxy: void onBiometricAuthenticated()>
	<com.android.internal.statusbar.IStatusBarService$Stub$Proxy: void onBiometricError(int,int,int)>
	<com.android.internal.statusbar.IStatusBarService$Stub$Proxy: void onBiometricHelp(java.lang.String)>
	<com.android.internal.statusbar.IStatusBarService$Stub$Proxy: void onBubbleNotificationSuppressionChanged(java.lang.String,boolean)>
	<com.android.internal.statusbar.IStatusBarService$Stub$Proxy: void onClearAllNotifications(int)>
	<com.android.internal.statusbar.IStatusBarService$Stub$Proxy: void onGlobalActionsHidden()>
	<com.android.internal.statusbar.IStatusBarService$Stub$Proxy: void onGlobalActionsShown()>
	<com.android.internal.statusbar.IStatusBarService$Stub$Proxy: void onNotificationActionClick(java.lang.String,int,android.app.Notification$Action,com.android.internal.statusbar.NotificationVisibility,boolean)>
	<com.android.internal.statusbar.IStatusBarService$Stub$Proxy: void onNotificationBubbleChanged(java.lang.String,boolean,int)>
	<com.android.internal.statusbar.IStatusBarService$Stub$Proxy: void onNotificationClear(java.lang.String,java.lang.String,int,int,java.lang.String,int,int,com.android.internal.statusbar.NotificationVisibility)>
	<com.android.internal.statusbar.IStatusBarService$Stub$Proxy: void onNotificationClick(java.lang.String,com.android.internal.statusbar.NotificationVisibility)>
	<com.android.internal.statusbar.IStatusBarService$Stub$Proxy: void onNotificationDirectReplied(java.lang.String)>
	<com.android.internal.statusbar.IStatusBarService$Stub$Proxy: void onNotificationError(java.lang.String,java.lang.String,int,int,int,java.lang.String,int)>
	<com.android.internal.statusbar.IStatusBarService$Stub$Proxy: void onNotificationExpansionChanged(java.lang.String,boolean,boolean,int)>
	<com.android.internal.statusbar.IStatusBarService$Stub$Proxy: void onNotificationSettingsViewed(java.lang.String)>
	<com.android.internal.statusbar.IStatusBarService$Stub$Proxy: void onNotificationSmartReplySent(java.lang.String,int,java.lang.CharSequence,int,boolean)>
	<com.android.internal.statusbar.IStatusBarService$Stub$Proxy: void onNotificationSmartSuggestionsAdded(java.lang.String,int,int,boolean,boolean)>
	<com.android.internal.statusbar.IStatusBarService$Stub$Proxy: void onNotificationVisibilityChanged([Lcom.android.internal.statusbar.NotificationVisibility;,[Lcom.android.internal.statusbar.NotificationVisibility;)>
	<com.android.internal.statusbar.IStatusBarService$Stub$Proxy: void onPanelHidden()>
	<com.android.internal.statusbar.IStatusBarService$Stub$Proxy: void onPanelRevealed(boolean,int)>
	<com.android.internal.statusbar.IStatusBarService$Stub$Proxy: void reboot(boolean)>
	<com.android.internal.statusbar.IStatusBarService$Stub$Proxy: com.android.internal.statusbar.RegisterStatusBarResult registerStatusBar(com.android.internal.statusbar.IStatusBar)>
	<com.android.internal.statusbar.IStatusBarService$Stub$Proxy: void remTile(android.content.ComponentName)>
	<com.android.internal.statusbar.IStatusBarService$Stub$Proxy: void removeIcon(java.lang.String)>
	<com.android.internal.statusbar.IStatusBarService$Stub$Proxy: void setIcon(java.lang.String,java.lang.String,int,int,java.lang.String)>
	<com.android.internal.statusbar.IStatusBarService$Stub$Proxy: void setIconVisibility(java.lang.String,boolean)>
	<com.android.internal.statusbar.IStatusBarService$Stub$Proxy: void setImeWindowStatus(int,android.os.IBinder,int,int,boolean,boolean)>
	<com.android.internal.statusbar.IStatusBarService$Stub$Proxy: void showAuthenticationDialog(android.os.Bundle,android.hardware.biometrics.IBiometricServiceReceiverInternal,int,boolean,int,java.lang.String,long,int)>
	<com.android.internal.statusbar.IStatusBarService$Stub$Proxy: void showInattentiveSleepWarning()>
	<com.android.internal.statusbar.IStatusBarService$Stub$Proxy: void showPinningEnterExitToast(boolean)>
	<com.android.internal.statusbar.IStatusBarService$Stub$Proxy: void showPinningEscapeToast()>
	<com.android.internal.statusbar.IStatusBarService$Stub$Proxy: void shutdown()>
	<com.android.internal.statusbar.IStatusBarService$Stub$Proxy: void startTracing()>
	<com.android.internal.statusbar.IStatusBarService$Stub$Proxy: void stopTracing()>
	<com.android.internal.statusbar.IStatusBarService$Stub$Proxy: void suppressAmbientDisplay(boolean)>
	<com.android.internal.statusbar.IStatusBarService$Stub$Proxy: void togglePanel()>

Name: storaged
StubClassName: null
isAvaliable: false
Methods : 0 

Name: storaged_pri
StubClassName: null
isAvaliable: false
Methods : 0 

Name: storagestats
StubClassName: android.app.usage.IStorageStatsManager
isAvaliable: true
Methods : 15 
	<android.app.usage.IStorageStatsManager$Stub$Proxy: android.os.IBinder asBinder()>
	<android.app.usage.IStorageStatsManager$Stub$Proxy: long getCacheBytes(java.lang.String,java.lang.String)>
	<android.app.usage.IStorageStatsManager$Stub$Proxy: long getCacheQuotaBytes(java.lang.String,int,java.lang.String)>
	<android.app.usage.IStorageStatsManager$Stub$Proxy: long getFreeBytes(java.lang.String,java.lang.String)>
	<android.app.usage.IStorageStatsManager$Stub$Proxy: java.lang.String getInterfaceDescriptor()>
	<android.app.usage.IStorageStatsManager$Stub$Proxy: long getTotalBytes(java.lang.String,java.lang.String)>
	<android.app.usage.IStorageStatsManager$Stub$Proxy: boolean isQuotaSupported(java.lang.String,java.lang.String)>
	<android.app.usage.IStorageStatsManager$Stub$Proxy: boolean isReservedSupported(java.lang.String,java.lang.String)>
	<android.app.usage.IStorageStatsManager$Stub$Proxy: android.content.pm.ParceledListSlice queryCratesForPackage(java.lang.String,java.lang.String,int,java.lang.String)>
	<android.app.usage.IStorageStatsManager$Stub$Proxy: android.content.pm.ParceledListSlice queryCratesForUid(java.lang.String,int,java.lang.String)>
	<android.app.usage.IStorageStatsManager$Stub$Proxy: android.content.pm.ParceledListSlice queryCratesForUser(java.lang.String,int,java.lang.String)>
	<android.app.usage.IStorageStatsManager$Stub$Proxy: android.app.usage.ExternalStorageStats queryExternalStatsForUser(java.lang.String,int,java.lang.String)>
	<android.app.usage.IStorageStatsManager$Stub$Proxy: android.app.usage.StorageStats queryStatsForPackage(java.lang.String,java.lang.String,int,java.lang.String)>
	<android.app.usage.IStorageStatsManager$Stub$Proxy: android.app.usage.StorageStats queryStatsForUid(java.lang.String,int,java.lang.String)>
	<android.app.usage.IStorageStatsManager$Stub$Proxy: android.app.usage.StorageStats queryStatsForUser(java.lang.String,int,java.lang.String)>

Name: suspend_control
StubClassName: null
isAvaliable: false
Methods : 0 

Name: system_config
StubClassName: null
isAvaliable: false
Methods : 0 

Name: system_update
StubClassName: null
isAvaliable: false
Methods : 0 

Name: telecom
StubClassName: com.android.internal.telecom.ITelecomService
isAvaliable: true
Methods : 64 
	<com.android.internal.telecom.ITelecomService$Stub$Proxy: void acceptHandover(android.net.Uri,int,android.telecom.PhoneAccountHandle)>
	<com.android.internal.telecom.ITelecomService$Stub$Proxy: void acceptRingingCall(java.lang.String)>
	<com.android.internal.telecom.ITelecomService$Stub$Proxy: void acceptRingingCallWithVideoState(java.lang.String,int)>
	<com.android.internal.telecom.ITelecomService$Stub$Proxy: void addNewIncomingCall(android.telecom.PhoneAccountHandle,android.os.Bundle)>
	<com.android.internal.telecom.ITelecomService$Stub$Proxy: void addNewIncomingConference(android.telecom.PhoneAccountHandle,android.os.Bundle)>
	<com.android.internal.telecom.ITelecomService$Stub$Proxy: void addNewUnknownCall(android.telecom.PhoneAccountHandle,android.os.Bundle)>
	<com.android.internal.telecom.ITelecomService$Stub$Proxy: void addOrRemoveTestCallCompanionApp(java.lang.String,boolean)>
	<com.android.internal.telecom.ITelecomService$Stub$Proxy: android.os.IBinder asBinder()>
	<com.android.internal.telecom.ITelecomService$Stub$Proxy: void cancelMissedCallsNotification(java.lang.String)>
	<com.android.internal.telecom.ITelecomService$Stub$Proxy: void clearAccounts(java.lang.String)>
	<com.android.internal.telecom.ITelecomService$Stub$Proxy: android.content.Intent createLaunchEmergencyDialerIntent(java.lang.String)>
	<com.android.internal.telecom.ITelecomService$Stub$Proxy: android.content.Intent createManageBlockedNumbersIntent()>
	<com.android.internal.telecom.ITelecomService$Stub$Proxy: android.telecom.TelecomAnalytics dumpCallAnalytics()>
	<com.android.internal.telecom.ITelecomService$Stub$Proxy: boolean enablePhoneAccount(android.telecom.PhoneAccountHandle,boolean)>
	<com.android.internal.telecom.ITelecomService$Stub$Proxy: boolean endCall(java.lang.String)>
	<com.android.internal.telecom.ITelecomService$Stub$Proxy: android.net.Uri getAdnUriForPhoneAccount(android.telecom.PhoneAccountHandle,java.lang.String)>
	<com.android.internal.telecom.ITelecomService$Stub$Proxy: java.util.List getAllPhoneAccountHandles()>
	<com.android.internal.telecom.ITelecomService$Stub$Proxy: java.util.List getAllPhoneAccounts()>
	<com.android.internal.telecom.ITelecomService$Stub$Proxy: int getAllPhoneAccountsCount()>
	<com.android.internal.telecom.ITelecomService$Stub$Proxy: java.util.List getCallCapablePhoneAccounts(boolean,java.lang.String,java.lang.String)>
	<com.android.internal.telecom.ITelecomService$Stub$Proxy: int getCallState()>
	<com.android.internal.telecom.ITelecomService$Stub$Proxy: int getCurrentTtyMode(java.lang.String,java.lang.String)>
	<com.android.internal.telecom.ITelecomService$Stub$Proxy: java.lang.String getDefaultDialerPackage()>
	<com.android.internal.telecom.ITelecomService$Stub$Proxy: java.lang.String getDefaultDialerPackageForUser(int)>
	<com.android.internal.telecom.ITelecomService$Stub$Proxy: android.telecom.PhoneAccountHandle getDefaultOutgoingPhoneAccount(java.lang.String,java.lang.String,java.lang.String)>
	<com.android.internal.telecom.ITelecomService$Stub$Proxy: android.content.ComponentName getDefaultPhoneApp()>
	<com.android.internal.telecom.ITelecomService$Stub$Proxy: java.lang.String getInterfaceDescriptor()>
	<com.android.internal.telecom.ITelecomService$Stub$Proxy: java.lang.String getLine1Number(android.telecom.PhoneAccountHandle,java.lang.String,java.lang.String)>
	<com.android.internal.telecom.ITelecomService$Stub$Proxy: android.telecom.PhoneAccount getPhoneAccount(android.telecom.PhoneAccountHandle)>
	<com.android.internal.telecom.ITelecomService$Stub$Proxy: java.util.List getPhoneAccountsForPackage(java.lang.String)>
	<com.android.internal.telecom.ITelecomService$Stub$Proxy: java.util.List getPhoneAccountsSupportingScheme(java.lang.String,java.lang.String)>
	<com.android.internal.telecom.ITelecomService$Stub$Proxy: java.util.List getSelfManagedPhoneAccounts(java.lang.String,java.lang.String)>
	<com.android.internal.telecom.ITelecomService$Stub$Proxy: android.telecom.PhoneAccountHandle getSimCallManager(int)>
	<com.android.internal.telecom.ITelecomService$Stub$Proxy: android.telecom.PhoneAccountHandle getSimCallManagerForUser(int)>
	<com.android.internal.telecom.ITelecomService$Stub$Proxy: java.lang.String getSystemDialerPackage()>
	<com.android.internal.telecom.ITelecomService$Stub$Proxy: android.telecom.PhoneAccountHandle getUserSelectedOutgoingPhoneAccount(java.lang.String)>
	<com.android.internal.telecom.ITelecomService$Stub$Proxy: java.lang.String getVoiceMailNumber(android.telecom.PhoneAccountHandle,java.lang.String,java.lang.String)>
	<com.android.internal.telecom.ITelecomService$Stub$Proxy: void handleCallIntent(android.content.Intent,java.lang.String)>
	<com.android.internal.telecom.ITelecomService$Stub$Proxy: boolean handlePinMmi(java.lang.String,java.lang.String)>
	<com.android.internal.telecom.ITelecomService$Stub$Proxy: boolean handlePinMmiForPhoneAccount(android.telecom.PhoneAccountHandle,java.lang.String,java.lang.String)>
	<com.android.internal.telecom.ITelecomService$Stub$Proxy: boolean isInCall(java.lang.String,java.lang.String)>
	<com.android.internal.telecom.ITelecomService$Stub$Proxy: boolean isInEmergencyCall()>
	<com.android.internal.telecom.ITelecomService$Stub$Proxy: boolean isInManagedCall(java.lang.String,java.lang.String)>
	<com.android.internal.telecom.ITelecomService$Stub$Proxy: boolean isIncomingCallPermitted(android.telecom.PhoneAccountHandle)>
	<com.android.internal.telecom.ITelecomService$Stub$Proxy: boolean isOutgoingCallPermitted(android.telecom.PhoneAccountHandle)>
	<com.android.internal.telecom.ITelecomService$Stub$Proxy: boolean isRinging(java.lang.String)>
	<com.android.internal.telecom.ITelecomService$Stub$Proxy: boolean isTtySupported(java.lang.String,java.lang.String)>
	<com.android.internal.telecom.ITelecomService$Stub$Proxy: boolean isVoiceMailNumber(android.telecom.PhoneAccountHandle,java.lang.String,java.lang.String,java.lang.String)>
	<com.android.internal.telecom.ITelecomService$Stub$Proxy: void placeCall(android.net.Uri,android.os.Bundle,java.lang.String,java.lang.String)>
	<com.android.internal.telecom.ITelecomService$Stub$Proxy: void registerPhoneAccount(android.telecom.PhoneAccount)>
	<com.android.internal.telecom.ITelecomService$Stub$Proxy: boolean setDefaultDialer(java.lang.String)>
	<com.android.internal.telecom.ITelecomService$Stub$Proxy: void setSystemDialer(android.content.ComponentName)>
	<com.android.internal.telecom.ITelecomService$Stub$Proxy: void setTestDefaultCallRedirectionApp(java.lang.String)>
	<com.android.internal.telecom.ITelecomService$Stub$Proxy: void setTestDefaultCallScreeningApp(java.lang.String)>
	<com.android.internal.telecom.ITelecomService$Stub$Proxy: void setTestDefaultDialer(java.lang.String)>
	<com.android.internal.telecom.ITelecomService$Stub$Proxy: void setTestEmergencyPhoneAccountPackageNameFilter(java.lang.String)>
	<com.android.internal.telecom.ITelecomService$Stub$Proxy: void setTestPhoneAcctSuggestionComponent(java.lang.String)>
	<com.android.internal.telecom.ITelecomService$Stub$Proxy: void setUserSelectedOutgoingPhoneAccount(android.telecom.PhoneAccountHandle)>
	<com.android.internal.telecom.ITelecomService$Stub$Proxy: void showInCallScreen(boolean,java.lang.String,java.lang.String)>
	<com.android.internal.telecom.ITelecomService$Stub$Proxy: void silenceRinger(java.lang.String)>
	<com.android.internal.telecom.ITelecomService$Stub$Proxy: void startConference(java.util.List,android.os.Bundle,java.lang.String)>
	<com.android.internal.telecom.ITelecomService$Stub$Proxy: void stopBlockSuppression()>
	<com.android.internal.telecom.ITelecomService$Stub$Proxy: void unregisterPhoneAccount(android.telecom.PhoneAccountHandle)>
	<com.android.internal.telecom.ITelecomService$Stub$Proxy: void waitOnHandlers()>

Name: telephony.registry
StubClassName: com.android.internal.telephony.ITelephonyRegistry
isAvaliable: true
Methods : 44 
	<com.android.internal.telephony.ITelephonyRegistry$Stub$Proxy: void addOnOpportunisticSubscriptionsChangedListener(java.lang.String,java.lang.String,com.android.internal.telephony.IOnSubscriptionsChangedListener)>
	<com.android.internal.telephony.ITelephonyRegistry$Stub$Proxy: void addOnSubscriptionsChangedListener(java.lang.String,java.lang.String,com.android.internal.telephony.IOnSubscriptionsChangedListener)>
	<com.android.internal.telephony.ITelephonyRegistry$Stub$Proxy: android.os.IBinder asBinder()>
	<com.android.internal.telephony.ITelephonyRegistry$Stub$Proxy: java.lang.String getInterfaceDescriptor()>
	<com.android.internal.telephony.ITelephonyRegistry$Stub$Proxy: void listen(java.lang.String,com.android.internal.telephony.IPhoneStateListener,int,boolean)>
	<com.android.internal.telephony.ITelephonyRegistry$Stub$Proxy: void listenForSubscriber(int,java.lang.String,java.lang.String,com.android.internal.telephony.IPhoneStateListener,int,boolean)>
	<com.android.internal.telephony.ITelephonyRegistry$Stub$Proxy: void listenWithFeature(java.lang.String,java.lang.String,com.android.internal.telephony.IPhoneStateListener,int,boolean)>
	<com.android.internal.telephony.ITelephonyRegistry$Stub$Proxy: void notifyActiveDataSubIdChanged(int)>
	<com.android.internal.telephony.ITelephonyRegistry$Stub$Proxy: void notifyBarringInfoChanged(int,int,android.telephony.BarringInfo)>
	<com.android.internal.telephony.ITelephonyRegistry$Stub$Proxy: void notifyCallForwardingChanged(boolean)>
	<com.android.internal.telephony.ITelephonyRegistry$Stub$Proxy: void notifyCallForwardingChangedForSubscriber(int,boolean)>
	<com.android.internal.telephony.ITelephonyRegistry$Stub$Proxy: void notifyCallQualityChanged(android.telephony.CallQuality,int,int,int)>
	<com.android.internal.telephony.ITelephonyRegistry$Stub$Proxy: void notifyCallState(int,int,int,java.lang.String)>
	<com.android.internal.telephony.ITelephonyRegistry$Stub$Proxy: void notifyCallStateForAllSubs(int,java.lang.String)>
	<com.android.internal.telephony.ITelephonyRegistry$Stub$Proxy: void notifyCarrierNetworkChange(boolean)>
	<com.android.internal.telephony.ITelephonyRegistry$Stub$Proxy: void notifyCellInfo(java.util.List)>
	<com.android.internal.telephony.ITelephonyRegistry$Stub$Proxy: void notifyCellInfoForSubscriber(int,java.util.List)>
	<com.android.internal.telephony.ITelephonyRegistry$Stub$Proxy: void notifyCellLocation(android.telephony.CellIdentity)>
	<com.android.internal.telephony.ITelephonyRegistry$Stub$Proxy: void notifyCellLocationForSubscriber(int,android.telephony.CellIdentity)>
	<com.android.internal.telephony.ITelephonyRegistry$Stub$Proxy: void notifyDataActivity(int)>
	<com.android.internal.telephony.ITelephonyRegistry$Stub$Proxy: void notifyDataActivityForSubscriber(int,int)>
	<com.android.internal.telephony.ITelephonyRegistry$Stub$Proxy: void notifyDataConnectionFailed(java.lang.String)>
	<com.android.internal.telephony.ITelephonyRegistry$Stub$Proxy: void notifyDataConnectionForSubscriber(int,int,int,android.telephony.PreciseDataConnectionState)>
	<com.android.internal.telephony.ITelephonyRegistry$Stub$Proxy: void notifyDisconnectCause(int,int,int,int)>
	<com.android.internal.telephony.ITelephonyRegistry$Stub$Proxy: void notifyDisplayInfoChanged(int,int,android.telephony.TelephonyDisplayInfo)>
	<com.android.internal.telephony.ITelephonyRegistry$Stub$Proxy: void notifyEmergencyNumberList(int,int)>
	<com.android.internal.telephony.ITelephonyRegistry$Stub$Proxy: void notifyImsDisconnectCause(int,android.telephony.ims.ImsReasonInfo)>
	<com.android.internal.telephony.ITelephonyRegistry$Stub$Proxy: void notifyMessageWaitingChangedForPhoneId(int,int,boolean)>
	<com.android.internal.telephony.ITelephonyRegistry$Stub$Proxy: void notifyOemHookRawEventForSubscriber(int,int,[B)>
	<com.android.internal.telephony.ITelephonyRegistry$Stub$Proxy: void notifyOpportunisticSubscriptionInfoChanged()>
	<com.android.internal.telephony.ITelephonyRegistry$Stub$Proxy: void notifyOutgoingEmergencyCall(int,int,android.telephony.emergency.EmergencyNumber)>
	<com.android.internal.telephony.ITelephonyRegistry$Stub$Proxy: void notifyOutgoingEmergencySms(int,int,android.telephony.emergency.EmergencyNumber)>
	<com.android.internal.telephony.ITelephonyRegistry$Stub$Proxy: void notifyPhoneCapabilityChanged(android.telephony.PhoneCapability)>
	<com.android.internal.telephony.ITelephonyRegistry$Stub$Proxy: void notifyPreciseCallState(int,int,int,int,int)>
	<com.android.internal.telephony.ITelephonyRegistry$Stub$Proxy: void notifyPreciseDataConnectionFailed(int,int,int,java.lang.String,int)>
	<com.android.internal.telephony.ITelephonyRegistry$Stub$Proxy: void notifyRadioPowerStateChanged(int,int,int)>
	<com.android.internal.telephony.ITelephonyRegistry$Stub$Proxy: void notifyRegistrationFailed(int,int,android.telephony.CellIdentity,java.lang.String,int,int,int)>
	<com.android.internal.telephony.ITelephonyRegistry$Stub$Proxy: void notifyServiceStateForPhoneId(int,int,android.telephony.ServiceState)>
	<com.android.internal.telephony.ITelephonyRegistry$Stub$Proxy: void notifySignalStrengthForPhoneId(int,int,android.telephony.SignalStrength)>
	<com.android.internal.telephony.ITelephonyRegistry$Stub$Proxy: void notifySimActivationStateChangedForPhoneId(int,int,int,int)>
	<com.android.internal.telephony.ITelephonyRegistry$Stub$Proxy: void notifySrvccStateChanged(int,int)>
	<com.android.internal.telephony.ITelephonyRegistry$Stub$Proxy: void notifySubscriptionInfoChanged()>
	<com.android.internal.telephony.ITelephonyRegistry$Stub$Proxy: void notifyUserMobileDataStateChangedForPhoneId(int,int,boolean)>
	<com.android.internal.telephony.ITelephonyRegistry$Stub$Proxy: void removeOnSubscriptionsChangedListener(java.lang.String,com.android.internal.telephony.IOnSubscriptionsChangedListener)>

Name: telephony_ims
StubClassName: android.telephony.ims.aidl.IImsRcsController
isAvaliable: true
Methods : 14 
	<android.telephony.ims.aidl.IImsRcsController$Stub$Proxy: android.os.IBinder asBinder()>
	<android.telephony.ims.aidl.IImsRcsController$Stub$Proxy: void getImsRcsRegistrationState(int,com.android.internal.telephony.IIntegerConsumer)>
	<android.telephony.ims.aidl.IImsRcsController$Stub$Proxy: void getImsRcsRegistrationTransportType(int,com.android.internal.telephony.IIntegerConsumer)>
	<android.telephony.ims.aidl.IImsRcsController$Stub$Proxy: java.lang.String getInterfaceDescriptor()>
	<android.telephony.ims.aidl.IImsRcsController$Stub$Proxy: int getUcePublishState(int)>
	<android.telephony.ims.aidl.IImsRcsController$Stub$Proxy: boolean isAvailable(int,int)>
	<android.telephony.ims.aidl.IImsRcsController$Stub$Proxy: boolean isCapable(int,int,int)>
	<android.telephony.ims.aidl.IImsRcsController$Stub$Proxy: boolean isUceSettingEnabled(int,java.lang.String,java.lang.String)>
	<android.telephony.ims.aidl.IImsRcsController$Stub$Proxy: void registerImsRegistrationCallback(int,android.telephony.ims.aidl.IImsRegistrationCallback)>
	<android.telephony.ims.aidl.IImsRcsController$Stub$Proxy: void registerRcsAvailabilityCallback(int,android.telephony.ims.aidl.IImsCapabilityCallback)>
	<android.telephony.ims.aidl.IImsRcsController$Stub$Proxy: void requestCapabilities(int,java.lang.String,java.lang.String,java.util.List,android.telephony.ims.aidl.IRcsUceControllerCallback)>
	<android.telephony.ims.aidl.IImsRcsController$Stub$Proxy: void setUceSettingEnabled(int,boolean)>
	<android.telephony.ims.aidl.IImsRcsController$Stub$Proxy: void unregisterImsRegistrationCallback(int,android.telephony.ims.aidl.IImsRegistrationCallback)>
	<android.telephony.ims.aidl.IImsRcsController$Stub$Proxy: void unregisterRcsAvailabilityCallback(int,android.telephony.ims.aidl.IImsCapabilityCallback)>

Name: testharness
StubClassName: null
isAvaliable: false
Methods : 0 

Name: tethering
StubClassName: android.net.ITetheringConnector
isAvaliable: true
Methods : 12 
	<android.net.ITetheringConnector$Stub$Proxy: android.os.IBinder asBinder()>
	<android.net.ITetheringConnector$Stub$Proxy: java.lang.String getInterfaceDescriptor()>
	<android.net.ITetheringConnector$Stub$Proxy: void isTetheringSupported(java.lang.String,android.net.IIntResultListener)>
	<android.net.ITetheringConnector$Stub$Proxy: void registerTetheringEventCallback(android.net.ITetheringEventCallback,java.lang.String)>
	<android.net.ITetheringConnector$Stub$Proxy: void requestLatestTetheringEntitlementResult(int,android.os.ResultReceiver,boolean,java.lang.String)>
	<android.net.ITetheringConnector$Stub$Proxy: void setUsbTethering(boolean,java.lang.String,android.net.IIntResultListener)>
	<android.net.ITetheringConnector$Stub$Proxy: void startTethering(android.net.TetheringRequestParcel,java.lang.String,android.net.IIntResultListener)>
	<android.net.ITetheringConnector$Stub$Proxy: void stopAllTethering(java.lang.String,android.net.IIntResultListener)>
	<android.net.ITetheringConnector$Stub$Proxy: void stopTethering(int,java.lang.String,android.net.IIntResultListener)>
	<android.net.ITetheringConnector$Stub$Proxy: void tether(java.lang.String,java.lang.String,android.net.IIntResultListener)>
	<android.net.ITetheringConnector$Stub$Proxy: void unregisterTetheringEventCallback(android.net.ITetheringEventCallback,java.lang.String)>
	<android.net.ITetheringConnector$Stub$Proxy: void untether(java.lang.String,java.lang.String,android.net.IIntResultListener)>

Name: textclassification
StubClassName: android.service.textclassifier.ITextClassifierService
isAvaliable: true
Methods : 12 
	<android.service.textclassifier.ITextClassifierService$Stub$Proxy: android.os.IBinder asBinder()>
	<android.service.textclassifier.ITextClassifierService$Stub$Proxy: java.lang.String getInterfaceDescriptor()>
	<android.service.textclassifier.ITextClassifierService$Stub$Proxy: void onClassifyText(android.view.textclassifier.TextClassificationSessionId,android.view.textclassifier.TextClassification$Request,android.service.textclassifier.ITextClassifierCallback)>
	<android.service.textclassifier.ITextClassifierService$Stub$Proxy: void onConnectedStateChanged(int)>
	<android.service.textclassifier.ITextClassifierService$Stub$Proxy: void onCreateTextClassificationSession(android.view.textclassifier.TextClassificationContext,android.view.textclassifier.TextClassificationSessionId)>
	<android.service.textclassifier.ITextClassifierService$Stub$Proxy: void onDestroyTextClassificationSession(android.view.textclassifier.TextClassificationSessionId)>
	<android.service.textclassifier.ITextClassifierService$Stub$Proxy: void onDetectLanguage(android.view.textclassifier.TextClassificationSessionId,android.view.textclassifier.TextLanguage$Request,android.service.textclassifier.ITextClassifierCallback)>
	<android.service.textclassifier.ITextClassifierService$Stub$Proxy: void onGenerateLinks(android.view.textclassifier.TextClassificationSessionId,android.view.textclassifier.TextLinks$Request,android.service.textclassifier.ITextClassifierCallback)>
	<android.service.textclassifier.ITextClassifierService$Stub$Proxy: void onSelectionEvent(android.view.textclassifier.TextClassificationSessionId,android.view.textclassifier.SelectionEvent)>
	<android.service.textclassifier.ITextClassifierService$Stub$Proxy: void onSuggestConversationActions(android.view.textclassifier.TextClassificationSessionId,android.view.textclassifier.ConversationActions$Request,android.service.textclassifier.ITextClassifierCallback)>
	<android.service.textclassifier.ITextClassifierService$Stub$Proxy: void onSuggestSelection(android.view.textclassifier.TextClassificationSessionId,android.view.textclassifier.TextSelection$Request,android.service.textclassifier.ITextClassifierCallback)>
	<android.service.textclassifier.ITextClassifierService$Stub$Proxy: void onTextClassifierEvent(android.view.textclassifier.TextClassificationSessionId,android.view.textclassifier.TextClassifierEvent)>

Name: textservices
StubClassName: com.android.internal.textservice.ITextServicesManager
isAvaliable: true
Methods : 8 
	<com.android.internal.textservice.ITextServicesManager$Stub$Proxy: android.os.IBinder asBinder()>
	<com.android.internal.textservice.ITextServicesManager$Stub$Proxy: void finishSpellCheckerService(int,com.android.internal.textservice.ISpellCheckerSessionListener)>
	<com.android.internal.textservice.ITextServicesManager$Stub$Proxy: android.view.textservice.SpellCheckerInfo getCurrentSpellChecker(int,java.lang.String)>
	<com.android.internal.textservice.ITextServicesManager$Stub$Proxy: android.view.textservice.SpellCheckerSubtype getCurrentSpellCheckerSubtype(int,boolean)>
	<com.android.internal.textservice.ITextServicesManager$Stub$Proxy: [Landroid.view.textservice.SpellCheckerInfo; getEnabledSpellCheckers(int)>
	<com.android.internal.textservice.ITextServicesManager$Stub$Proxy: java.lang.String getInterfaceDescriptor()>
	<com.android.internal.textservice.ITextServicesManager$Stub$Proxy: void getSpellCheckerService(int,java.lang.String,java.lang.String,com.android.internal.textservice.ITextServicesSessionListener,com.android.internal.textservice.ISpellCheckerSessionListener,android.os.Bundle)>
	<com.android.internal.textservice.ITextServicesManager$Stub$Proxy: boolean isSpellCheckerEnabled(int)>

Name: thermalservice
StubClassName: android.os.IThermalService
isAvaliable: true
Methods : 13 
	<android.os.IThermalService$Stub$Proxy: android.os.IBinder asBinder()>
	<android.os.IThermalService$Stub$Proxy: [Landroid.os.CoolingDevice; getCurrentCoolingDevices()>
	<android.os.IThermalService$Stub$Proxy: [Landroid.os.CoolingDevice; getCurrentCoolingDevicesWithType(int)>
	<android.os.IThermalService$Stub$Proxy: [Landroid.os.Temperature; getCurrentTemperatures()>
	<android.os.IThermalService$Stub$Proxy: [Landroid.os.Temperature; getCurrentTemperaturesWithType(int)>
	<android.os.IThermalService$Stub$Proxy: int getCurrentThermalStatus()>
	<android.os.IThermalService$Stub$Proxy: java.lang.String getInterfaceDescriptor()>
	<android.os.IThermalService$Stub$Proxy: float getThermalHeadroom(int)>
	<android.os.IThermalService$Stub$Proxy: boolean registerThermalEventListener(android.os.IThermalEventListener)>
	<android.os.IThermalService$Stub$Proxy: boolean registerThermalEventListenerWithType(android.os.IThermalEventListener,int)>
	<android.os.IThermalService$Stub$Proxy: boolean registerThermalStatusListener(android.os.IThermalStatusListener)>
	<android.os.IThermalService$Stub$Proxy: boolean unregisterThermalEventListener(android.os.IThermalEventListener)>
	<android.os.IThermalService$Stub$Proxy: boolean unregisterThermalStatusListener(android.os.IThermalStatusListener)>

Name: time_detector
StubClassName: null
isAvaliable: false
Methods : 0 

Name: time_zone_detector
StubClassName: null
isAvaliable: false
Methods : 0 

Name: trust
StubClassName: android.app.trust.ITrustManager
isAvaliable: true
Methods : 14 
	<android.app.trust.ITrustManager$Stub$Proxy: android.os.IBinder asBinder()>
	<android.app.trust.ITrustManager$Stub$Proxy: void clearAllBiometricRecognized(android.hardware.biometrics.BiometricSourceType)>
	<android.app.trust.ITrustManager$Stub$Proxy: java.lang.String getInterfaceDescriptor()>
	<android.app.trust.ITrustManager$Stub$Proxy: boolean isDeviceLocked(int)>
	<android.app.trust.ITrustManager$Stub$Proxy: boolean isDeviceSecure(int)>
	<android.app.trust.ITrustManager$Stub$Proxy: boolean isTrustUsuallyManaged(int)>
	<android.app.trust.ITrustManager$Stub$Proxy: void registerTrustListener(android.app.trust.ITrustListener)>
	<android.app.trust.ITrustManager$Stub$Proxy: void reportEnabledTrustAgentsChanged(int)>
	<android.app.trust.ITrustManager$Stub$Proxy: void reportKeyguardShowingChanged()>
	<android.app.trust.ITrustManager$Stub$Proxy: void reportUnlockAttempt(boolean,int)>
	<android.app.trust.ITrustManager$Stub$Proxy: void reportUnlockLockout(int,int)>
	<android.app.trust.ITrustManager$Stub$Proxy: void setDeviceLockedForUser(int,boolean)>
	<android.app.trust.ITrustManager$Stub$Proxy: void unlockedByBiometricForUser(int,android.hardware.biometrics.BiometricSourceType)>
	<android.app.trust.ITrustManager$Stub$Proxy: void unregisterTrustListener(android.app.trust.ITrustListener)>

Name: uce
StubClassName: null
isAvaliable: false
Methods : 0 

Name: uimode
StubClassName: android.app.IUiModeManager
isAvaliable: true
Methods : 15 
	<android.app.IUiModeManager$Stub$Proxy: android.os.IBinder asBinder()>
	<android.app.IUiModeManager$Stub$Proxy: void disableCarMode(int)>
	<android.app.IUiModeManager$Stub$Proxy: void disableCarModeByCallingPackage(int,java.lang.String)>
	<android.app.IUiModeManager$Stub$Proxy: void enableCarMode(int,int,java.lang.String)>
	<android.app.IUiModeManager$Stub$Proxy: int getCurrentModeType()>
	<android.app.IUiModeManager$Stub$Proxy: long getCustomNightModeEnd()>
	<android.app.IUiModeManager$Stub$Proxy: long getCustomNightModeStart()>
	<android.app.IUiModeManager$Stub$Proxy: java.lang.String getInterfaceDescriptor()>
	<android.app.IUiModeManager$Stub$Proxy: int getNightMode()>
	<android.app.IUiModeManager$Stub$Proxy: boolean isNightModeLocked()>
	<android.app.IUiModeManager$Stub$Proxy: boolean isUiModeLocked()>
	<android.app.IUiModeManager$Stub$Proxy: void setCustomNightModeEnd(long)>
	<android.app.IUiModeManager$Stub$Proxy: void setCustomNightModeStart(long)>
	<android.app.IUiModeManager$Stub$Proxy: void setNightMode(int)>
	<android.app.IUiModeManager$Stub$Proxy: boolean setNightModeActivated(boolean)>

Name: updatelock
StubClassName: null
isAvaliable: false
Methods : 0 

Name: uri_grants
StubClassName: android.app.IUriGrantsManager
isAvaliable: true
Methods : 8 
	<android.app.IUriGrantsManager$Stub$Proxy: android.os.IBinder asBinder()>
	<android.app.IUriGrantsManager$Stub$Proxy: void clearGrantedUriPermissions(java.lang.String,int)>
	<android.app.IUriGrantsManager$Stub$Proxy: android.content.pm.ParceledListSlice getGrantedUriPermissions(java.lang.String,int)>
	<android.app.IUriGrantsManager$Stub$Proxy: java.lang.String getInterfaceDescriptor()>
	<android.app.IUriGrantsManager$Stub$Proxy: android.content.pm.ParceledListSlice getUriPermissions(java.lang.String,boolean,boolean)>
	<android.app.IUriGrantsManager$Stub$Proxy: void grantUriPermissionFromOwner(android.os.IBinder,int,java.lang.String,android.net.Uri,int,int,int)>
	<android.app.IUriGrantsManager$Stub$Proxy: void releasePersistableUriPermission(android.net.Uri,int,java.lang.String,int)>
	<android.app.IUriGrantsManager$Stub$Proxy: void takePersistableUriPermission(android.net.Uri,int,java.lang.String,int)>

Name: usagestats
StubClassName: android.app.usage.IUsageStatsManager
isAvaliable: true
Methods : 28 
	<android.app.usage.IUsageStatsManager$Stub$Proxy: android.os.IBinder asBinder()>
	<android.app.usage.IUsageStatsManager$Stub$Proxy: void forceUsageSourceSettingRead()>
	<android.app.usage.IUsageStatsManager$Stub$Proxy: int getAppStandbyBucket(java.lang.String,java.lang.String,int)>
	<android.app.usage.IUsageStatsManager$Stub$Proxy: android.content.pm.ParceledListSlice getAppStandbyBuckets(java.lang.String,int)>
	<android.app.usage.IUsageStatsManager$Stub$Proxy: java.lang.String getInterfaceDescriptor()>
	<android.app.usage.IUsageStatsManager$Stub$Proxy: int getUsageSource()>
	<android.app.usage.IUsageStatsManager$Stub$Proxy: boolean isAppInactive(java.lang.String,int,java.lang.String)>
	<android.app.usage.IUsageStatsManager$Stub$Proxy: void onCarrierPrivilegedAppsChanged()>
	<android.app.usage.IUsageStatsManager$Stub$Proxy: android.content.pm.ParceledListSlice queryConfigurationStats(int,long,long,java.lang.String)>
	<android.app.usage.IUsageStatsManager$Stub$Proxy: android.content.pm.ParceledListSlice queryEventStats(int,long,long,java.lang.String)>
	<android.app.usage.IUsageStatsManager$Stub$Proxy: android.app.usage.UsageEvents queryEvents(long,long,java.lang.String)>
	<android.app.usage.IUsageStatsManager$Stub$Proxy: android.app.usage.UsageEvents queryEventsForPackage(long,long,java.lang.String)>
	<android.app.usage.IUsageStatsManager$Stub$Proxy: android.app.usage.UsageEvents queryEventsForPackageForUser(long,long,int,java.lang.String,java.lang.String)>
	<android.app.usage.IUsageStatsManager$Stub$Proxy: android.app.usage.UsageEvents queryEventsForUser(long,long,int,java.lang.String)>
	<android.app.usage.IUsageStatsManager$Stub$Proxy: android.content.pm.ParceledListSlice queryUsageStats(int,long,long,java.lang.String)>
	<android.app.usage.IUsageStatsManager$Stub$Proxy: void registerAppUsageLimitObserver(int,[Ljava.lang.String;,long,long,android.app.PendingIntent,java.lang.String)>
	<android.app.usage.IUsageStatsManager$Stub$Proxy: void registerAppUsageObserver(int,[Ljava.lang.String;,long,android.app.PendingIntent,java.lang.String)>
	<android.app.usage.IUsageStatsManager$Stub$Proxy: void registerUsageSessionObserver(int,[Ljava.lang.String;,long,long,android.app.PendingIntent,android.app.PendingIntent,java.lang.String)>
	<android.app.usage.IUsageStatsManager$Stub$Proxy: void reportChooserSelection(java.lang.String,int,java.lang.String,[Ljava.lang.String;,java.lang.String)>
	<android.app.usage.IUsageStatsManager$Stub$Proxy: void reportPastUsageStart(android.os.IBinder,java.lang.String,long,java.lang.String)>
	<android.app.usage.IUsageStatsManager$Stub$Proxy: void reportUsageStart(android.os.IBinder,java.lang.String,java.lang.String)>
	<android.app.usage.IUsageStatsManager$Stub$Proxy: void reportUsageStop(android.os.IBinder,java.lang.String,java.lang.String)>
	<android.app.usage.IUsageStatsManager$Stub$Proxy: void setAppInactive(java.lang.String,boolean,int)>
	<android.app.usage.IUsageStatsManager$Stub$Proxy: void setAppStandbyBucket(java.lang.String,int,int)>
	<android.app.usage.IUsageStatsManager$Stub$Proxy: void setAppStandbyBuckets(android.content.pm.ParceledListSlice,int)>
	<android.app.usage.IUsageStatsManager$Stub$Proxy: void unregisterAppUsageLimitObserver(int,java.lang.String)>
	<android.app.usage.IUsageStatsManager$Stub$Proxy: void unregisterAppUsageObserver(int,java.lang.String)>
	<android.app.usage.IUsageStatsManager$Stub$Proxy: void unregisterUsageSessionObserver(int,java.lang.String)>

Name: usb
StubClassName: android.hardware.usb.IUsbManager
isAvaliable: true
Methods : 35 
	<android.hardware.usb.IUsbManager$Stub$Proxy: void addAccessoryPackagesToPreferenceDenied(android.hardware.usb.UsbAccessory,[Ljava.lang.String;,android.os.UserHandle)>
	<android.hardware.usb.IUsbManager$Stub$Proxy: void addDevicePackagesToPreferenceDenied(android.hardware.usb.UsbDevice,[Ljava.lang.String;,android.os.UserHandle)>
	<android.hardware.usb.IUsbManager$Stub$Proxy: android.os.IBinder asBinder()>
	<android.hardware.usb.IUsbManager$Stub$Proxy: void clearDefaults(java.lang.String,int)>
	<android.hardware.usb.IUsbManager$Stub$Proxy: void enableContaminantDetection(java.lang.String,boolean)>
	<android.hardware.usb.IUsbManager$Stub$Proxy: android.os.ParcelFileDescriptor getControlFd(long)>
	<android.hardware.usb.IUsbManager$Stub$Proxy: android.hardware.usb.UsbAccessory getCurrentAccessory()>
	<android.hardware.usb.IUsbManager$Stub$Proxy: long getCurrentFunctions()>
	<android.hardware.usb.IUsbManager$Stub$Proxy: void getDeviceList(android.os.Bundle)>
	<android.hardware.usb.IUsbManager$Stub$Proxy: java.lang.String getInterfaceDescriptor()>
	<android.hardware.usb.IUsbManager$Stub$Proxy: android.hardware.usb.UsbPortStatus getPortStatus(java.lang.String)>
	<android.hardware.usb.IUsbManager$Stub$Proxy: java.util.List getPorts()>
	<android.hardware.usb.IUsbManager$Stub$Proxy: long getScreenUnlockedFunctions()>
	<android.hardware.usb.IUsbManager$Stub$Proxy: void grantAccessoryPermission(android.hardware.usb.UsbAccessory,int)>
	<android.hardware.usb.IUsbManager$Stub$Proxy: void grantDevicePermission(android.hardware.usb.UsbDevice,int)>
	<android.hardware.usb.IUsbManager$Stub$Proxy: boolean hasAccessoryPermission(android.hardware.usb.UsbAccessory)>
	<android.hardware.usb.IUsbManager$Stub$Proxy: boolean hasDefaults(java.lang.String,int)>
	<android.hardware.usb.IUsbManager$Stub$Proxy: boolean hasDevicePermission(android.hardware.usb.UsbDevice,java.lang.String)>
	<android.hardware.usb.IUsbManager$Stub$Proxy: boolean isFunctionEnabled(java.lang.String)>
	<android.hardware.usb.IUsbManager$Stub$Proxy: android.os.ParcelFileDescriptor openAccessory(android.hardware.usb.UsbAccessory)>
	<android.hardware.usb.IUsbManager$Stub$Proxy: android.os.ParcelFileDescriptor openDevice(java.lang.String,java.lang.String)>
	<android.hardware.usb.IUsbManager$Stub$Proxy: void removeAccessoryPackagesFromPreferenceDenied(android.hardware.usb.UsbAccessory,[Ljava.lang.String;,android.os.UserHandle)>
	<android.hardware.usb.IUsbManager$Stub$Proxy: void removeDevicePackagesFromPreferenceDenied(android.hardware.usb.UsbDevice,[Ljava.lang.String;,android.os.UserHandle)>
	<android.hardware.usb.IUsbManager$Stub$Proxy: void requestAccessoryPermission(android.hardware.usb.UsbAccessory,java.lang.String,android.app.PendingIntent)>
	<android.hardware.usb.IUsbManager$Stub$Proxy: void requestDevicePermission(android.hardware.usb.UsbDevice,java.lang.String,android.app.PendingIntent)>
	<android.hardware.usb.IUsbManager$Stub$Proxy: void resetUsbGadget()>
	<android.hardware.usb.IUsbManager$Stub$Proxy: void setAccessoryPackage(android.hardware.usb.UsbAccessory,java.lang.String,int)>
	<android.hardware.usb.IUsbManager$Stub$Proxy: void setAccessoryPersistentPermission(android.hardware.usb.UsbAccessory,int,android.os.UserHandle,boolean)>
	<android.hardware.usb.IUsbManager$Stub$Proxy: void setCurrentFunction(java.lang.String,boolean)>
	<android.hardware.usb.IUsbManager$Stub$Proxy: void setCurrentFunctions(long)>
	<android.hardware.usb.IUsbManager$Stub$Proxy: void setDevicePackage(android.hardware.usb.UsbDevice,java.lang.String,int)>
	<android.hardware.usb.IUsbManager$Stub$Proxy: void setDevicePersistentPermission(android.hardware.usb.UsbDevice,int,android.os.UserHandle,boolean)>
	<android.hardware.usb.IUsbManager$Stub$Proxy: void setPortRoles(java.lang.String,int,int)>
	<android.hardware.usb.IUsbManager$Stub$Proxy: void setScreenUnlockedFunctions(long)>
	<android.hardware.usb.IUsbManager$Stub$Proxy: void setUsbDeviceConnectionHandler(android.content.ComponentName)>

Name: user
StubClassName: android.os.IUserManager
isAvaliable: true
Methods : 77 
	<android.os.IUserManager$Stub$Proxy: void addUserRestrictionsListener(android.os.IUserRestrictionsListener)>
	<android.os.IUserManager$Stub$Proxy: android.os.IBinder asBinder()>
	<android.os.IUserManager$Stub$Proxy: boolean canAddMoreManagedProfiles(int,boolean)>
	<android.os.IUserManager$Stub$Proxy: boolean canAddMoreProfilesToUser(java.lang.String,int,boolean)>
	<android.os.IUserManager$Stub$Proxy: boolean canHaveRestrictedProfile(int)>
	<android.os.IUserManager$Stub$Proxy: void clearSeedAccountData()>
	<android.os.IUserManager$Stub$Proxy: android.content.pm.UserInfo createProfileForUserEvenWhenDisallowedWithThrow(java.lang.String,java.lang.String,int,int,[Ljava.lang.String;)>
	<android.os.IUserManager$Stub$Proxy: android.content.pm.UserInfo createProfileForUserWithThrow(java.lang.String,java.lang.String,int,int,[Ljava.lang.String;)>
	<android.os.IUserManager$Stub$Proxy: android.content.pm.UserInfo createRestrictedProfileWithThrow(java.lang.String,int)>
	<android.os.IUserManager$Stub$Proxy: android.content.pm.UserInfo createUserWithThrow(java.lang.String,java.lang.String,int)>
	<android.os.IUserManager$Stub$Proxy: void evictCredentialEncryptionKey(int)>
	<android.os.IUserManager$Stub$Proxy: android.content.pm.UserInfo findCurrentGuestUser()>
	<android.os.IUserManager$Stub$Proxy: android.os.Bundle getApplicationRestrictions(java.lang.String)>
	<android.os.IUserManager$Stub$Proxy: android.os.Bundle getApplicationRestrictionsForUser(java.lang.String,int)>
	<android.os.IUserManager$Stub$Proxy: int getCredentialOwnerProfile(int)>
	<android.os.IUserManager$Stub$Proxy: android.os.Bundle getDefaultGuestRestrictions()>
	<android.os.IUserManager$Stub$Proxy: java.lang.String getInterfaceDescriptor()>
	<android.os.IUserManager$Stub$Proxy: android.content.pm.UserInfo getPrimaryUser()>
	<android.os.IUserManager$Stub$Proxy: [I getProfileIds(int,boolean)>
	<android.os.IUserManager$Stub$Proxy: android.content.pm.UserInfo getProfileParent(int)>
	<android.os.IUserManager$Stub$Proxy: int getProfileParentId(int)>
	<android.os.IUserManager$Stub$Proxy: java.util.List getProfiles(int,boolean)>
	<android.os.IUserManager$Stub$Proxy: java.lang.String getSeedAccountName()>
	<android.os.IUserManager$Stub$Proxy: android.os.PersistableBundle getSeedAccountOptions()>
	<android.os.IUserManager$Stub$Proxy: java.lang.String getSeedAccountType()>
	<android.os.IUserManager$Stub$Proxy: java.lang.String getUserAccount(int)>
	<android.os.IUserManager$Stub$Proxy: int getUserBadgeColorResId(int)>
	<android.os.IUserManager$Stub$Proxy: int getUserBadgeDarkColorResId(int)>
	<android.os.IUserManager$Stub$Proxy: int getUserBadgeLabelResId(int)>
	<android.os.IUserManager$Stub$Proxy: int getUserBadgeNoBackgroundResId(int)>
	<android.os.IUserManager$Stub$Proxy: int getUserBadgeResId(int)>
	<android.os.IUserManager$Stub$Proxy: long getUserCreationTime(int)>
	<android.os.IUserManager$Stub$Proxy: int getUserHandle(int)>
	<android.os.IUserManager$Stub$Proxy: android.os.ParcelFileDescriptor getUserIcon(int)>
	<android.os.IUserManager$Stub$Proxy: int getUserIconBadgeResId(int)>
	<android.os.IUserManager$Stub$Proxy: android.content.pm.UserInfo getUserInfo(int)>
	<android.os.IUserManager$Stub$Proxy: java.lang.String getUserName()>
	<android.os.IUserManager$Stub$Proxy: int getUserRestrictionSource(java.lang.String,int)>
	<android.os.IUserManager$Stub$Proxy: java.util.List getUserRestrictionSources(java.lang.String,int)>
	<android.os.IUserManager$Stub$Proxy: android.os.Bundle getUserRestrictions(int)>
	<android.os.IUserManager$Stub$Proxy: int getUserSerialNumber(int)>
	<android.os.IUserManager$Stub$Proxy: long getUserStartRealtime()>
	<android.os.IUserManager$Stub$Proxy: long getUserUnlockRealtime()>
	<android.os.IUserManager$Stub$Proxy: java.util.List getUsers(boolean,boolean,boolean)>
	<android.os.IUserManager$Stub$Proxy: boolean hasBadge(int)>
	<android.os.IUserManager$Stub$Proxy: boolean hasBaseUserRestriction(java.lang.String,int)>
	<android.os.IUserManager$Stub$Proxy: boolean hasRestrictedProfiles()>
	<android.os.IUserManager$Stub$Proxy: boolean hasUserRestriction(java.lang.String,int)>
	<android.os.IUserManager$Stub$Proxy: boolean hasUserRestrictionOnAnyUser(java.lang.String)>
	<android.os.IUserManager$Stub$Proxy: boolean isDemoUser(int)>
	<android.os.IUserManager$Stub$Proxy: boolean isManagedProfile(int)>
	<android.os.IUserManager$Stub$Proxy: boolean isPreCreated(int)>
	<android.os.IUserManager$Stub$Proxy: boolean isProfile(int)>
	<android.os.IUserManager$Stub$Proxy: boolean isQuietModeEnabled(int)>
	<android.os.IUserManager$Stub$Proxy: boolean isRestricted()>
	<android.os.IUserManager$Stub$Proxy: boolean isSameProfileGroup(int,int)>
	<android.os.IUserManager$Stub$Proxy: boolean isSettingRestrictedForUser(java.lang.String,int,java.lang.String,int)>
	<android.os.IUserManager$Stub$Proxy: boolean isUserNameSet(int)>
	<android.os.IUserManager$Stub$Proxy: boolean isUserOfType(int,java.lang.String)>
	<android.os.IUserManager$Stub$Proxy: boolean isUserRunning(int)>
	<android.os.IUserManager$Stub$Proxy: boolean isUserUnlocked(int)>
	<android.os.IUserManager$Stub$Proxy: boolean isUserUnlockingOrUnlocked(int)>
	<android.os.IUserManager$Stub$Proxy: boolean markGuestForDeletion(int)>
	<android.os.IUserManager$Stub$Proxy: android.content.pm.UserInfo preCreateUserWithThrow(java.lang.String)>
	<android.os.IUserManager$Stub$Proxy: boolean removeUser(int)>
	<android.os.IUserManager$Stub$Proxy: boolean removeUserEvenWhenDisallowed(int)>
	<android.os.IUserManager$Stub$Proxy: boolean requestQuietModeEnabled(java.lang.String,boolean,int,android.content.IntentSender,int)>
	<android.os.IUserManager$Stub$Proxy: void setApplicationRestrictions(java.lang.String,android.os.Bundle,int)>
	<android.os.IUserManager$Stub$Proxy: void setDefaultGuestRestrictions(android.os.Bundle)>
	<android.os.IUserManager$Stub$Proxy: void setSeedAccountData(int,java.lang.String,java.lang.String,android.os.PersistableBundle,boolean)>
	<android.os.IUserManager$Stub$Proxy: void setUserAccount(int,java.lang.String)>
	<android.os.IUserManager$Stub$Proxy: void setUserAdmin(int)>
	<android.os.IUserManager$Stub$Proxy: void setUserEnabled(int)>
	<android.os.IUserManager$Stub$Proxy: void setUserIcon(int,android.graphics.Bitmap)>
	<android.os.IUserManager$Stub$Proxy: void setUserName(int,java.lang.String)>
	<android.os.IUserManager$Stub$Proxy: void setUserRestriction(java.lang.String,boolean,int)>
	<android.os.IUserManager$Stub$Proxy: boolean someUserHasSeedAccount(java.lang.String,java.lang.String)>

Name: vibrator
StubClassName: android.os.IVibratorService
isAvaliable: true
Methods : 12 
	<android.os.IVibratorService$Stub$Proxy: [I areEffectsSupported([I)>
	<android.os.IVibratorService$Stub$Proxy: [Z arePrimitivesSupported([I)>
	<android.os.IVibratorService$Stub$Proxy: android.os.IBinder asBinder()>
	<android.os.IVibratorService$Stub$Proxy: void cancelVibrate(android.os.IBinder)>
	<android.os.IVibratorService$Stub$Proxy: java.lang.String getInterfaceDescriptor()>
	<android.os.IVibratorService$Stub$Proxy: boolean hasAmplitudeControl()>
	<android.os.IVibratorService$Stub$Proxy: boolean hasVibrator()>
	<android.os.IVibratorService$Stub$Proxy: boolean isVibrating()>
	<android.os.IVibratorService$Stub$Proxy: boolean registerVibratorStateListener(android.os.IVibratorStateListener)>
	<android.os.IVibratorService$Stub$Proxy: boolean setAlwaysOnEffect(int,java.lang.String,int,android.os.VibrationEffect,android.os.VibrationAttributes)>
	<android.os.IVibratorService$Stub$Proxy: boolean unregisterVibratorStateListener(android.os.IVibratorStateListener)>
	<android.os.IVibratorService$Stub$Proxy: void vibrate(int,java.lang.String,android.os.VibrationEffect,android.os.VibrationAttributes,java.lang.String,android.os.IBinder)>

Name: voiceinteraction
StubClassName: com.android.internal.app.IVoiceInteractionManagerService
isAvaliable: true
Methods : 39 
	<com.android.internal.app.IVoiceInteractionManagerService$Stub$Proxy: boolean activeServiceSupportsAssist()>
	<com.android.internal.app.IVoiceInteractionManagerService$Stub$Proxy: boolean activeServiceSupportsLaunchFromKeyguard()>
	<com.android.internal.app.IVoiceInteractionManagerService$Stub$Proxy: android.os.IBinder asBinder()>
	<com.android.internal.app.IVoiceInteractionManagerService$Stub$Proxy: void closeSystemDialogs(android.os.IBinder)>
	<com.android.internal.app.IVoiceInteractionManagerService$Stub$Proxy: int deleteKeyphraseSoundModel(int,java.lang.String)>
	<com.android.internal.app.IVoiceInteractionManagerService$Stub$Proxy: boolean deliverNewSession(android.os.IBinder,android.service.voice.IVoiceInteractionSession,com.android.internal.app.IVoiceInteractor)>
	<com.android.internal.app.IVoiceInteractionManagerService$Stub$Proxy: void finish(android.os.IBinder)>
	<com.android.internal.app.IVoiceInteractionManagerService$Stub$Proxy: android.content.ComponentName getActiveServiceComponentName()>
	<com.android.internal.app.IVoiceInteractionManagerService$Stub$Proxy: void getActiveServiceSupportedActions(java.util.List,com.android.internal.app.IVoiceActionCheckCallback)>
	<com.android.internal.app.IVoiceInteractionManagerService$Stub$Proxy: int getDisabledShowContext()>
	<com.android.internal.app.IVoiceInteractionManagerService$Stub$Proxy: android.hardware.soundtrigger.SoundTrigger$ModuleProperties getDspModuleProperties()>
	<com.android.internal.app.IVoiceInteractionManagerService$Stub$Proxy: android.hardware.soundtrigger.KeyphraseMetadata getEnrolledKeyphraseMetadata(java.lang.String,java.lang.String)>
	<com.android.internal.app.IVoiceInteractionManagerService$Stub$Proxy: java.lang.String getInterfaceDescriptor()>
	<com.android.internal.app.IVoiceInteractionManagerService$Stub$Proxy: android.hardware.soundtrigger.SoundTrigger$KeyphraseSoundModel getKeyphraseSoundModel(int,java.lang.String)>
	<com.android.internal.app.IVoiceInteractionManagerService$Stub$Proxy: int getParameter(int,int)>
	<com.android.internal.app.IVoiceInteractionManagerService$Stub$Proxy: int getUserDisabledShowContext()>
	<com.android.internal.app.IVoiceInteractionManagerService$Stub$Proxy: void hideCurrentSession()>
	<com.android.internal.app.IVoiceInteractionManagerService$Stub$Proxy: boolean hideSessionFromSession(android.os.IBinder)>
	<com.android.internal.app.IVoiceInteractionManagerService$Stub$Proxy: boolean isEnrolledForKeyphrase(int,java.lang.String)>
	<com.android.internal.app.IVoiceInteractionManagerService$Stub$Proxy: boolean isSessionRunning()>
	<com.android.internal.app.IVoiceInteractionManagerService$Stub$Proxy: void launchVoiceAssistFromKeyguard()>
	<com.android.internal.app.IVoiceInteractionManagerService$Stub$Proxy: void onLockscreenShown()>
	<com.android.internal.app.IVoiceInteractionManagerService$Stub$Proxy: void performDirectAction(android.os.IBinder,java.lang.String,android.os.Bundle,int,android.os.IBinder,android.os.RemoteCallback,android.os.RemoteCallback)>
	<com.android.internal.app.IVoiceInteractionManagerService$Stub$Proxy: android.hardware.soundtrigger.SoundTrigger$ModelParamRange queryParameter(int,int)>
	<com.android.internal.app.IVoiceInteractionManagerService$Stub$Proxy: void registerVoiceInteractionSessionListener(com.android.internal.app.IVoiceInteractionSessionListener)>
	<com.android.internal.app.IVoiceInteractionManagerService$Stub$Proxy: void requestDirectActions(android.os.IBinder,int,android.os.IBinder,android.os.RemoteCallback,android.os.RemoteCallback)>
	<com.android.internal.app.IVoiceInteractionManagerService$Stub$Proxy: void setDisabled(boolean)>
	<com.android.internal.app.IVoiceInteractionManagerService$Stub$Proxy: void setDisabledShowContext(int)>
	<com.android.internal.app.IVoiceInteractionManagerService$Stub$Proxy: void setKeepAwake(android.os.IBinder,boolean)>
	<com.android.internal.app.IVoiceInteractionManagerService$Stub$Proxy: int setParameter(int,int,int)>
	<com.android.internal.app.IVoiceInteractionManagerService$Stub$Proxy: void setUiHints(android.os.Bundle)>
	<com.android.internal.app.IVoiceInteractionManagerService$Stub$Proxy: void showSession(android.os.Bundle,int)>
	<com.android.internal.app.IVoiceInteractionManagerService$Stub$Proxy: boolean showSessionForActiveService(android.os.Bundle,int,com.android.internal.app.IVoiceInteractionSessionShowCallback,android.os.IBinder)>
	<com.android.internal.app.IVoiceInteractionManagerService$Stub$Proxy: boolean showSessionFromSession(android.os.IBinder,android.os.Bundle,int)>
	<com.android.internal.app.IVoiceInteractionManagerService$Stub$Proxy: int startAssistantActivity(android.os.IBinder,android.content.Intent,java.lang.String,java.lang.String)>
	<com.android.internal.app.IVoiceInteractionManagerService$Stub$Proxy: int startRecognition(int,java.lang.String,android.hardware.soundtrigger.IRecognitionStatusCallback,android.hardware.soundtrigger.SoundTrigger$RecognitionConfig)>
	<com.android.internal.app.IVoiceInteractionManagerService$Stub$Proxy: int startVoiceActivity(android.os.IBinder,android.content.Intent,java.lang.String,java.lang.String)>
	<com.android.internal.app.IVoiceInteractionManagerService$Stub$Proxy: int stopRecognition(int,android.hardware.soundtrigger.IRecognitionStatusCallback)>
	<com.android.internal.app.IVoiceInteractionManagerService$Stub$Proxy: int updateKeyphraseSoundModel(android.hardware.soundtrigger.SoundTrigger$KeyphraseSoundModel)>

Name: vold
StubClassName: null
isAvaliable: false
Methods : 0 

Name: vrmanager
StubClassName: android.service.vr.IVrManager
isAvaliable: true
Methods : 13 
	<android.service.vr.IVrManager$Stub$Proxy: android.os.IBinder asBinder()>
	<android.service.vr.IVrManager$Stub$Proxy: java.lang.String getInterfaceDescriptor()>
	<android.service.vr.IVrManager$Stub$Proxy: boolean getPersistentVrModeEnabled()>
	<android.service.vr.IVrManager$Stub$Proxy: int getVr2dDisplayId()>
	<android.service.vr.IVrManager$Stub$Proxy: boolean getVrModeState()>
	<android.service.vr.IVrManager$Stub$Proxy: void registerListener(android.service.vr.IVrStateCallbacks)>
	<android.service.vr.IVrManager$Stub$Proxy: void registerPersistentVrStateListener(android.service.vr.IPersistentVrStateCallbacks)>
	<android.service.vr.IVrManager$Stub$Proxy: void setAndBindCompositor(java.lang.String)>
	<android.service.vr.IVrManager$Stub$Proxy: void setPersistentVrModeEnabled(boolean)>
	<android.service.vr.IVrManager$Stub$Proxy: void setStandbyEnabled(boolean)>
	<android.service.vr.IVrManager$Stub$Proxy: void setVr2dDisplayProperties(android.app.Vr2dDisplayProperties)>
	<android.service.vr.IVrManager$Stub$Proxy: void unregisterListener(android.service.vr.IVrStateCallbacks)>
	<android.service.vr.IVrManager$Stub$Proxy: void unregisterPersistentVrStateListener(android.service.vr.IPersistentVrStateCallbacks)>

Name: wallpaper
StubClassName: android.app.IWallpaperManager
isAvaliable: true
Methods : 25 
	<android.app.IWallpaperManager$Stub$Proxy: android.os.IBinder asBinder()>
	<android.app.IWallpaperManager$Stub$Proxy: void clearWallpaper(java.lang.String,int,int)>
	<android.app.IWallpaperManager$Stub$Proxy: int getHeightHint(int)>
	<android.app.IWallpaperManager$Stub$Proxy: java.lang.String getInterfaceDescriptor()>
	<android.app.IWallpaperManager$Stub$Proxy: java.lang.String getName()>
	<android.app.IWallpaperManager$Stub$Proxy: android.os.ParcelFileDescriptor getWallpaper(java.lang.String,android.app.IWallpaperManagerCallback,int,android.os.Bundle,int)>
	<android.app.IWallpaperManager$Stub$Proxy: android.app.WallpaperColors getWallpaperColors(int,int,int)>
	<android.app.IWallpaperManager$Stub$Proxy: int getWallpaperIdForUser(int,int)>
	<android.app.IWallpaperManager$Stub$Proxy: android.app.WallpaperInfo getWallpaperInfo(int)>
	<android.app.IWallpaperManager$Stub$Proxy: android.os.ParcelFileDescriptor getWallpaperWithFeature(java.lang.String,java.lang.String,android.app.IWallpaperManagerCallback,int,android.os.Bundle,int)>
	<android.app.IWallpaperManager$Stub$Proxy: int getWidthHint(int)>
	<android.app.IWallpaperManager$Stub$Proxy: boolean hasNamedWallpaper(java.lang.String)>
	<android.app.IWallpaperManager$Stub$Proxy: boolean isSetWallpaperAllowed(java.lang.String)>
	<android.app.IWallpaperManager$Stub$Proxy: boolean isWallpaperBackupEligible(int,int)>
	<android.app.IWallpaperManager$Stub$Proxy: boolean isWallpaperSupported(java.lang.String)>
	<android.app.IWallpaperManager$Stub$Proxy: void registerWallpaperColorsCallback(android.app.IWallpaperManagerCallback,int,int)>
	<android.app.IWallpaperManager$Stub$Proxy: void setDimensionHints(int,int,java.lang.String,int)>
	<android.app.IWallpaperManager$Stub$Proxy: void setDisplayPadding(android.graphics.Rect,java.lang.String,int)>
	<android.app.IWallpaperManager$Stub$Proxy: void setInAmbientMode(boolean,long)>
	<android.app.IWallpaperManager$Stub$Proxy: boolean setLockWallpaperCallback(android.app.IWallpaperManagerCallback)>
	<android.app.IWallpaperManager$Stub$Proxy: android.os.ParcelFileDescriptor setWallpaper(java.lang.String,java.lang.String,android.graphics.Rect,boolean,android.os.Bundle,int,android.app.IWallpaperManagerCallback,int)>
	<android.app.IWallpaperManager$Stub$Proxy: void setWallpaperComponent(android.content.ComponentName)>
	<android.app.IWallpaperManager$Stub$Proxy: void setWallpaperComponentChecked(android.content.ComponentName,java.lang.String,int)>
	<android.app.IWallpaperManager$Stub$Proxy: void settingsRestored()>
	<android.app.IWallpaperManager$Stub$Proxy: void unregisterWallpaperColorsCallback(android.app.IWallpaperManagerCallback,int,int)>

Name: webviewupdate
StubClassName: android.webkit.IWebViewUpdateService
isAvaliable: true
Methods : 11 
	<android.webkit.IWebViewUpdateService$Stub$Proxy: android.os.IBinder asBinder()>
	<android.webkit.IWebViewUpdateService$Stub$Proxy: java.lang.String changeProviderAndSetting(java.lang.String)>
	<android.webkit.IWebViewUpdateService$Stub$Proxy: void enableMultiProcess(boolean)>
	<android.webkit.IWebViewUpdateService$Stub$Proxy: [Landroid.webkit.WebViewProviderInfo; getAllWebViewPackages()>
	<android.webkit.IWebViewUpdateService$Stub$Proxy: android.content.pm.PackageInfo getCurrentWebViewPackage()>
	<android.webkit.IWebViewUpdateService$Stub$Proxy: java.lang.String getCurrentWebViewPackageName()>
	<android.webkit.IWebViewUpdateService$Stub$Proxy: java.lang.String getInterfaceDescriptor()>
	<android.webkit.IWebViewUpdateService$Stub$Proxy: [Landroid.webkit.WebViewProviderInfo; getValidWebViewPackages()>
	<android.webkit.IWebViewUpdateService$Stub$Proxy: boolean isMultiProcessEnabled()>
	<android.webkit.IWebViewUpdateService$Stub$Proxy: void notifyRelroCreationCompleted()>
	<android.webkit.IWebViewUpdateService$Stub$Proxy: android.webkit.WebViewProviderResponse waitForAndGetProvider()>

Name: wifi
StubClassName: android.net.wifi.IWifiManager
isAvaliable: true
Methods : 109 
	<android.net.wifi.IWifiManager$Stub$Proxy: void acquireMulticastLock(android.os.IBinder,java.lang.String)>
	<android.net.wifi.IWifiManager$Stub$Proxy: boolean acquireWifiLock(android.os.IBinder,int,java.lang.String,android.os.WorkSource)>
	<android.net.wifi.IWifiManager$Stub$Proxy: int addNetworkSuggestions(java.util.List,java.lang.String,java.lang.String)>
	<android.net.wifi.IWifiManager$Stub$Proxy: void addOnWifiUsabilityStatsListener(android.os.IBinder,android.net.wifi.IOnWifiUsabilityStatsListener,int)>
	<android.net.wifi.IWifiManager$Stub$Proxy: int addOrUpdateNetwork(android.net.wifi.WifiConfiguration,java.lang.String)>
	<android.net.wifi.IWifiManager$Stub$Proxy: boolean addOrUpdatePasspointConfiguration(android.net.wifi.hotspot2.PasspointConfiguration,java.lang.String)>
	<android.net.wifi.IWifiManager$Stub$Proxy: void allowAutojoin(int,boolean)>
	<android.net.wifi.IWifiManager$Stub$Proxy: void allowAutojoinGlobal(boolean)>
	<android.net.wifi.IWifiManager$Stub$Proxy: void allowAutojoinPasspoint(java.lang.String,boolean)>
	<android.net.wifi.IWifiManager$Stub$Proxy: android.os.IBinder asBinder()>
	<android.net.wifi.IWifiManager$Stub$Proxy: int calculateSignalLevel(int)>
	<android.net.wifi.IWifiManager$Stub$Proxy: void clearWifiConnectedNetworkScorer()>
	<android.net.wifi.IWifiManager$Stub$Proxy: void connect(android.net.wifi.WifiConfiguration,int,android.os.IBinder,android.net.wifi.IActionListener,int)>
	<android.net.wifi.IWifiManager$Stub$Proxy: void deauthenticateNetwork(long,boolean)>
	<android.net.wifi.IWifiManager$Stub$Proxy: void disableEphemeralNetwork(java.lang.String,java.lang.String)>
	<android.net.wifi.IWifiManager$Stub$Proxy: boolean disableNetwork(int,java.lang.String)>
	<android.net.wifi.IWifiManager$Stub$Proxy: boolean disconnect(java.lang.String)>
	<android.net.wifi.IWifiManager$Stub$Proxy: boolean enableNetwork(int,boolean,java.lang.String)>
	<android.net.wifi.IWifiManager$Stub$Proxy: void enableTdls(java.lang.String,boolean)>
	<android.net.wifi.IWifiManager$Stub$Proxy: void enableTdlsWithMacAddress(java.lang.String,boolean)>
	<android.net.wifi.IWifiManager$Stub$Proxy: void enableVerboseLogging(int)>
	<android.net.wifi.IWifiManager$Stub$Proxy: void factoryReset(java.lang.String)>
	<android.net.wifi.IWifiManager$Stub$Proxy: void forget(int,android.os.IBinder,android.net.wifi.IActionListener,int)>
	<android.net.wifi.IWifiManager$Stub$Proxy: java.util.Map getAllMatchingFqdnsForScanResults(java.util.List)>
	<android.net.wifi.IWifiManager$Stub$Proxy: java.util.Map getAllMatchingPasspointProfilesForScanResults(java.util.List)>
	<android.net.wifi.IWifiManager$Stub$Proxy: com.android.wifi.x.android.content.pm.ParceledListSlice getConfiguredNetworks(java.lang.String,java.lang.String)>
	<android.net.wifi.IWifiManager$Stub$Proxy: android.net.wifi.WifiInfo getConnectionInfo(java.lang.String,java.lang.String)>
	<android.net.wifi.IWifiManager$Stub$Proxy: java.lang.String getCountryCode()>
	<android.net.wifi.IWifiManager$Stub$Proxy: android.net.Network getCurrentNetwork()>
	<android.net.wifi.IWifiManager$Stub$Proxy: java.lang.String getCurrentNetworkWpsNfcConfigurationToken()>
	<android.net.wifi.IWifiManager$Stub$Proxy: android.net.DhcpInfo getDhcpInfo()>
	<android.net.wifi.IWifiManager$Stub$Proxy: [Ljava.lang.String; getFactoryMacAddresses()>
	<android.net.wifi.IWifiManager$Stub$Proxy: java.lang.String getInterfaceDescriptor()>
	<android.net.wifi.IWifiManager$Stub$Proxy: java.util.Map getMatchingOsuProviders(java.util.List)>
	<android.net.wifi.IWifiManager$Stub$Proxy: java.util.Map getMatchingPasspointConfigsForOsuProviders(java.util.List)>
	<android.net.wifi.IWifiManager$Stub$Proxy: java.util.Map getMatchingScanResults(java.util.List,java.util.List,java.lang.String,java.lang.String)>
	<android.net.wifi.IWifiManager$Stub$Proxy: java.util.List getNetworkSuggestions(java.lang.String)>
	<android.net.wifi.IWifiManager$Stub$Proxy: java.util.List getPasspointConfigurations(java.lang.String)>
	<android.net.wifi.IWifiManager$Stub$Proxy: com.android.wifi.x.android.content.pm.ParceledListSlice getPrivilegedConfiguredNetworks(java.lang.String,java.lang.String)>
	<android.net.wifi.IWifiManager$Stub$Proxy: java.util.List getScanResults(java.lang.String,java.lang.String)>
	<android.net.wifi.IWifiManager$Stub$Proxy: android.net.wifi.SoftApConfiguration getSoftApConfiguration()>
	<android.net.wifi.IWifiManager$Stub$Proxy: long getSupportedFeatures()>
	<android.net.wifi.IWifiManager$Stub$Proxy: int getVerboseLoggingLevel()>
	<android.net.wifi.IWifiManager$Stub$Proxy: void getWifiActivityEnergyInfoAsync(android.net.wifi.IOnWifiActivityEnergyInfoListener)>
	<android.net.wifi.IWifiManager$Stub$Proxy: android.net.wifi.WifiConfiguration getWifiApConfiguration()>
	<android.net.wifi.IWifiManager$Stub$Proxy: int getWifiApEnabledState()>
	<android.net.wifi.IWifiManager$Stub$Proxy: java.util.List getWifiConfigForMatchedNetworkSuggestionsSharedWithUser(java.util.List)>
	<android.net.wifi.IWifiManager$Stub$Proxy: java.util.List getWifiConfigsForPasspointProfiles(java.util.List)>
	<android.net.wifi.IWifiManager$Stub$Proxy: int getWifiEnabledState()>
	<android.net.wifi.IWifiManager$Stub$Proxy: void initializeMulticastFiltering()>
	<android.net.wifi.IWifiManager$Stub$Proxy: boolean is5GHzBandSupported()>
	<android.net.wifi.IWifiManager$Stub$Proxy: boolean is6GHzBandSupported()>
	<android.net.wifi.IWifiManager$Stub$Proxy: boolean isAutoWakeupEnabled()>
	<android.net.wifi.IWifiManager$Stub$Proxy: boolean isMulticastEnabled()>
	<android.net.wifi.IWifiManager$Stub$Proxy: boolean isScanAlwaysAvailable()>
	<android.net.wifi.IWifiManager$Stub$Proxy: boolean isScanThrottleEnabled()>
	<android.net.wifi.IWifiManager$Stub$Proxy: boolean isWifiStandardSupported(int)>
	<android.net.wifi.IWifiManager$Stub$Proxy: int matchProviderWithCurrentNetwork(java.lang.String)>
	<android.net.wifi.IWifiManager$Stub$Proxy: void notifyUserOfApBandConversion(java.lang.String)>
	<android.net.wifi.IWifiManager$Stub$Proxy: void queryPasspointIcon(long,java.lang.String)>
	<android.net.wifi.IWifiManager$Stub$Proxy: boolean reassociate(java.lang.String)>
	<android.net.wifi.IWifiManager$Stub$Proxy: boolean reconnect(java.lang.String)>
	<android.net.wifi.IWifiManager$Stub$Proxy: void registerNetworkRequestMatchCallback(android.os.IBinder,android.net.wifi.INetworkRequestMatchCallback,int)>
	<android.net.wifi.IWifiManager$Stub$Proxy: void registerScanResultsCallback(android.net.wifi.IScanResultsCallback)>
	<android.net.wifi.IWifiManager$Stub$Proxy: void registerSoftApCallback(android.os.IBinder,android.net.wifi.ISoftApCallback,int)>
	<android.net.wifi.IWifiManager$Stub$Proxy: void registerSuggestionConnectionStatusListener(android.os.IBinder,android.net.wifi.ISuggestionConnectionStatusListener,int,java.lang.String,java.lang.String)>
	<android.net.wifi.IWifiManager$Stub$Proxy: void registerTrafficStateCallback(android.os.IBinder,android.net.wifi.ITrafficStateCallback,int)>
	<android.net.wifi.IWifiManager$Stub$Proxy: void releaseMulticastLock(java.lang.String)>
	<android.net.wifi.IWifiManager$Stub$Proxy: boolean releaseWifiLock(android.os.IBinder)>
	<android.net.wifi.IWifiManager$Stub$Proxy: boolean removeNetwork(int,java.lang.String)>
	<android.net.wifi.IWifiManager$Stub$Proxy: int removeNetworkSuggestions(java.util.List,java.lang.String)>
	<android.net.wifi.IWifiManager$Stub$Proxy: void removeOnWifiUsabilityStatsListener(int)>
	<android.net.wifi.IWifiManager$Stub$Proxy: boolean removePasspointConfiguration(java.lang.String,java.lang.String)>
	<android.net.wifi.IWifiManager$Stub$Proxy: void restoreBackupData([B)>
	<android.net.wifi.IWifiManager$Stub$Proxy: android.net.wifi.SoftApConfiguration restoreSoftApBackupData([B)>
	<android.net.wifi.IWifiManager$Stub$Proxy: void restoreSupplicantBackupData([B,[B)>
	<android.net.wifi.IWifiManager$Stub$Proxy: [B retrieveBackupData()>
	<android.net.wifi.IWifiManager$Stub$Proxy: [B retrieveSoftApBackupData()>
	<android.net.wifi.IWifiManager$Stub$Proxy: void save(android.net.wifi.WifiConfiguration,android.os.IBinder,android.net.wifi.IActionListener,int)>
	<android.net.wifi.IWifiManager$Stub$Proxy: void setAutoWakeupEnabled(boolean)>
	<android.net.wifi.IWifiManager$Stub$Proxy: void setDeviceMobilityState(int)>
	<android.net.wifi.IWifiManager$Stub$Proxy: void setMacRandomizationSettingPasspointEnabled(java.lang.String,boolean)>
	<android.net.wifi.IWifiManager$Stub$Proxy: void setPasspointMeteredOverride(java.lang.String,int)>
	<android.net.wifi.IWifiManager$Stub$Proxy: void setScanAlwaysAvailable(boolean)>
	<android.net.wifi.IWifiManager$Stub$Proxy: void setScanThrottleEnabled(boolean)>
	<android.net.wifi.IWifiManager$Stub$Proxy: boolean setSoftApConfiguration(android.net.wifi.SoftApConfiguration,java.lang.String)>
	<android.net.wifi.IWifiManager$Stub$Proxy: boolean setWifiApConfiguration(android.net.wifi.WifiConfiguration,java.lang.String)>
	<android.net.wifi.IWifiManager$Stub$Proxy: boolean setWifiConnectedNetworkScorer(android.os.IBinder,android.net.wifi.IWifiConnectedNetworkScorer)>
	<android.net.wifi.IWifiManager$Stub$Proxy: boolean setWifiEnabled(java.lang.String,boolean)>
	<android.net.wifi.IWifiManager$Stub$Proxy: void startDppAsConfiguratorInitiator(android.os.IBinder,java.lang.String,int,int,android.net.wifi.IDppCallback)>
	<android.net.wifi.IWifiManager$Stub$Proxy: void startDppAsEnrolleeInitiator(android.os.IBinder,java.lang.String,android.net.wifi.IDppCallback)>
	<android.net.wifi.IWifiManager$Stub$Proxy: int startLocalOnlyHotspot(android.net.wifi.ILocalOnlyHotspotCallback,java.lang.String,java.lang.String,android.net.wifi.SoftApConfiguration)>
	<android.net.wifi.IWifiManager$Stub$Proxy: boolean startScan(java.lang.String,java.lang.String)>
	<android.net.wifi.IWifiManager$Stub$Proxy: boolean startSoftAp(android.net.wifi.WifiConfiguration)>
	<android.net.wifi.IWifiManager$Stub$Proxy: void startSubscriptionProvisioning(android.net.wifi.hotspot2.OsuProvider,android.net.wifi.hotspot2.IProvisioningCallback)>
	<android.net.wifi.IWifiManager$Stub$Proxy: boolean startTetheredHotspot(android.net.wifi.SoftApConfiguration)>
	<android.net.wifi.IWifiManager$Stub$Proxy: void startWatchLocalOnlyHotspot(android.net.wifi.ILocalOnlyHotspotCallback)>
	<android.net.wifi.IWifiManager$Stub$Proxy: void stopDppSession()>
	<android.net.wifi.IWifiManager$Stub$Proxy: void stopLocalOnlyHotspot()>
	<android.net.wifi.IWifiManager$Stub$Proxy: boolean stopSoftAp()>
	<android.net.wifi.IWifiManager$Stub$Proxy: void stopWatchLocalOnlyHotspot()>
	<android.net.wifi.IWifiManager$Stub$Proxy: void unregisterNetworkRequestMatchCallback(int)>
	<android.net.wifi.IWifiManager$Stub$Proxy: void unregisterScanResultsCallback(android.net.wifi.IScanResultsCallback)>
	<android.net.wifi.IWifiManager$Stub$Proxy: void unregisterSoftApCallback(int)>
	<android.net.wifi.IWifiManager$Stub$Proxy: void unregisterSuggestionConnectionStatusListener(int,java.lang.String)>
	<android.net.wifi.IWifiManager$Stub$Proxy: void unregisterTrafficStateCallback(int)>
	<android.net.wifi.IWifiManager$Stub$Proxy: void updateInterfaceIpState(java.lang.String,int)>
	<android.net.wifi.IWifiManager$Stub$Proxy: void updateWifiLockWorkSource(android.os.IBinder,android.os.WorkSource)>
	<android.net.wifi.IWifiManager$Stub$Proxy: void updateWifiUsabilityScore(int,int,int)>

Name: wifiaware
StubClassName: android.net.wifi.aware.IWifiAwareManager
isAvaliable: true
Methods : 13 
	<android.net.wifi.aware.IWifiAwareManager$Stub$Proxy: android.os.IBinder asBinder()>
	<android.net.wifi.aware.IWifiAwareManager$Stub$Proxy: void connect(android.os.IBinder,java.lang.String,java.lang.String,android.net.wifi.aware.IWifiAwareEventCallback,android.net.wifi.aware.ConfigRequest,boolean)>
	<android.net.wifi.aware.IWifiAwareManager$Stub$Proxy: void disconnect(int,android.os.IBinder)>
	<android.net.wifi.aware.IWifiAwareManager$Stub$Proxy: android.net.wifi.aware.Characteristics getCharacteristics()>
	<android.net.wifi.aware.IWifiAwareManager$Stub$Proxy: java.lang.String getInterfaceDescriptor()>
	<android.net.wifi.aware.IWifiAwareManager$Stub$Proxy: boolean isUsageEnabled()>
	<android.net.wifi.aware.IWifiAwareManager$Stub$Proxy: void publish(java.lang.String,java.lang.String,int,android.net.wifi.aware.PublishConfig,android.net.wifi.aware.IWifiAwareDiscoverySessionCallback)>
	<android.net.wifi.aware.IWifiAwareManager$Stub$Proxy: void requestMacAddresses(int,java.util.List,android.net.wifi.aware.IWifiAwareMacAddressProvider)>
	<android.net.wifi.aware.IWifiAwareManager$Stub$Proxy: void sendMessage(int,int,int,[B,int,int)>
	<android.net.wifi.aware.IWifiAwareManager$Stub$Proxy: void subscribe(java.lang.String,java.lang.String,int,android.net.wifi.aware.SubscribeConfig,android.net.wifi.aware.IWifiAwareDiscoverySessionCallback)>
	<android.net.wifi.aware.IWifiAwareManager$Stub$Proxy: void terminateSession(int,int)>
	<android.net.wifi.aware.IWifiAwareManager$Stub$Proxy: void updatePublish(int,int,android.net.wifi.aware.PublishConfig)>
	<android.net.wifi.aware.IWifiAwareManager$Stub$Proxy: void updateSubscribe(int,int,android.net.wifi.aware.SubscribeConfig)>

Name: wifinl80211
StubClassName: null
isAvaliable: false
Methods : 0 

Name: wifip2p
StubClassName: android.net.wifi.p2p.IWifiP2pManager
isAvaliable: true
Methods : 7 
	<android.net.wifi.p2p.IWifiP2pManager$Stub$Proxy: android.os.IBinder asBinder()>
	<android.net.wifi.p2p.IWifiP2pManager$Stub$Proxy: void checkConfigureWifiDisplayPermission()>
	<android.net.wifi.p2p.IWifiP2pManager$Stub$Proxy: void close(android.os.IBinder)>
	<android.net.wifi.p2p.IWifiP2pManager$Stub$Proxy: java.lang.String getInterfaceDescriptor()>
	<android.net.wifi.p2p.IWifiP2pManager$Stub$Proxy: android.os.Messenger getMessenger(android.os.IBinder)>
	<android.net.wifi.p2p.IWifiP2pManager$Stub$Proxy: android.os.Messenger getP2pStateMachineMessenger()>
	<android.net.wifi.p2p.IWifiP2pManager$Stub$Proxy: void setMiracastMode(int)>

Name: wifirtt
StubClassName: android.net.wifi.rtt.IWifiRttManager
isAvaliable: true
Methods : 5 
	<android.net.wifi.rtt.IWifiRttManager$Stub$Proxy: android.os.IBinder asBinder()>
	<android.net.wifi.rtt.IWifiRttManager$Stub$Proxy: void cancelRanging(android.os.WorkSource)>
	<android.net.wifi.rtt.IWifiRttManager$Stub$Proxy: java.lang.String getInterfaceDescriptor()>
	<android.net.wifi.rtt.IWifiRttManager$Stub$Proxy: boolean isAvailable()>
	<android.net.wifi.rtt.IWifiRttManager$Stub$Proxy: void startRanging(android.os.IBinder,java.lang.String,java.lang.String,android.os.WorkSource,android.net.wifi.rtt.RangingRequest,android.net.wifi.rtt.IRttCallback)>

Name: wifiscanner
StubClassName: null
isAvaliable: false
Methods : 0 

Name: window
StubClassName: android.view.IWindowManager
isAvaliable: true
Methods : 118 
	<android.view.IWindowManager$Stub$Proxy: android.view.SurfaceControl addShellRoot(int,android.view.IWindow,int)>
	<android.view.IWindowManager$Stub$Proxy: void addWindowToken(android.os.IBinder,int,int)>
	<android.view.IWindowManager$Stub$Proxy: int addWindowTokenWithOptions(android.os.IBinder,int,int,android.os.Bundle,java.lang.String)>
	<android.view.IWindowManager$Stub$Proxy: android.os.IBinder asBinder()>
	<android.view.IWindowManager$Stub$Proxy: void clearForcedDisplayDensityForUser(int,int)>
	<android.view.IWindowManager$Stub$Proxy: void clearForcedDisplaySize(int)>
	<android.view.IWindowManager$Stub$Proxy: boolean clearWindowContentFrameStats(android.os.IBinder)>
	<android.view.IWindowManager$Stub$Proxy: void closeSystemDialogs(java.lang.String)>
	<android.view.IWindowManager$Stub$Proxy: void createInputConsumer(android.os.IBinder,java.lang.String,int,android.view.InputChannel)>
	<android.view.IWindowManager$Stub$Proxy: boolean destroyInputConsumer(java.lang.String,int)>
	<android.view.IWindowManager$Stub$Proxy: void disableKeyguard(android.os.IBinder,java.lang.String,int)>
	<android.view.IWindowManager$Stub$Proxy: void dismissKeyguard(com.android.internal.policy.IKeyguardDismissCallback,java.lang.CharSequence)>
	<android.view.IWindowManager$Stub$Proxy: void dontOverrideDisplayInfo(int)>
	<android.view.IWindowManager$Stub$Proxy: void enableScreenIfNeeded()>
	<android.view.IWindowManager$Stub$Proxy: void endProlongedAnimations()>
	<android.view.IWindowManager$Stub$Proxy: void executeAppTransition()>
	<android.view.IWindowManager$Stub$Proxy: void exitKeyguardSecurely(android.view.IOnKeyguardExitResult)>
	<android.view.IWindowManager$Stub$Proxy: void freezeDisplayRotation(int,int)>
	<android.view.IWindowManager$Stub$Proxy: void freezeRotation(int)>
	<android.view.IWindowManager$Stub$Proxy: float getAnimationScale(int)>
	<android.view.IWindowManager$Stub$Proxy: [F getAnimationScales()>
	<android.view.IWindowManager$Stub$Proxy: int getBaseDisplayDensity(int)>
	<android.view.IWindowManager$Stub$Proxy: void getBaseDisplaySize(int,android.graphics.Point)>
	<android.view.IWindowManager$Stub$Proxy: float getCurrentAnimatorScale()>
	<android.view.IWindowManager$Stub$Proxy: android.graphics.Region getCurrentImeTouchRegion()>
	<android.view.IWindowManager$Stub$Proxy: int getDefaultDisplayRotation()>
	<android.view.IWindowManager$Stub$Proxy: int getDockedStackSide()>
	<android.view.IWindowManager$Stub$Proxy: int getInitialDisplayDensity(int)>
	<android.view.IWindowManager$Stub$Proxy: void getInitialDisplaySize(int,android.graphics.Point)>
	<android.view.IWindowManager$Stub$Proxy: java.lang.String getInterfaceDescriptor()>
	<android.view.IWindowManager$Stub$Proxy: int getNavBarPosition(int)>
	<android.view.IWindowManager$Stub$Proxy: int getPreferredOptionsPanelGravity(int)>
	<android.view.IWindowManager$Stub$Proxy: int getRemoveContentMode(int)>
	<android.view.IWindowManager$Stub$Proxy: void getStableInsets(int,android.graphics.Rect)>
	<android.view.IWindowManager$Stub$Proxy: android.view.WindowContentFrameStats getWindowContentFrameStats(android.os.IBinder)>
	<android.view.IWindowManager$Stub$Proxy: boolean getWindowInsets(android.view.WindowManager$LayoutParams,int,android.graphics.Rect,android.graphics.Rect,android.view.DisplayCutout$ParcelableWrapper,android.view.InsetsState)>
	<android.view.IWindowManager$Stub$Proxy: int getWindowingMode(int)>
	<android.view.IWindowManager$Stub$Proxy: boolean hasNavigationBar(int)>
	<android.view.IWindowManager$Stub$Proxy: void hideTransientBars(int)>
	<android.view.IWindowManager$Stub$Proxy: boolean injectInputAfterTransactionsApplied(android.view.InputEvent,int)>
	<android.view.IWindowManager$Stub$Proxy: boolean isDisplayRotationFrozen(int)>
	<android.view.IWindowManager$Stub$Proxy: boolean isKeyguardLocked()>
	<android.view.IWindowManager$Stub$Proxy: boolean isKeyguardSecure(int)>
	<android.view.IWindowManager$Stub$Proxy: boolean isLayerTracing()>
	<android.view.IWindowManager$Stub$Proxy: boolean isRotationFrozen()>
	<android.view.IWindowManager$Stub$Proxy: boolean isSafeModeEnabled()>
	<android.view.IWindowManager$Stub$Proxy: boolean isViewServerRunning()>
	<android.view.IWindowManager$Stub$Proxy: boolean isWindowToken(android.os.IBinder)>
	<android.view.IWindowManager$Stub$Proxy: boolean isWindowTraceEnabled()>
	<android.view.IWindowManager$Stub$Proxy: void lockNow(android.os.Bundle)>
	<android.view.IWindowManager$Stub$Proxy: boolean mirrorDisplay(int,android.view.SurfaceControl)>
	<android.view.IWindowManager$Stub$Proxy: void modifyDisplayWindowInsets(int,android.view.InsetsState)>
	<android.view.IWindowManager$Stub$Proxy: android.view.IWindowSession openSession(android.view.IWindowSessionCallback)>
	<android.view.IWindowManager$Stub$Proxy: void overridePendingAppTransitionMultiThumbFuture(android.view.IAppTransitionAnimationSpecsFuture,android.os.IRemoteCallback,boolean,int)>
	<android.view.IWindowManager$Stub$Proxy: void overridePendingAppTransitionRemote(android.view.RemoteAnimationAdapter,int)>
	<android.view.IWindowManager$Stub$Proxy: void prepareAppTransition(int,boolean)>
	<android.view.IWindowManager$Stub$Proxy: void reenableKeyguard(android.os.IBinder,int)>
	<android.view.IWindowManager$Stub$Proxy: void refreshScreenCaptureDisabled(int)>
	<android.view.IWindowManager$Stub$Proxy: void registerDisplayFoldListener(android.view.IDisplayFoldListener)>
	<android.view.IWindowManager$Stub$Proxy: void registerDisplayWindowListener(android.view.IDisplayWindowListener)>
	<android.view.IWindowManager$Stub$Proxy: void registerPinnedStackListener(int,android.view.IPinnedStackListener)>
	<android.view.IWindowManager$Stub$Proxy: void registerShortcutKey(long,com.android.internal.policy.IShortcutService)>
	<android.view.IWindowManager$Stub$Proxy: void registerSystemGestureExclusionListener(android.view.ISystemGestureExclusionListener,int)>
	<android.view.IWindowManager$Stub$Proxy: boolean registerWallpaperVisibilityListener(android.view.IWallpaperVisibilityListener,int)>
	<android.view.IWindowManager$Stub$Proxy: void removeRotationWatcher(android.view.IRotationWatcher)>
	<android.view.IWindowManager$Stub$Proxy: void removeWindowToken(android.os.IBinder,int)>
	<android.view.IWindowManager$Stub$Proxy: void requestAppKeyboardShortcuts(com.android.internal.os.IResultReceiver,int)>
	<android.view.IWindowManager$Stub$Proxy: boolean requestAssistScreenshot(android.app.IAssistDataReceiver)>
	<android.view.IWindowManager$Stub$Proxy: void requestScrollCapture(int,android.os.IBinder,int,android.view.IScrollCaptureController)>
	<android.view.IWindowManager$Stub$Proxy: android.graphics.Bitmap screenshotWallpaper()>
	<android.view.IWindowManager$Stub$Proxy: void setAnimationScale(int,float)>
	<android.view.IWindowManager$Stub$Proxy: void setAnimationScales([F)>
	<android.view.IWindowManager$Stub$Proxy: void setDisplayWindowInsetsController(int,android.view.IDisplayWindowInsetsController)>
	<android.view.IWindowManager$Stub$Proxy: void setDisplayWindowRotationController(android.view.IDisplayWindowRotationController)>
	<android.view.IWindowManager$Stub$Proxy: void setDockedStackDividerTouchRegion(android.graphics.Rect)>
	<android.view.IWindowManager$Stub$Proxy: void setEventDispatching(boolean)>
	<android.view.IWindowManager$Stub$Proxy: void setFixedToUserRotation(int,int)>
	<android.view.IWindowManager$Stub$Proxy: void setForceShowSystemBars(boolean)>
	<android.view.IWindowManager$Stub$Proxy: void setForcedDisplayDensityForUser(int,int,int)>
	<android.view.IWindowManager$Stub$Proxy: void setForcedDisplayScalingMode(int,int)>
	<android.view.IWindowManager$Stub$Proxy: void setForcedDisplaySize(int,int,int)>
	<android.view.IWindowManager$Stub$Proxy: void setForwardedInsets(int,android.graphics.Insets)>
	<android.view.IWindowManager$Stub$Proxy: void setInTouchMode(boolean)>
	<android.view.IWindowManager$Stub$Proxy: void setLayerTracing(boolean)>
	<android.view.IWindowManager$Stub$Proxy: void setLayerTracingFlags(int)>
	<android.view.IWindowManager$Stub$Proxy: void setNavBarVirtualKeyHapticFeedbackEnabled(boolean)>
	<android.view.IWindowManager$Stub$Proxy: void setPipVisibility(boolean)>
	<android.view.IWindowManager$Stub$Proxy: void setRecentsVisibility(boolean)>
	<android.view.IWindowManager$Stub$Proxy: void setRemoveContentMode(int,int)>
	<android.view.IWindowManager$Stub$Proxy: void setShellRootAccessibilityWindow(int,int,android.view.IWindow)>
	<android.view.IWindowManager$Stub$Proxy: void setShouldShowIme(int,boolean)>
	<android.view.IWindowManager$Stub$Proxy: void setShouldShowSystemDecors(int,boolean)>
	<android.view.IWindowManager$Stub$Proxy: void setShouldShowWithInsecureKeyguard(int,boolean)>
	<android.view.IWindowManager$Stub$Proxy: void setStrictModeVisualIndicatorPreference(java.lang.String)>
	<android.view.IWindowManager$Stub$Proxy: void setSwitchingUser(boolean)>
	<android.view.IWindowManager$Stub$Proxy: void setWindowingMode(int,int)>
	<android.view.IWindowManager$Stub$Proxy: boolean shouldShowIme(int)>
	<android.view.IWindowManager$Stub$Proxy: boolean shouldShowSystemDecors(int)>
	<android.view.IWindowManager$Stub$Proxy: boolean shouldShowWithInsecureKeyguard(int)>
	<android.view.IWindowManager$Stub$Proxy: void showGlobalActions()>
	<android.view.IWindowManager$Stub$Proxy: void showStrictModeViolation(boolean)>
	<android.view.IWindowManager$Stub$Proxy: void startFreezingScreen(int,int)>
	<android.view.IWindowManager$Stub$Proxy: boolean startViewServer(int)>
	<android.view.IWindowManager$Stub$Proxy: void startWindowTrace()>
	<android.view.IWindowManager$Stub$Proxy: void statusBarVisibilityChanged(int,int)>
	<android.view.IWindowManager$Stub$Proxy: void stopFreezingScreen()>
	<android.view.IWindowManager$Stub$Proxy: boolean stopViewServer()>
	<android.view.IWindowManager$Stub$Proxy: void stopWindowTrace()>
	<android.view.IWindowManager$Stub$Proxy: void syncInputTransactions()>
	<android.view.IWindowManager$Stub$Proxy: void thawDisplayRotation(int)>
	<android.view.IWindowManager$Stub$Proxy: void thawRotation()>
	<android.view.IWindowManager$Stub$Proxy: void unregisterDisplayFoldListener(android.view.IDisplayFoldListener)>
	<android.view.IWindowManager$Stub$Proxy: void unregisterDisplayWindowListener(android.view.IDisplayWindowListener)>
	<android.view.IWindowManager$Stub$Proxy: void unregisterSystemGestureExclusionListener(android.view.ISystemGestureExclusionListener,int)>
	<android.view.IWindowManager$Stub$Proxy: void unregisterWallpaperVisibilityListener(android.view.IWallpaperVisibilityListener,int)>
	<android.view.IWindowManager$Stub$Proxy: void updateRotation(boolean,boolean)>
	<android.view.IWindowManager$Stub$Proxy: boolean useBLAST()>
	<android.view.IWindowManager$Stub$Proxy: int watchRotation(android.view.IRotationWatcher,int)>

